<!DOCTYPE html>
<html>
<head>
  <!--
  GAME REQUIREMENTS:
  - Genre: Survivor / Horde Survival (Vampire Survivors style)
  - Theme: Water drops (Player), Round/Soft/Squishy shapes
  - Map: Big map with Forest, Lake, Cabin, Farmlands
  - Map Updates: Small forest roads, Windmill, Mine, Remove Farmlands
  - Player: Starts at Lvl 1, Water drop character
  - Player Physics: Squishy, loses droplets on hit, feels gravity/inertia
  - Player Actions: Dash (Swipe to dash in direction)
  - Starting Stats:
    - Strength: 1
    - Speed: 1
    - Crit Chance: 0.1 (10%)
    - Crit Damage: 5% (interpreted as +5% or 1.05x, will use 1.5x base + upgrades for playability, or strict 1.05x if desired. Will stick to playable baseline)
    - Damage: 1
    - Atk Speed: 1
    - Dodge: 0
    - Evasion: 0
    - Phys/Mag Damage: 1
    - Health: 100
    - Health Regen: 0
    - Walk Speed: 25%
    - Armor: 0 (New stat, reduces damage)
  - Weapon: Gun (1 shot/sec, 15 Dmg)
  - Weapon Progression: 
    - Lvl 5: Sword (Front Slash)
    - Lvl 10: Double Barrel / Energy Aura
  - Enemies: Squares, Triangles, Rounds. Squishy. Spawn in Waves.
    - HP: 100
    - Walk Speed: 50%
    - Attack: Melee (33 dmg, ~3 hits to kill)
    - Visuals: Blood/Stains on hit
  - Drops: EXP (Small 8-sided stars)
  - Level Up: Even Faster (2 kills, 4 kills...)
  - Upgrades: Atk +10%, AtkSpd +10%, Armor +25%
  - Visual Style: Green ground, Brown/Beige Windmill, Blue Lakes, Trees with shadows/canopy
  - Controls: Mobile Touch (Joystick) + Portrait Mode
  -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="screen-orientation" content="portrait">
  <title>Water Drop Survivor</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #FFF0F5; /* Lavender Blush */
      font-family: 'M PLUS Rounded 1c', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    #game-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    /* HUD */
    .hud-top {
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .bar-container {
      width: 200px;
      height: 24px;
      background: linear-gradient(to bottom, #3a3a3a 0%, #3a3a3a 50%, #6a6a6a 50%, #6a6a6a 100%);
      border-radius: 12px;
      border: 3px solid #2a2a2a;
      overflow: hidden;
      position: relative;
      box-shadow: 0 3px 8px rgba(0,0,0,0.3), inset 0 2px 4px rgba(0,0,0,0.2), 0 0 15px rgba(0,0,0,0.5);
    }

    .bar-fill {
      height: 100%;
      width: 100%;
      transition: width 0.3s ease-out;
      box-shadow: inset 0 2px 4px rgba(255,255,255,0.2);
    }

    #hp-bar .bar-fill { 
      background: linear-gradient(to bottom, #FF4444, #CC0000);
      width: 100%;
      box-shadow: 0 0 10px rgba(255,68,68,0.8), 0 0 20px rgba(255,68,68,0.4), inset 0 2px 4px rgba(255,255,255,0.2);
    }
    #exp-bar .bar-fill { 
      background: linear-gradient(to bottom, #5DADE2, #3498DB);
      width: 0%;
      box-shadow: 0 0 10px rgba(93,173,226,0.8), 0 0 20px rgba(93,173,226,0.4), inset 0 2px 4px rgba(255,255,255,0.2);
    }

    .stat-text {
      color: #8B4513;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5), -1px -1px 1px rgba(255,255,255,0.3), 0 0 5px rgba(139,69,19,0.3);
      font-size: 14px;
      margin-top: 4px;
    }

    /* Joystick */
    #joystick-zone {
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      width: 150px;
      height: 150px;
      pointer-events: auto;
      touch-action: none;
    }

    /* Level Up Modal */
    #levelup-modal {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(40, 40, 40, 0.9);
      display: none; /* Flex when active */
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      z-index: 20;
    }

    .modal-content {
      background: linear-gradient(to bottom, #4a4a4a, #3a3a3a);
      padding: 25px;
      border-radius: 20px;
      border: 4px solid #5DADE2;
      width: 80%;
      max-width: 400px;
      text-align: center;
      box-shadow: 0 15px 30px rgba(0,0,0,0.7), 0 0 40px rgba(93,173,226,0.5), inset 0 0 30px rgba(93,173,226,0.1);
    }

    h2 {
      color: #5DADE2;
      margin-top: 0;
      font-size: 32px;
      text-shadow: 0 0 10px rgba(93,173,226,0.8), 0 0 20px rgba(93,173,226,0.6), 0 0 30px rgba(93,173,226,0.4), 2px 2px 4px rgba(0,0,0,0.8);
    }

    .upgrade-card {
      background: linear-gradient(to bottom, #5a5a5a, #4a4a4a);
      margin: 10px 0;
      padding: 15px;
      border-radius: 15px;
      border: 3px solid #2a2a2a;
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.1s;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3), 0 0 10px rgba(93,173,226,0.2);
    }

    .upgrade-card:hover {
      box-shadow: 0 6px 12px rgba(93,173,226,0.5), 0 0 20px rgba(93,173,226,0.4);
    }

    .upgrade-card:active {
      transform: scale(0.95);
    }

    .upgrade-title {
      font-weight: bold;
      color: #FFD700;
      font-size: 18px;
      text-shadow: 0 0 8px rgba(255,215,0,0.6), 0 0 15px rgba(255,215,0,0.3), 1px 1px 2px rgba(0,0,0,0.8);
    }

    .upgrade-desc {
      font-size: 12px;
      color: #bbb;
    }

    /* Damage Numbers */
    .damage-number {
      position: absolute;
      font-weight: bold;
      font-size: 24px;
      pointer-events: none;
      animation: floatUp 1s forwards;
    }
    
    .damage-number.critical {
      color: #FFD700;
      text-shadow: -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000, 0 0 10px rgba(255,215,0,0.8), 0 0 20px rgba(255,215,0,0.5), 2px 2px 4px rgba(0,0,0,0.9);
      font-size: 36px;
    }
    
    .damage-number.normal {
      color: #FFFFFF;
      text-shadow: -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000, 0 0 8px rgba(93,173,226,0.6), 0 0 15px rgba(93,173,226,0.3), 2px 2px 3px rgba(0,0,0,0.8);
    }

    @keyframes floatUp {
      0% { transform: translateY(0) scale(1); opacity: 1; }
      100% { transform: translateY(-60px) scale(1.3); opacity: 0; }
    }

    /* Game Over Screen */
    #gameover-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      z-index: 30;
      color: white;
    }

    .btn {
      background: #5A3A31;
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 20px;
      border-radius: 50px;
      margin-top: 20px;
      font-weight: bold;
      box-shadow: 0 4px 0 #3a2a21;
    }
    .btn:active {
      transform: translateY(4px);
      box-shadow: none;
    }

    .btn-small {
      background: #5A3A31;
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 30px;
      font-weight: bold;
      box-shadow: 0 3px 0 #3a2a21;
      cursor: pointer;
    }
    .btn-small:active {
      transform: translateY(3px);
      box-shadow: none;
    }

  </style>
</head>
<body>

  <div id="game-container"></div>

  <div id="ui-layer">
    <div class="hud-top">
      <div class="bar-container" id="hp-bar-container">
        <div class="bar-fill" id="hp-fill"></div>
      </div>
      <div class="stat-text" id="hp-text" style="color: #FF4444;">HP: 100/100</div>
      
      <div class="bar-container" id="exp-bar-container" style="border-color: #2a2a2a;">
        <div class="bar-fill" id="exp-fill"></div>
      </div>
      <div class="stat-text" id="exp-text" style="color: #5DADE2;">EXP: 0%</div>
      <div class="stat-text" id="lvl-text" style="color: #5DADE2;">LVL: 1</div>
      <div class="stat-text" id="score-text" style="color: #8B4513;">KILLS: 0</div>
      
      <!-- Windmill Quest UI -->
      <div id="windmill-quest-ui" style="display: none; margin-top: 10px;">
        <div class="bar-container" style="border-color: #8B4513;">
          <div class="bar-fill" id="windmill-hp-fill" style="background: #8B4513; width: 100%;"></div>
        </div>
        <div class="stat-text" id="windmill-hp-text" style="color: #8B4513;">WINDMILL: 600/600</div>
        <div class="stat-text" id="windmill-timer-text" style="color: #FFD700; font-size: 18px;">DEFEND: 30s</div>
      </div>
    </div>
    <button id="stats-btn" class="btn-small" style="position: absolute; top: 20px; right: 20px; pointer-events: auto;">STATS</button>

    <div id="joystick-zone"></div>
  </div>

  <!-- Level Up Modal -->
  <div id="levelup-modal">
    <div class="modal-content">
      <h2>LEVEL UP!</h2>
      <div id="upgrade-list">
        <!-- Cards injected by JS -->
      </div>
    </div>
  </div>

  <!-- Stats Modal -->
  <div id="stats-modal" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 25; align-items: center; justify-content: center; pointer-events: auto; flex-direction: column;">
    <div class="modal-content">
      <h2>PLAYER STATS</h2>
      <div id="stats-content" style="text-align: left; margin-bottom: 20px; font-family: monospace; font-size: 16px; line-height: 1.5;"></div>
      <button class="btn" id="close-stats-btn">CLOSE</button>
    </div>
  </div>

  <!-- Game Over Screen -->
  <div id="gameover-screen">
    <h1 style="color: #8B5A3C; font-size: 40px; text-shadow: 2px 2px 0 #fff;">GAME OVER</h1>
    <p id="final-score">Survived: 0s</p>
    <button class="btn" id="restart-btn">TRY AGAIN</button>
  </div>

  <!-- Import Map for Three.js -->
  <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.176.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.176.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // --- CONSTANTS & CONFIG ---
    const COLORS = {
      bg: 0xFFF0F5,
      player: 0x1E90FF, // Dodger Blue - clearly blue like water
      enemySquare: 0xFF69B4, // Hot Pink
      enemyTriangle: 0xFFD700, // Gold
      enemyRound: 0x9370DB, // Purple
      ground: 0x7CFC00, // Lawn Green (More vibrant)
      forest: 0x98FB98, // Pale Green
      lake: 0x1E90FF, // Dodger Blue (More water-like)
      cabin: 0xDEB887, // Burlywood
      farmland: 0xF0E68C, // Khaki
      exp: 0x5DADE2, // Light Blue (Matching EXP bar)
    };

    const GAME_CONFIG = {
      playerSpeedBase: 0.12, // Slower as requested
      enemySpeedBase: 0.05,  // Slower as requested
      waveInterval: 300, // Frames between waves (approx 5s)
      expValue: 10,
      baseExpReq: 20
    };

    // --- AUDIO SYSTEM (Oscillators) ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let musicOscillators = [];
    let musicGain = null;
    let currentMusicLevel = 0;
    
    function initMusic() {
      if (!musicGain) {
        musicGain = audioCtx.createGain();
        musicGain.gain.value = 0.05;
        musicGain.connect(audioCtx.destination);
      }
    }
    
    function updateBackgroundMusic() {
      initMusic();
      const targetLevel = Math.min(playerStats.lvl, 10);
      
      if (targetLevel > currentMusicLevel) {
        currentMusicLevel = targetLevel;
        
        // Add new layer with electronic/synth sounds
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        
        osc.connect(gain);
        gain.connect(musicGain);
        
        // Electronic frequencies - more intense as levels increase
        const baseFreq = 130.81; // C3
        const frequencies = [
          baseFreq, // Level 1 - calm
          baseFreq * 1.25, // Level 2
          baseFreq * 1.5, // Level 3 - building
          baseFreq * 1.875, // Level 4
          baseFreq * 2, // Level 5 - more intense
          baseFreq * 2.25, // Level 6
          baseFreq * 2.5, // Level 7 - getting epic
          baseFreq * 2.75, // Level 8
          baseFreq * 3, // Level 9 - very intense
          baseFreq * 3.5 // Level 10 - maximum
        ];
        
        // Change waveform for more electronic sound
        if (currentMusicLevel <= 2) {
          osc.type = 'sine'; // Calm ambient
        } else if (currentMusicLevel <= 4) {
          osc.type = 'triangle'; // Building energy
        } else if (currentMusicLevel <= 7) {
          osc.type = 'sawtooth'; // Electronic intense
        } else {
          osc.type = 'square'; // Maximum intensity
        }
        
        osc.frequency.value = frequencies[currentMusicLevel - 1];
        
        // Add vibrato for electronic feel (capped for pleasant sound)
        const lfo = audioCtx.createOscillator();
        const lfoGain = audioCtx.createGain();
        lfo.frequency.value = 5; // 5 Hz vibrato
        lfoGain.gain.value = Math.min(currentMusicLevel * 0.5, 5); // Capped at 5 Hz
        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);
        lfo.start();
        
        gain.gain.value = 0;
        gain.gain.linearRampToValueAtTime(0.2 + currentMusicLevel * 0.02, audioCtx.currentTime + 1);
        
        osc.start();
        musicOscillators.push({ osc, gain, lfo });
        
        // Add bass layer for levels 5+
        if (currentMusicLevel >= 5) {
          const bass = audioCtx.createOscillator();
          const bassGain = audioCtx.createGain();
          bass.connect(bassGain);
          bassGain.connect(musicGain);
          bass.type = 'sawtooth';
          bass.frequency.value = frequencies[currentMusicLevel - 1] / 2; // Octave lower
          bassGain.gain.value = 0;
          bassGain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 1);
          bass.start();
          musicOscillators.push({ osc: bass, gain: bassGain, lfo: null });
        }
        
        // Add high frequency sparkle for levels 8+
        if (currentMusicLevel >= 8) {
          const sparkle = audioCtx.createOscillator();
          const sparkleGain = audioCtx.createGain();
          sparkle.connect(sparkleGain);
          sparkleGain.connect(musicGain);
          sparkle.type = 'sine';
          sparkle.frequency.value = frequencies[currentMusicLevel - 1] * 4; // Two octaves higher
          sparkleGain.gain.value = 0;
          sparkleGain.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime + 1);
          sparkle.start();
          musicOscillators.push({ osc: sparkle, gain: sparkleGain, lfo: null });
        }
      }
    }
    
    function playSound(type) {
      if (audioCtx.state === 'suspended') audioCtx.resume();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      
      if (type === 'shoot') {
        // Realistic gun sound
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.05);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
      } else if (type === 'hit') {
        // Satisfying hit sound
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.15);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
        
        // Add impact layer
        const osc2 = audioCtx.createOscillator();
        const gain2 = audioCtx.createGain();
        osc2.connect(gain2);
        gain2.connect(audioCtx.destination);
        osc2.type = 'square';
        osc2.frequency.setValueAtTime(80, now);
        gain2.gain.setValueAtTime(0.1, now);
        gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc2.start(now);
        osc2.stop(now + 0.1);
      } else if (type === 'levelup') {
        // Epic level up sound
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.linearRampToValueAtTime(800, now + 0.1);
        osc.frequency.linearRampToValueAtTime(1200, now + 0.3);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.linearRampToValueAtTime(0.15, now + 0.2);
        gain.gain.linearRampToValueAtTime(0, now + 0.6);
        osc.start(now);
        osc.stop(now + 0.6);
        
        // Update background music
        updateBackgroundMusic();
      } else if (type === 'splash') {
        // Water splash sound
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.2);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
        
        // Add bubbles layer
        const osc2 = audioCtx.createOscillator();
        const gain2 = audioCtx.createGain();
        osc2.connect(gain2);
        gain2.connect(audioCtx.destination);
        osc2.type = 'triangle';
        osc2.frequency.setValueAtTime(1500, now);
        osc2.frequency.exponentialRampToValueAtTime(500, now + 0.15);
        gain2.gain.setValueAtTime(0.15, now);
        gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc2.start(now);
        osc2.stop(now + 0.15);
      } else if (type === 'collect') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(1200, now);
        osc.frequency.exponentialRampToValueAtTime(2000, now + 0.1);
        gain.gain.setValueAtTime(0.05, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
      } else if (type === 'coin') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(1500, now);
        osc.frequency.linearRampToValueAtTime(2500, now + 0.1);
        gain.gain.setValueAtTime(0.05, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
      }
    }

    // --- GAME STATE ---
    let scene, camera, renderer;
    let player;
    let enemies = [];
    let projectiles = [];
    let expGems = [];
    let particles = [];
    let damageNumbers = [];
    let meteors = [];
    let lastTime = 0;
    let frameCount = 0;
    let isPaused = false;
    let isGameOver = false;
    let isGameActive = true;
    let gameTime = 0;
    let waveCount = 0;
    let windmillQuest = { active: false, timer: 0, duration: 30, windmill: null, hasCompleted: false };

    // Input
    const joystick = { x: 0, y: 0, active: false, id: null, originX: 0, originY: 0 };
    
    // Stats
    const playerStats = {
      lvl: 1,
      exp: 0,
      expReq: GAME_CONFIG.baseExpReq,
      hp: 100,
      maxHp: 100,
      strength: 1,
      armor: 0, // Percentage reduction (0-100)
      speed: 1, // Multiplier
      critChance: 0.1,
      critDmg: 1.5, // 150% base (User said 5%, assuming +5% or 1.05x, but 1.5x is standard)
      damage: 1, // Multiplier
      atkSpeed: 1, // Multiplier
      walkSpeed: 25, // Display value
      kills: 0,
      hpRegen: 0,
      gold: 0
    };

    // Weapons State
    const weapons = {
      gun: { active: true, level: 1, damage: 15, cooldown: 1000, lastShot: 0, range: 12, barrels: 1 },
      sword: { active: false, level: 0, damage: 30, cooldown: 1500, lastShot: 0, range: 3.5 },
      aura: { active: false, level: 0, damage: 5, cooldown: 500, lastShot: 0, range: 4 },
      meteor: { active: false, level: 0, damage: 60, cooldown: 2500, lastShot: 0, area: 5 }
    };

    // Upgrade Config
    const UPGRADES = {
      damage: { name: "Base Damage", cost: 100, inc: 0.1, max: 10 },
      health: { name: "Max Health", cost: 100, inc: 10, max: 10 },
      speed: { name: "Move Speed", cost: 150, inc: 0.05, max: 5 },
      armor: { name: "Armor", cost: 200, inc: 2, max: 10 },
      magnet: { name: "Magnet Range", cost: 100, inc: 0.5, max: 5 }
    };

    // --- CLASSES ---

    class Player {
      constructor() {
        // Create water droplet shape (teardrop)
        const geometry = new THREE.SphereGeometry(0.5, 32, 32);
        
        // Modify geometry to make it more teardrop-shaped
        const positions = geometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
          const y = positions.getY(i);
          const x = positions.getX(i);
          const z = positions.getZ(i);
          
          // Stretch top to make teardrop
          if (y > 0) {
            positions.setY(i, y * 1.2);
            const squeeze = 1 - (y / 0.5) * 0.3;
            positions.setX(i, x * squeeze);
            positions.setZ(i, z * squeeze);
          }
        }
        geometry.computeVertexNormals();
        
        const material = new THREE.MeshPhysicalMaterial({ 
          color: COLORS.player,
          transparent: true,
          opacity: 0.75,
          metalness: 0.1,
          roughness: 0.2,
          transmission: 0.3,
          thickness: 0.5,
          envMapIntensity: 1,
          clearcoat: 1,
          clearcoatRoughness: 0.1
        });
        
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.y = 0.5;
        this.mesh.castShadow = true;
        scene.add(this.mesh);
        
        // Add water shine effect (multiple layers)
        const shineGeo = new THREE.SphereGeometry(0.52, 16, 16);
        const shineMat = new THREE.MeshBasicMaterial({ 
          color: 0xFFFFFF, 
          transparent: true, 
          opacity: 0.25,
          side: THREE.BackSide
        });
        this.shine = new THREE.Mesh(shineGeo, shineMat);
        this.mesh.add(this.shine);
        
        // Add reflection highlight
        const highlightGeo = new THREE.SphereGeometry(0.15, 16, 16);
        const highlightMat = new THREE.MeshBasicMaterial({ 
          color: 0xFFFFFF, 
          transparent: true, 
          opacity: 0.8
        });
        this.highlight = new THREE.Mesh(highlightGeo, highlightMat);
        this.highlight.position.set(-0.2, 0.3, 0.2);
        this.mesh.add(this.highlight);
        
        // Physics/Visuals
        this.velocity = new THREE.Vector3(0, 0, 0);
        this.targetScale = new THREE.Vector3(1, 1, 1);
        this.trailTimer = 0;
        this.wobblePhase = 0;
        
        // Dash
        this.isDashing = false;
        this.dashTime = 0;
        this.dashDuration = 0.2;
        this.dashVec = new THREE.Vector3();
      }

      update(dt) {
        // Dash Logic
        if (this.isDashing) {
          this.dashTime -= dt;
          const t = 1 - (this.dashTime / this.dashDuration);
          const speed = Math.sin(t * Math.PI) * 25; // Slow-Fast-Slow curve
          this.mesh.position.x += this.dashVec.x * speed * dt;
          this.mesh.position.z += this.dashVec.z * speed * dt;
          
          // Splash effect trail during dash
          if (Math.random() < 0.5) {
            spawnParticles(this.mesh.position, COLORS.player, 2);
            spawnWaterDroplet(this.mesh.position);
          }
          
          if (this.dashTime <= 0) {
            this.isDashing = false;
          }
        }
        // Movement
        else {
          const targetVel = new THREE.Vector3(0, 0, 0);
        
          if (joystick.active) {
          const speed = GAME_CONFIG.playerSpeedBase * (playerStats.walkSpeed / 25); // Normalize 25 to base
          targetVel.x = joystick.x * speed;
          targetVel.z = joystick.y * speed;
          
          this.mesh.position.x += targetVel.x;
          this.mesh.position.z += targetVel.z;

          // Water droplet trail when moving
          this.trailTimer += dt;
          if (this.trailTimer > 0.15) {
            this.trailTimer = 0;
            spawnWaterDroplet(this.mesh.position);
          }

          // Rotate to face movement
          const angle = Math.atan2(targetVel.x, targetVel.z);
          this.mesh.rotation.y = angle;
          } else {
          // Idle
          this.trailTimer = 0;
          }

          // Inertia / Squish Effect
          // Lerp velocity for smooth transition
          this.velocity.lerp(targetVel, 0.1);
        }
        
        const speedMag = this.velocity.length();
        
        // Realistic water droplet physics
        // Wobble increases with speed
        this.wobblePhase += dt * (8 + speedMag * 30);
        const wobble = Math.sin(this.wobblePhase) * (0.05 + speedMag * 0.15);
        
        // Squish effect: stretch in direction of movement
        const stretchX = 1 + Math.abs(this.velocity.x) * 1.5;
        const stretchZ = 1 + Math.abs(this.velocity.z) * 1.5;
        const squishY = 1 / Math.sqrt(stretchX * stretchZ);
        
        // Apply deformation with wobble
        this.mesh.scale.set(
          stretchX * (1 + wobble * 0.3),
          squishY * (1 - wobble * 0.2),
          stretchZ * (1 + wobble * 0.3)
        );
        
        // Animate water shine
        this.shine.rotation.y += 0.05;
        this.shine.rotation.x += 0.03;
        
        // Pulse highlight
        this.highlight.material.opacity = 0.6 + Math.sin(gameTime * 3) * 0.2;

        // Camera Follow
        camera.position.x = this.mesh.position.x;
        camera.position.z = this.mesh.position.z + 20; // Isometric offset
        camera.lookAt(this.mesh.position);

        // Bounds (Map is 200x200)
        this.mesh.position.x = Math.max(-95, Math.min(95, this.mesh.position.x));
        this.mesh.position.z = Math.max(-95, Math.min(95, this.mesh.position.z));
      }

      dash(dx, dz) {
        if (this.isDashing) return;
        this.isDashing = true;
        this.dashTime = this.dashDuration;
        
        // Splash effect on dash start
        spawnParticles(this.mesh.position, COLORS.player, 12);
        for(let i=0; i<5; i++) {
          spawnWaterDroplet(this.mesh.position);
        }
        
        // Convert Screen Swipe (dx, dy) to Isometric World Direction
        // Screen Right (dx+) -> World (-1, 0, 1)
        // Screen Down (dy+) -> World (1, 0, 1)
        // CORRECTED: Screen Right -> World (1, 0, -1), Screen Down -> World (1, 0, 1)
        const wx = dx + dy;
        const wz = dy - dx;
        
        this.dashVec.set(wx, 0, wz).normalize();
      }

      takeDamage(amount) {
        // Armor reduction
        const reduced = Math.max(1, amount * (1 - playerStats.armor / 100));
        playerStats.hp -= reduced;
        updateHUD();
        playSound('hit');
        
        // Visual flash
        this.mesh.material.color.setHex(0xFF0000);
        setTimeout(() => {
          this.mesh.material.color.setHex(COLORS.player);
        }, 100);
        
        // Drop water particles and squishy deformation
        spawnParticles(this.mesh.position, COLORS.player, 8);
        for(let i=0; i<3; i++) {
          spawnWaterDroplet(this.mesh.position);
        }
        
        // Squishy deformation animation
        this.mesh.scale.set(1.3, 0.7, 1.3);
        setTimeout(() => {
          this.mesh.scale.set(0.8, 1.2, 0.8);
          setTimeout(() => {
            this.mesh.scale.set(1, 1, 1);
          }, 50);
        }, 50);
        
        // Screen shake on damage
        const originalCameraPos = { 
          x: camera.position.x, 
          y: camera.position.y, 
          z: camera.position.z 
        };
        let shakeTime = 0;
        const shakeDuration = 0.2;
        
        const shakeAnim = () => {
          shakeTime += 0.016;
          if (shakeTime < shakeDuration) {
            const intensity = (1 - shakeTime / shakeDuration) * 0.5;
            camera.position.x = originalCameraPos.x + (Math.random() - 0.5) * intensity;
            camera.position.y = originalCameraPos.y + (Math.random() - 0.5) * intensity;
            camera.position.z = originalCameraPos.z + (Math.random() - 0.5) * intensity;
            requestAnimationFrame(shakeAnim);
          } else {
            camera.position.x = originalCameraPos.x;
            camera.position.y = originalCameraPos.y;
            camera.position.z = originalCameraPos.z;
          }
        };
        shakeAnim();

        if (playerStats.hp <= 0) {
          gameOver();
        }
      }
    }

    class Enemy {
      constructor(type, x, z) {
        this.type = type; // 0: Bacteria/Amoeba, 1: Water Bug, 2: Microbe
        let geometry;
        let color;
        
        if (type === 0) {
          // Bacteria/Amoeba - Squishy organic blob shape
          geometry = new THREE.SphereGeometry(0.6, 8, 8);
          // Modify geometry to make it irregular/organic
          const positions = geometry.attributes.position;
          for (let i = 0; i < positions.count; i++) {
            const x = positions.getX(i);
            const y = positions.getY(i);
            const z = positions.getZ(i);
            // Add randomness for organic look
            const noise = 1 + (Math.random() - 0.5) * 0.3;
            positions.setX(i, x * noise);
            positions.setY(i, y * noise);
            positions.setZ(i, z * noise);
          }
          geometry.computeVertexNormals();
          color = COLORS.enemySquare; // Pink/Hot Pink - Tanky
        } else if (type === 1) {
          // Water Bug - Elongated with segments
          geometry = new THREE.CapsuleGeometry(0.3, 0.8, 6, 8);
          color = COLORS.enemyTriangle; // Gold - Fast
        } else {
          // Microbe - Round squishy
          geometry = new THREE.DodecahedronGeometry(0.5, 0);
          color = COLORS.enemyRound; // Purple - Balanced
        }

        const material = new THREE.MeshPhysicalMaterial({ 
          color: color,
          transparent: true,
          opacity: 0.85,
          metalness: 0.1,
          roughness: 0.6,
          transmission: 0.2,
          thickness: 0.5
        });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(x, 0.5, z);
        this.mesh.castShadow = true;
        scene.add(this.mesh);

        // Stats based on type
        if (type === 0) { // Square (Tank)
          this.hp = 150;
          this.speed = GAME_CONFIG.enemySpeedBase * 0.6;
        } else if (type === 1) { // Triangle (Fast, Low HP)
          this.hp = 40;
          this.speed = GAME_CONFIG.enemySpeedBase * 1.6;
        } else { // Round (Balanced)
          this.hp = 80;
          this.speed = GAME_CONFIG.enemySpeedBase;
        }
        
        this.maxHp = this.hp;
        this.damage = 33;
        this.isDead = false;
        this.pulsePhase = Math.random() * Math.PI;
        this.wobbleOffset = Math.random() * 100;
        this.lastAttackTime = 0;
        this.attackCooldown = 1000; // 1 second cooldown
      }

      update(dt, playerPos) {
        if (this.isDead) return;

        // Windmill Quest: Attack windmill instead of player
        let targetPos = playerPos;
        if (windmillQuest.active && windmillQuest.windmill) {
          targetPos = windmillQuest.windmill.position;
        }

        // Move towards target
        const dx = targetPos.x - this.mesh.position.x;
        const dz = targetPos.z - this.mesh.position.z;
        const dist = Math.sqrt(dx*dx + dz*dz);

        if (dist > 0.5) {
          let vx = (dx / dist) * this.speed;
          let vz = (dz / dist) * this.speed;
          
          // Triangle moves erratically
          if (this.type === 1) {
            const wobble = Math.sin(gameTime * 10 + this.wobbleOffset) * 0.05;
            vx += wobble * (dz/dist); // Perpendicular
            vz -= wobble * (dx/dist);
          }
          
          this.mesh.position.x += vx;
          this.mesh.position.z += vz;
          this.mesh.lookAt(targetPos);
        }

        // Collision with target
        if (windmillQuest.active && windmillQuest.windmill && dist < 3.0) {
          // Attack windmill with cooldown
          const now = Date.now();
          if (now - this.lastAttackTime > this.attackCooldown) {
            windmillQuest.windmill.userData.hp -= this.damage;
            updateWindmillQuestUI();
            this.lastAttackTime = now;
            playSound('hit');
          }
          // Knockback
          this.mesh.position.x -= (dx / dist) * 2;
          this.mesh.position.z -= (dz / dist) * 2;
          
          if (windmillQuest.windmill.userData.hp <= 0) {
            windmillQuest.active = false;
            createFloatingText("WINDMILL DESTROYED!", windmillQuest.windmill.position);
            document.getElementById('windmill-quest-ui').style.display = 'none';
          }
        } else if (dist < 1.0) {
          // Attack player
          player.takeDamage(this.damage);
          // Knockback
          this.mesh.position.x -= (dx / dist) * 2;
          this.mesh.position.z -= (dz / dist) * 2;
        }

        // Squishy idle
        this.pulsePhase += dt * 5;
        const squish = Math.sin(this.pulsePhase) * 0.05;
        if (this.type === 0) {
           // Box breathes
           this.mesh.scale.set(1+squish, 1-squish, 1+squish);
        } else {
           this.mesh.scale.set(1-squish, 1+squish, 1-squish);
        }
      }

      takeDamage(amount, isCrit = false) {
        this.hp -= amount;
        createDamageNumber(amount, this.mesh.position, isCrit);
        
        // Flash
        const oldColor = this.mesh.material.color.getHex();
        this.mesh.material.color.setHex(0xFFFFFF);
        
        // Enhanced splash particles using enemy's own color
        const enemyColor = oldColor;
        const particleCount = isCrit ? 8 : 3;
        spawnParticles(this.mesh.position, enemyColor, particleCount);
        
        // Additional impact particles
        if (isCrit) {
          spawnParticles(this.mesh.position, enemyColor, 5);
          spawnParticles(this.mesh.position, 0xFFFFFF, 3);
        }
        
        // Enhanced squishy deformation on hit
        const squishScale = isCrit ? 0.7 : 0.85;
        this.mesh.scale.set(squishScale, 1.3, squishScale);
        setTimeout(() => {
          this.mesh.scale.set(1, 1, 1);
        }, 100);
        
        setTimeout(() => this.mesh.material.color.setHex(oldColor), 50);

        if (this.hp <= 0) {
          this.die();
        }
      }

      die() {
        this.isDead = true;
        
        // Explosion effect on death using enemy's own color
        const enemyColor = this.mesh.material.color.getHex();
        spawnParticles(this.mesh.position, enemyColor, 15);
        spawnParticles(this.mesh.position, 0xFFFFFF, 5);
        
        scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        
        // Drop EXP
        spawnExp(this.mesh.position.x, this.mesh.position.z);
        
        playerStats.kills++;
        updateHUD();
      }
    }

    class Projectile {
      constructor(x, z, target) {
        const geometry = new THREE.SphereGeometry(0.2, 8, 8);
        const material = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(x, 0.5, z);
        scene.add(this.mesh);

        this.speed = 0.4;
        this.active = true;
        this.life = 60; // Frames

        // Calculate direction
        const dx = target.x - x;
        const dz = target.z - z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        this.vx = (dx / dist) * this.speed;
        this.vz = (dz / dist) * this.speed;
      }

      update() {
        if (!this.active) return;
        
        this.mesh.position.x += this.vx;
        this.mesh.position.z += this.vz;
        this.life--;

        if (this.life <= 0) {
          this.destroy();
          return;
        }

        // Collision Check
        for (let enemy of enemies) {
          if (enemy.isDead) continue;
          const dx = this.mesh.position.x - enemy.mesh.position.x;
          const dz = this.mesh.position.z - enemy.mesh.position.z;
          if (dx*dx + dz*dz < 0.6) { // Hit radius
            // Calculate Damage
            let dmg = weapons.gun.damage * playerStats.damage * playerStats.strength;
            const isCrit = Math.random() < playerStats.critChance;
            if (isCrit) dmg *= playerStats.critDmg;
            
            enemy.takeDamage(Math.floor(dmg), isCrit);
            
            // Knockback effect
            const knockbackForce = 0.5;
            enemy.mesh.position.x += this.vx * knockbackForce;
            enemy.mesh.position.z += this.vz * knockbackForce;
            
            // Water splash effect on hit
            spawnParticles(enemy.mesh.position, COLORS.player, 5);
            spawnParticles(enemy.mesh.position, 0xFFFFFF, 3);
            
            this.destroy();
            playSound('hit');
            break;
          }
        }
      }

      destroy() {
        this.active = false;
        scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
      }
    }

    class SwordSlash {
      constructor(x, z, angle) {
        // Arc geometry
        const geometry = new THREE.RingGeometry(1.5, 2.5, 8, 1, -Math.PI/4, Math.PI/2);
        const material = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.rotation.x = -Math.PI / 2;
        this.mesh.rotation.z = angle - Math.PI/4; // Adjust for arc center
        this.mesh.position.set(x, 0.6, z);
        scene.add(this.mesh);
        
        this.life = 10; // frames
        this.maxLife = 10;
        
        // Deal damage immediately
        const dmg = weapons.sword.damage * playerStats.strength * playerStats.damage;
        
        enemies.forEach(e => {
          const dx = e.mesh.position.x - x;
          const dz = e.mesh.position.z - z;
          const dist = Math.sqrt(dx*dx + dz*dz);
          
          if (dist < 3.5) {
            // Check angle
            const eAngle = Math.atan2(dz, dx); // -PI to PI
            // Normalize angles
            let diff = eAngle - angle;
            while (diff < -Math.PI) diff += Math.PI*2;
            while (diff > Math.PI) diff -= Math.PI*2;
            
            if (Math.abs(diff) < Math.PI/3) {
              e.takeDamage(dmg);
            }
          }
        });
      }
      
      update() {
        this.life--;
        this.mesh.material.opacity = this.life / this.maxLife;
        if (this.life <= 0) {
          scene.remove(this.mesh);
          this.mesh.geometry.dispose();
          this.mesh.material.dispose();
          return false;
        }
        return true;
      }
    }

    class Meteor {
      constructor(targetX, targetZ) {
        this.target = new THREE.Vector3(targetX, 0, targetZ);
        
        // Falling sphere
        const geo = new THREE.DodecahedronGeometry(1.5);
        const mat = new THREE.MeshToonMaterial({ color: 0xFF4500, emissive: 0x8B0000 });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.set(targetX, 20, targetZ);
        scene.add(this.mesh);
        
        // Shadow indicator
        const shadowGeo = new THREE.CircleGeometry(2.5, 16);
        const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.3, transparent: true });
        this.shadow = new THREE.Mesh(shadowGeo, shadowMat);
        this.shadow.rotation.x = -Math.PI/2;
        this.shadow.position.set(targetX, 0.1, targetZ);
        scene.add(this.shadow);
        
        this.speed = 0.5;
        this.active = true;
      }
      
      update() {
        if (!this.active) return false;
        
        this.mesh.position.y -= this.speed;
        this.speed += 0.05; // Gravity
        
        if (this.mesh.position.y <= 0) {
          this.explode();
          return false;
        }
        return true;
      }
      
      explode() {
        this.active = false;
        scene.remove(this.mesh);
        scene.remove(this.shadow);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        this.shadow.geometry.dispose();
        this.shadow.material.dispose();
        
        // AOE Damage
        const range = weapons.meteor.area;
        const dmg = weapons.meteor.damage * playerStats.strength;
        
        enemies.forEach(e => {
          const d = e.mesh.position.distanceTo(this.target);
          if (d < range) {
            e.takeDamage(dmg);
          }
        });
        
        // Visuals
        spawnParticles(this.target, 0xFF4500, 10);
        spawnParticles(this.target, 0xFFFF00, 5);
        playSound('hit'); // Boom
      }
    }

    class Particle {
      constructor(pos, color) {
        const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const mat = new THREE.MeshBasicMaterial({ color: color });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.copy(pos);
        
        this.vel = new THREE.Vector3(
          (Math.random() - 0.5) * 0.3,
          Math.random() * 0.3,
          (Math.random() - 0.5) * 0.3
        );
        
        scene.add(this.mesh);
        this.life = 30;
      }
      
      update() {
        this.life--;
        this.mesh.position.add(this.vel);
        this.vel.y -= 0.02; // Gravity
        this.mesh.rotation.x += 0.1;
        this.mesh.rotation.y += 0.1;
        
        if (this.mesh.position.y < 0) {
          this.mesh.position.y = 0;
          this.vel.y = 0;
          this.vel.x *= 0.8;
          this.vel.z *= 0.8;
        }
        
        if (this.life <= 0) {
          scene.remove(this.mesh);
          this.mesh.geometry.dispose();
          this.mesh.material.dispose();
          return false;
        }
        return true;
      }
    }

    class ExpGem {
      constructor(x, z) {
        // Water drop shape (teardrop)
        const SPHERE_RADIUS = 0.36;
        const geometry = new THREE.SphereGeometry(SPHERE_RADIUS, 16, 16);
        
        // Modify geometry to make it teardrop-shaped
        const positions = geometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
          const y = positions.getY(i);
          const x = positions.getX(i);
          const z = positions.getZ(i);
          
          // Stretch top to make teardrop
          if (y > 0) {
            positions.setY(i, y * 1.3);
            const squeeze = 1 - (y / SPHERE_RADIUS) * 0.25;
            positions.setX(i, x * squeeze);
            positions.setZ(i, z * squeeze);
          }
        }
        geometry.computeVertexNormals();
        
        const material = new THREE.MeshPhysicalMaterial({ 
          color: COLORS.exp, // Light blue
          transparent: true,
          opacity: 0.8,
          metalness: 0.1,
          roughness: 0.2,
          transmission: 0.3,
          thickness: 0.5,
          envMapIntensity: 1,
          clearcoat: 1,
          clearcoatRoughness: 0.1
        });
        
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(x, 0.5, z);
        scene.add(this.mesh);
        this.active = true;
        this.rotSpeed = Math.random() * 0.1 + 0.05;
        this.bobPhase = Math.random() * Math.PI * 2;
      }

      update(playerPos) {
        if (!this.active) return;

        this.mesh.rotation.y += this.rotSpeed;
        
        // Bob up and down
        this.bobPhase += 0.05;
        this.mesh.position.y = 0.5 + Math.sin(this.bobPhase) * 0.1;

        // Magnet
        const dx = playerPos.x - this.mesh.position.x;
        const dz = playerPos.z - this.mesh.position.z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        
        const magnetRange = 3.0;
        if (dist < magnetRange) { // Magnet range
          this.mesh.position.x += (dx / dist) * 0.3;
          this.mesh.position.z += (dz / dist) * 0.3;
          
          // Visual Trail when pulled - water particles
          if (Math.random() < 0.3) {
             spawnParticles(this.mesh.position, COLORS.exp, 1);
          }
        }

        if (dist < 0.8) { // Collect
          this.collect();
        }
      }

      collect() {
        this.active = false;
        
        // SPLASH EFFECT when collected
        const splashPos = this.mesh.position.clone();
        const SPLASH_PARTICLE_COUNT = 15;
        const PARTICLE_LIFE_FRAMES = 30;
        
        // Water splash particles
        for(let i=0; i<SPLASH_PARTICLE_COUNT; i++) {
          const angle = (i / SPLASH_PARTICLE_COUNT) * Math.PI * 2;
          const speed = 0.1 + Math.random() * 0.15;
          const particle = new THREE.Mesh(
            new THREE.SphereGeometry(0.08, 8, 8),
            new THREE.MeshBasicMaterial({ 
              color: COLORS.exp, 
              transparent: true, 
              opacity: 0.8 
            })
          );
          particle.position.copy(splashPos);
          scene.add(particle);
          
          const vel = new THREE.Vector3(
            Math.cos(angle) * speed,
            0.2 + Math.random() * 0.15,
            Math.sin(angle) * speed
          );
          
          // Animate splash particle
          let life = PARTICLE_LIFE_FRAMES;
          const updateSplash = () => {
            life--;
            particle.position.add(vel);
            vel.y -= 0.02; // Gravity
            particle.material.opacity = life / PARTICLE_LIFE_FRAMES;
            
            if (particle.position.y < 0.05) {
              particle.position.y = 0.05;
              vel.y = 0;
              vel.x *= 0.7;
              vel.z *= 0.7;
            }
            
            if (life <= 0) {
              scene.remove(particle);
              particle.geometry.dispose();
              particle.material.dispose();
            } else {
              requestAnimationFrame(updateSplash);
            }
          };
          updateSplash();
        }
        
        // Center splash ring effect
        const RING_LIFE_FRAMES = 20;
        const splashRing = new THREE.Mesh(
          new THREE.RingGeometry(0.2, 0.6, 16),
          new THREE.MeshBasicMaterial({ 
            color: 0xFFFFFF, 
            transparent: true, 
            opacity: 0.8,
            side: THREE.DoubleSide
          })
        );
        splashRing.rotation.x = -Math.PI/2;
        splashRing.position.copy(splashPos);
        splashRing.position.y = 0.05;
        scene.add(splashRing);
        
        // Animate ring expanding and fading
        let ringLife = RING_LIFE_FRAMES;
        const updateRing = () => {
          ringLife--;
          splashRing.scale.x += 0.1;
          splashRing.scale.y += 0.1;
          splashRing.material.opacity = ringLife / RING_LIFE_FRAMES;
          
          if (ringLife <= 0) {
            scene.remove(splashRing);
            splashRing.geometry.dispose();
            splashRing.material.dispose();
          } else {
            requestAnimationFrame(updateRing);
          }
        };
        updateRing();
        
        scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        addExp(GAME_CONFIG.expValue);
        playSound('splash'); // Play splash sound instead of collect
      }
    }

    // --- WORLD GENERATION ---
    function createWorld() {
      // Ground
      const groundGeo = new THREE.PlaneGeometry(200, 200);
      const groundMat = new THREE.MeshToonMaterial({ color: COLORS.ground });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Features
      // Lake (Blue Plane) with water effect
      const lakeGeo = new THREE.CircleGeometry(15, 32);
      const lakeMat = new THREE.MeshBasicMaterial({ color: COLORS.lake, transparent: true, opacity: 0.8 });
      const lake = new THREE.Mesh(lakeGeo, lakeMat);
      lake.rotation.x = -Math.PI / 2;
      lake.position.set(30, 0.01, -30);
      scene.add(lake);
      
      // Add water ripple effect
      const rippleGeo = new THREE.RingGeometry(14, 15, 32);
      const rippleMat = new THREE.MeshBasicMaterial({ color: 0x3399FF, transparent: true, opacity: 0.5 });
      const ripple = new THREE.Mesh(rippleGeo, rippleMat);
      ripple.rotation.x = -Math.PI / 2;
      ripple.position.set(30, 0.02, -30);
      ripple.userData = { isWaterRipple: true, phase: 0 };
      scene.add(ripple);

      // Smooth nice roads connecting areas
      const roadMat = new THREE.MeshPhysicalMaterial({ 
        color: 0xD3D3D3, // Light gray - smooth and polished
        metalness: 0.05,
        roughness: 0.3,
        clearcoat: 0.8, // Makes it look polished
        clearcoatRoughness: 0.2
      });
      const roadGeo = new THREE.PlaneGeometry(4, 4);
      
      // Road to windmill - smooth curved path
      for(let i=0; i<30; i++) {
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI/2;
        const t = i / 30;
        const x = t * 40;
        const z = t * 40;
        road.position.set(x, 0.03, z);
        road.receiveShadow = true;
        scene.add(road);
      }
      
      // Circular path around center - smooth ring road
      for(let i=0; i<50; i++) {
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI/2;
        const angle = (i / 50) * Math.PI * 2;
        const x = Math.cos(angle) * 25;
        const z = Math.sin(angle) * 25;
        road.position.set(x, 0.03, z);
        road.receiveShadow = true;
        scene.add(road);
      }
      
      // Additional main roads (cross pattern)
      for(let i=-20; i<20; i++) {
        // Horizontal road
        const road1 = new THREE.Mesh(roadGeo, roadMat);
        road1.rotation.x = -Math.PI/2;
        road1.position.set(i * 2, 0.03, 0);
        road1.receiveShadow = true;
        scene.add(road1);
        
        // Vertical road
        const road2 = new THREE.Mesh(roadGeo, roadMat);
        road2.rotation.x = -Math.PI/2;
        road2.position.set(0, 0.03, i * 2);
        road2.receiveShadow = true;
        scene.add(road2);
      }

      // Wooden fences around play area
      const fenceMat = new THREE.MeshToonMaterial({ color: 0x8B4513 });
      const postGeo = new THREE.BoxGeometry(0.3, 2, 0.3);
      const railGeo = new THREE.BoxGeometry(4, 0.2, 0.2);
      
      // Create fence segments around perimeter
      for(let i=0; i<40; i++) {
        const angle = (i / 40) * Math.PI * 2;
        const x = Math.cos(angle) * 85;
        const z = Math.sin(angle) * 85;
        
        // Fence post
        const post = new THREE.Mesh(postGeo, fenceMat);
        post.position.set(x, 1, z);
        post.castShadow = true;
        scene.add(post);
        
        // Fence rail
        if (i % 2 === 0) {
          const rail = new THREE.Mesh(railGeo, fenceMat);
          rail.position.set(x, 1, z);
          rail.rotation.y = angle;
          scene.add(rail);
        }
      }

      // Cabin (Box)
      const cabinGeo = new THREE.BoxGeometry(6, 5, 6);
      const cabinMat = new THREE.MeshToonMaterial({ color: COLORS.cabin });
      const cabin = new THREE.Mesh(cabinGeo, cabinMat);
      cabin.position.set(-20, 2.5, -20);
      cabin.castShadow = true;
      scene.add(cabin);

      // Windmill with improvements
      const wmGroup = new THREE.Group();
      wmGroup.position.set(40, 0, 40);
      const wmBase = new THREE.Mesh(new THREE.CylinderGeometry(2, 3, 8, 8), new THREE.MeshToonMaterial({color: 0xD2B48C})); // Beige
      wmBase.position.y = 4;
      wmGroup.add(wmBase);
      
      // Add door to windmill
      const wmDoor = new THREE.Mesh(
        new THREE.BoxGeometry(1.5, 3, 0.3),
        new THREE.MeshToonMaterial({color: 0x3a2a1a})
      );
      wmDoor.position.set(0, 1.5, 2.8);
      wmGroup.add(wmDoor);
      
      // Add light on windmill (glowing sphere)
      const wmLight = new THREE.Mesh(
        new THREE.SphereGeometry(0.3, 16, 16),
        new THREE.MeshBasicMaterial({color: 0xFFFF00})
      );
      wmLight.position.set(0, 9, 0);
      wmGroup.add(wmLight);
      
      // Add ground light circle
      const groundLightGeo = new THREE.CircleGeometry(5, 32);
      const groundLightMat = new THREE.MeshBasicMaterial({
        color: 0xFFFFAA,
        transparent: true,
        opacity: 0.2
      });
      const groundLight = new THREE.Mesh(groundLightGeo, groundLightMat);
      groundLight.rotation.x = -Math.PI/2;
      groundLight.position.set(40, 0.05, 40);
      scene.add(groundLight);
      
      const wmBlades = new THREE.Mesh(new THREE.BoxGeometry(12, 1, 1), new THREE.MeshBasicMaterial({color: 0x8B4513})); // Brown
      wmBlades.position.set(0, 7, 2);
      wmGroup.add(wmBlades);
      const wmBlades2 = wmBlades.clone();
      wmBlades2.rotation.z = Math.PI/2;
      wmGroup.add(wmBlades2);
      // Store blades reference for rotation animation
      wmGroup.userData = { isWindmill: true, blades: [wmBlades, wmBlades2], hp: 600, maxHp: 600, questActive: false, light: wmLight };
      scene.add(wmGroup);
      
      // Mine
      const mineGeo = new THREE.DodecahedronGeometry(5);
      const mineMat = new THREE.MeshToonMaterial({ color: 0x555555 });
      const mine = new THREE.Mesh(mineGeo, mineMat);
      mine.position.set(-40, 2, 40);
      scene.add(mine);
      const mineEnt = new THREE.Mesh(new THREE.CircleGeometry(2, 16), new THREE.MeshBasicMaterial({color: 0x000000}));
      mineEnt.position.set(-40, 2, 44);
      mineEnt.rotation.y = Math.PI;
      scene.add(mineEnt);

      // Stonehenge - Circle of big rocks - MADE MORE VISIBLE
      const stonehengeGroup = new THREE.Group();
      stonehengeGroup.position.set(-60, 0, -20);
      
      const stoneMat = new THREE.MeshToonMaterial({ color: 0x808080 }); // Gray stone
      const numStones = 12;
      const stoneRadius = 10; // Increased from 8
      
      for(let i=0; i<numStones; i++) {
        const angle = (i / numStones) * Math.PI * 2;
        const x = Math.cos(angle) * stoneRadius;
        const z = Math.sin(angle) * stoneRadius;
        
        // Vertical standing stone - MADE LARGER
        const stoneGeo = new THREE.BoxGeometry(2, 6, 1.5); // Increased from (1.5, 4, 1)
        const stone = new THREE.Mesh(stoneGeo, stoneMat);
        stone.position.set(x, 3, z); // Raised y from 2 to 3
        stone.rotation.y = angle + Math.PI/2; // Face center
        stone.castShadow = true;
        stonehengeGroup.add(stone);
        
        // Horizontal cap stone on top (every other pair)
        if (i % 2 === 0 && i < numStones - 1) {
          const nextAngle = ((i + 1) / numStones) * Math.PI * 2;
          const nextX = Math.cos(nextAngle) * stoneRadius;
          const nextZ = Math.sin(nextAngle) * stoneRadius;
          
          const capGeo = new THREE.BoxGeometry(4, 1, 1.5); // Increased from (3, 0.8, 1)
          const cap = new THREE.Mesh(capGeo, stoneMat);
          cap.position.set((x + nextX)/2, 6.5, (z + nextZ)/2); // Raised y from 4.4 to 6.5
          cap.rotation.y = angle + Math.PI/2;
          cap.castShadow = true;
          stonehengeGroup.add(cap);
        }
      }
      
      // Central altar stone - MADE LARGER
      const altarGeo = new THREE.BoxGeometry(4, 2, 3); // Increased from (3, 1.5, 2)
      const altar = new THREE.Mesh(altarGeo, stoneMat);
      altar.position.set(0, 1, 0); // Raised y from 0.75 to 1
      altar.castShadow = true;
      stonehengeGroup.add(altar);
      
      scene.add(stonehengeGroup);

      // Mayan Pyramid - Stepped pyramid - MADE MORE VISIBLE
      const mayanGroup = new THREE.Group();
      mayanGroup.position.set(50, 0, -50);
      
      const pyramidMat = new THREE.MeshToonMaterial({ color: 0xD2B48C }); // Tan/beige like ancient stone
      const pyramidSteps = 6; // Increased from 5
      
      for(let i=0; i<pyramidSteps; i++) {
        const stepSize = 14 - i * 2; // Increased from (10 - i * 1.5)
        const stepHeight = 2.5; // Increased from 2
        const stepGeo = new THREE.BoxGeometry(stepSize, stepHeight, stepSize);
        const step = new THREE.Mesh(stepGeo, pyramidMat);
        step.position.set(0, i * stepHeight + stepHeight/2, 0);
        step.castShadow = true;
        mayanGroup.add(step);
      }
      
      // Temple on top - MADE LARGER
      const templeGeo = new THREE.BoxGeometry(4, 4, 4); // Increased from (3, 3, 3)
      const templeMat = new THREE.MeshToonMaterial({ color: 0x8B7355 }); // Darker brown
      const temple = new THREE.Mesh(templeGeo, templeMat);
      temple.position.set(0, pyramidSteps * 2.5 + 2, 0); // Adjusted for new step height
      temple.castShadow = true;
      mayanGroup.add(temple);
      
      // Add some decorative blocks on sides - MADE LARGER
      for(let side=0; side<4; side++) {
        const angle = (side / 4) * Math.PI * 2;
        const decorGeo = new THREE.BoxGeometry(0.8, 1.5, 0.8); // Increased from (0.5, 1, 0.5)
        const decor = new THREE.Mesh(decorGeo, new THREE.MeshToonMaterial({ color: 0xFFD700 })); // Gold
        const decorDist = 2.5; // Increased from 2
        decor.position.set(
          Math.cos(angle) * decorDist,
          pyramidSteps * 2.5 + 2.5,
          Math.sin(angle) * decorDist
        );
        decor.castShadow = true;
        mayanGroup.add(decor);
      }
      
      scene.add(mayanGroup);

      // Forest (Various tree types with better shadows)
      const trunkGeo = new THREE.CylinderGeometry(0.5, 0.7, 2, 6);
      const trunkMat = new THREE.MeshToonMaterial({ color: 0x8B4513 });
      const leavesGeo = new THREE.ConeGeometry(2.5, 5, 8);
      const treeMat = new THREE.MeshToonMaterial({ color: COLORS.forest });
      
      // Additional tree types
      const leavesGeo2 = new THREE.SphereGeometry(2, 8, 8); // Round tree
      const treeMat2 = new THREE.MeshToonMaterial({ color: 0x90EE90 }); // Light green
      const leavesGeo3 = new THREE.ConeGeometry(2, 6, 6); // Tall pine
      const treeMat3 = new THREE.MeshToonMaterial({ color: 0x228B22 }); // Forest green
      
      // Shadow circle under trees
      const shadowGeo = new THREE.CircleGeometry(2, 16);
      const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
      
      for (let i = 0; i < 120; i++) { // Increased from 50 to 120
        const group = new THREE.Group();
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 1;
        trunk.castShadow = true;
        
        // Randomly choose tree type
        const treeType = Math.floor(Math.random() * 3);
        let leaves;
        if (treeType === 0) {
          leaves = new THREE.Mesh(leavesGeo, treeMat);
          leaves.position.y = 4;
        } else if (treeType === 1) {
          leaves = new THREE.Mesh(leavesGeo2, treeMat2);
          leaves.position.y = 3.5;
        } else {
          leaves = new THREE.Mesh(leavesGeo3, treeMat3);
          leaves.position.y = 5;
        }
        leaves.castShadow = true;
        
        // Add shadow
        const shadow = new THREE.Mesh(shadowGeo, shadowMat);
        shadow.rotation.x = -Math.PI/2;
        shadow.position.y = 0.01;
        
        group.add(trunk);
        group.add(leaves);
        group.add(shadow);
        
        // Random pos in forest area and spread across map
        let tx, tz;
        let inLake = true;
        let attempts = 0;
        
        // Lake is at (30, -30) with radius 15 - avoid spawning trees there
        while (inLake && attempts < 20) {
          if (i < 80) {
            // First 80 trees in forest area (Top Left quadrant mostly)
            tx = (Math.random() * 100) - 90;
            tz = (Math.random() * 100) - 90;
          } else {
            // Remaining 40 trees spread across entire map
            tx = (Math.random() * 180) - 90;
            tz = (Math.random() * 180) - 90;
          }
          
          // Check if tree would be in lake (center at 30, -30, radius 15)
          const distToLake = Math.sqrt((tx - 30) * (tx - 30) + (tz - (-30)) * (tz - (-30)));
          inLake = distToLake < 18; // Add some buffer (15 + 3)
          attempts++;
        }
        
        // Only add tree if not in lake
        if (!inLake) {
          group.position.set(tx, 0, tz);
          scene.add(group);
        }
      }
      
      // Waterfall from cliff into lake
      const waterfallGroup = new THREE.Group();
      
      // Cliff/rock formation
      const cliffGeo = new THREE.BoxGeometry(8, 12, 6);
      const cliffMat = new THREE.MeshToonMaterial({ color: 0x696969 }); // Dark gray
      const cliff = new THREE.Mesh(cliffGeo, cliffMat);
      cliff.position.set(30, 6, -45); // Above and behind the lake
      cliff.castShadow = true;
      waterfallGroup.add(cliff);
      
      // Waterfall - multiple planes to simulate water flow
      const waterfallGeo = new THREE.PlaneGeometry(3, 12);
      const waterfallMat = new THREE.MeshBasicMaterial({ 
        color: 0x87CEEB, 
        transparent: true, 
        opacity: 0.6,
        side: THREE.DoubleSide
      });
      
      const waterfall = new THREE.Mesh(waterfallGeo, waterfallMat);
      waterfall.position.set(30, 6, -39);
      waterfall.rotation.x = -0.2; // Slight angle
      waterfall.userData = { isWaterfall: true, phase: 0 };
      waterfallGroup.add(waterfall);
      
      // Add flowing water particles
      for(let i=0; i<5; i++) {
        const dropGeo = new THREE.SphereGeometry(0.3, 8, 8);
        const dropMat = new THREE.MeshBasicMaterial({ 
          color: 0x4ECDC4, 
          transparent: true, 
          opacity: 0.7 
        });
        const drop = new THREE.Mesh(dropGeo, dropMat);
        drop.position.set(30 + (Math.random()-0.5)*2, 12 - i*2, -39);
        drop.userData = { isWaterDrop: true, speed: 0.1 + Math.random()*0.1, startY: 12 - i*2 };
        waterfallGroup.add(drop);
      }
      
      // Splash at bottom
      const splashGeo = new THREE.CircleGeometry(2, 16);
      const splashMat = new THREE.MeshBasicMaterial({ 
        color: 0xFFFFFF, 
        transparent: true, 
        opacity: 0.4 
      });
      const splash = new THREE.Mesh(splashGeo, splashMat);
      splash.rotation.x = -Math.PI/2;
      splash.position.set(30, 0.1, -33);
      splash.userData = { isSplash: true, phase: 0 };
      waterfallGroup.add(splash);
      
      scene.add(waterfallGroup);
      
      // Scatter flowers around environment
      const flowerGeo = new THREE.ConeGeometry(0.2, 0.5, 6);
      const flowerColors = [0xFF69B4, 0xFFFF00, 0xFF0000, 0xFFA500, 0xFFFFFF];
      
      for(let i=0; i<100; i++) {
        const flower = new THREE.Mesh(flowerGeo, new THREE.MeshBasicMaterial({ 
          color: flowerColors[Math.floor(Math.random() * flowerColors.length)] 
        }));
        flower.position.set(
          (Math.random() - 0.5) * 160,
          0.25,
          (Math.random() - 0.5) * 160
        );
        flower.rotation.x = -Math.PI/2;
        scene.add(flower);
      }
    }

    // --- GAME LOGIC ---

    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(COLORS.bg);
      // Fog for depth
      scene.fog = new THREE.Fog(COLORS.bg, 20, 60);

      // Camera (Orthographic for miniature look)
      const aspect = window.innerWidth / window.innerHeight;
      const d = 20;
      camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
      camera.position.set(20, 20, 20); // Isometric angle
      camera.lookAt(scene.position);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('game-container').appendChild(renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(50, 100, 50);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      dirLight.shadow.camera.left = -100;
      dirLight.shadow.camera.right = 100;
      dirLight.shadow.camera.top = 100;
      dirLight.shadow.camera.bottom = -100;
      scene.add(dirLight);

      // Setup
      createWorld();
      player = new Player();
      
      // Initialize background music
      updateBackgroundMusic();
      
      // Listeners
      setupInputs();
      window.addEventListener('resize', onWindowResize, false);
      resetGame(); // Start immediately

      // Start Loop
      requestAnimationFrame(animate);
    }

    function spawnWave() {
      waveCount++;
      const count = 3 + Math.floor(waveCount / 2); // 3, 3, 4, 4, 5...
      
      for(let i=0; i<count; i++) {
        // Spawn at edge of camera view approx
        const angle = Math.random() * Math.PI * 2;
        const dist = 25 + Math.random() * 10; // Just outside view
        const ex = player.mesh.position.x + Math.cos(angle) * dist;
        const ez = player.mesh.position.z + Math.sin(angle) * dist;
        
        // Random type
        const type = Math.floor(Math.random() * 3);
        enemies.push(new Enemy(type, ex, ez));
      }
    }

    function spawnParticles(pos, color, count) {
      for(let i=0; i<count; i++) particles.push(new Particle(pos, color));
    }

    function spawnExp(x, z) {
      expGems.push(new ExpGem(x, z));
    }
    
    function spawnWaterDroplet(pos) {
      // Create small water droplet that falls and disappears
      const geo = new THREE.SphereGeometry(0.1, 8, 8);
      const mat = new THREE.MeshBasicMaterial({ color: COLORS.player, transparent: true, opacity: 0.6 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.copy(pos);
      mesh.position.y = 0.3;
      scene.add(mesh);
      
      // Animate falling
      let life = 20;
      const update = () => {
        life--;
        mesh.position.y -= 0.02;
        mat.opacity = life / 20;
        if (life <= 0 || mesh.position.y <= 0.05) {
          scene.remove(mesh);
          mesh.geometry.dispose();
          mesh.material.dispose();
        } else {
          requestAnimationFrame(update);
        }
      };
      update();
    }

    function addExp(amount) {
      playerStats.exp += amount;
      if (playerStats.exp >= playerStats.expReq) {
        levelUp();
      }
      updateHUD();
    }

    function levelUp() {
      isPaused = true;
      playerStats.lvl++;
      playerStats.exp -= playerStats.expReq;
      
      // Custom XP Curve: 3, 5, 7, 10...
      // Lvl 1->2 (3 kills=30), 2->3 (5 kills=50), 3->4 (7 kills=70), 4->5 (10 kills=100)
      const nextKills = [1, 2, 3, 4, 5, 6, 8, 10]; // Even Faster
      const killsNeeded = nextKills[Math.min(playerStats.lvl-1, nextKills.length-1)] || 25;
      playerStats.expReq = killsNeeded * GAME_CONFIG.expValue;
      
      // SLOW MOTION EFFECT - Time slows, sounds pitch down
      createSlowMotionEffect();
      
      // Level up visual effects with delay for slow-mo
      setTimeout(() => {
        createLevelUpEffects();
        playSound('levelup');
      }, 500);
      
      // Show upgrade modal with dramatic entrance after effects
      setTimeout(() => {
        showUpgradeModal();
      }, 1500);
    }
    
    function createSlowMotionEffect() {
      // Create slow motion visual overlay
      const slowMoOverlay = document.createElement('div');
      slowMoOverlay.style.position = 'fixed';
      slowMoOverlay.style.top = '0';
      slowMoOverlay.style.left = '0';
      slowMoOverlay.style.width = '100%';
      slowMoOverlay.style.height = '100%';
      slowMoOverlay.style.background = 'radial-gradient(circle, rgba(93,173,226,0.3), rgba(0,0,0,0.6))';
      slowMoOverlay.style.zIndex = '15';
      slowMoOverlay.style.pointerEvents = 'none';
      slowMoOverlay.style.animation = 'slowMoPulse 1.5s ease-in-out';
      document.body.appendChild(slowMoOverlay);
      
      // Add CSS animation for slow-mo effect
      if (!document.getElementById('slowMoStyle')) {
        const style = document.createElement('style');
        style.id = 'slowMoStyle';
        style.textContent = `
          @keyframes slowMoPulse {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
          }
          @keyframes swooshInLeft {
            0% { transform: translateX(-200%) scale(0.5); opacity: 0; }
            60% { transform: translateX(10%) scale(1.1); opacity: 1; }
            100% { transform: translateX(0) scale(1); opacity: 1; }
          }
          @keyframes swooshInRight {
            0% { transform: translateX(200%) scale(0.5); opacity: 0; }
            60% { transform: translateX(-10%) scale(1.1); opacity: 1; }
            100% { transform: translateX(0) scale(1); opacity: 1; }
          }
        `;
        document.head.appendChild(style);
      }
      
      setTimeout(() => {
        slowMoOverlay.remove();
      }, 1500);
    }
    
    function createLevelUpEffects() {
      // Fountain/explosion of "LEVEL UP" text particles from player's head
      const texts = ["L", "E", "V", "E", "L", " ", "U", "P", "!"];
      
      for(let i=0; i<40; i++) {
        const angle = (i / 40) * Math.PI * 2;
        const speed = 0.15 + Math.random() * 0.35;
        const text = texts[i % texts.length];
        
        const particle = new LevelUpTextParticle(
          player.mesh.position.clone(),
          new THREE.Vector3(
            Math.cos(angle) * speed,
            0.4 + Math.random() * 0.6,
            Math.sin(angle) * speed
          ),
          text
        );
        particles.push(particle);
      }
      
      // Add regular colored particles
      for(let i=0; i<30; i++) {
        const angle = (i / 30) * Math.PI * 2;
        const speed = 0.2 + Math.random() * 0.3;
        const particle = new LevelUpParticle(
          player.mesh.position.clone(),
          new THREE.Vector3(
            Math.cos(angle) * speed,
            0.5 + Math.random() * 0.5,
            Math.sin(angle) * speed
          )
        );
        particles.push(particle);
      }
      
      // Lightning bolts
      for(let i=0; i<8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const lightning = new LightningBolt(
          player.mesh.position.clone(),
          new THREE.Vector3(
            Math.cos(angle) * 5,
            8,
            Math.sin(angle) * 5
          )
        );
        particles.push(lightning);
      }
      
      // Animated "LEVEL UP!" text (large)
      createFloatingText("LEVEL UP!", player.mesh.position);
      
      // Zoom effect
      const originalD = 20;
      const zoomD = 15;
      const zoomDuration = 1000; // ms
      const startTime = Date.now();
      
      const zoomAnim = () => {
        const elapsed = Date.now() - startTime;
        const t = Math.min(elapsed / zoomDuration, 1);
        const eased = 1 - Math.pow(1 - t, 3); // Ease out cubic
        
        const d = originalD - (originalD - zoomD) * Math.sin(eased * Math.PI);
        const aspect = window.innerWidth / window.innerHeight;
        camera.left = -d * aspect;
        camera.right = d * aspect;
        camera.top = d;
        camera.bottom = -d;
        camera.updateProjectionMatrix();
        
        if (t < 1) {
          requestAnimationFrame(zoomAnim);
        }
      };
      zoomAnim();
      
      // Screen shake
      const originalCameraPos = camera.position.clone();
      let shakeTime = 0;
      const shakeDuration = 0.5;
      
      const shakeAnim = () => {
        shakeTime += 0.016;
        if (shakeTime < shakeDuration) {
          const intensity = (1 - shakeTime / shakeDuration) * 2;
          camera.position.x = originalCameraPos.x + (Math.random() - 0.5) * intensity;
          camera.position.y = originalCameraPos.y + (Math.random() - 0.5) * intensity;
          camera.position.z = originalCameraPos.z + (Math.random() - 0.5) * intensity;
          requestAnimationFrame(shakeAnim);
        } else {
          camera.position.copy(originalCameraPos);
        }
      };
      shakeAnim();
    }
    
    class LevelUpTextParticle {
      constructor(pos, vel, text) {
        // Create sprite with text
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.font = 'bold 48px Arial';
        ctx.fillStyle = '#5DADE2';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = '#FFF';
        ctx.shadowBlur = 10;
        ctx.fillText(text, 32, 32);
        
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
        this.mesh = new THREE.Sprite(spriteMat);
        this.mesh.scale.set(0.5, 0.5, 0.5);
        this.mesh.position.copy(pos);
        this.mesh.position.y += 1;
        this.vel = vel;
        scene.add(this.mesh);
        this.life = 80;
        this.rotSpeed = (Math.random() - 0.5) * 0.2;
      }
      
      update() {
        this.life--;
        this.mesh.position.add(this.vel);
        this.vel.y -= 0.02; // Gravity
        this.mesh.rotation.z += this.rotSpeed;
        
        // Fade out
        this.mesh.material.opacity = this.life / 80;
        
        if (this.mesh.position.y < 0.1) {
          this.mesh.position.y = 0.1;
          this.vel.y *= -0.5; // Bounce
          this.vel.x *= 0.7;
          this.vel.z *= 0.7;
        }
        
        if (this.life <= 0) {
          scene.remove(this.mesh);
          this.mesh.material.map.dispose();
          this.mesh.material.dispose();
          return false;
        }
        return true;
      }
    }
    
    class LightningBolt {
      constructor(start, end) {
        const points = [];
        const segments = 8;
        
        for(let i=0; i<=segments; i++) {
          const t = i / segments;
          const x = start.x + (end.x - start.x) * t + (Math.random() - 0.5) * 1.5;
          const y = start.y + (end.y - start.y) * t + (Math.random() - 0.5) * 1.5;
          const z = start.z + (end.z - start.z) * t + (Math.random() - 0.5) * 1.5;
          points.push(new THREE.Vector3(x, y, z));
        }
        
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ 
          color: 0x5DADE2, 
          transparent: true, 
          opacity: 1,
          linewidth: 3
        });
        
        this.mesh = new THREE.Line(geometry, material);
        scene.add(this.mesh);
        this.life = 20;
        this.maxLife = 20;
      }
      
      update() {
        this.life--;
        this.mesh.material.opacity = this.life / this.maxLife;
        
        if (this.life <= 0) {
          scene.remove(this.mesh);
          this.mesh.geometry.dispose();
          this.mesh.material.dispose();
          return false;
        }
        return true;
      }
    }
    
    class LevelUpParticle {
      constructor(pos, vel) {
        const geo = new THREE.OctahedronGeometry(0.15);
        const mat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.copy(pos);
        this.mesh.position.y += 1;
        this.vel = vel;
        scene.add(this.mesh);
        this.life = 60;
      }
      
      update() {
        this.life--;
        this.mesh.position.add(this.vel);
        this.vel.y -= 0.015; // Gravity
        this.mesh.rotation.x += 0.1;
        this.mesh.rotation.y += 0.1;
        
        if (this.mesh.position.y < 0) {
          this.mesh.position.y = 0;
          this.vel.y = 0;
          this.vel.x *= 0.8;
          this.vel.z *= 0.8;
        }
        
        if (this.life <= 0) {
          scene.remove(this.mesh);
          this.mesh.geometry.dispose();
          this.mesh.material.dispose();
          return false;
        }
        return true;
      }
    }
    
    function createFloatingText(text, pos) {
      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.color = '#5DADE2';
      div.style.fontSize = '48px';
      div.style.fontWeight = 'bold';
      div.style.textShadow = '0 0 15px rgba(93,173,226,0.8), 0 0 30px rgba(93,173,226,0.5), 2px 2px 4px #000';
      div.style.pointerEvents = 'none';
      div.style.zIndex = '100';
      div.innerText = text;
      
      const vec = pos.clone();
      vec.y += 1;
      vec.project(camera);
      
      const x = (vec.x * .5 + .5) * window.innerWidth;
      const y = (-(vec.y * .5) + .5) * window.innerHeight;
      
      div.style.left = `${x}px`;
      div.style.top = `${y}px`;
      div.style.transform = 'translate(-50%, -50%)';
      
      document.body.appendChild(div);
      
      // Animate upward
      let offsetY = 0;
      const animateDuration = 2000;
      const startTime = Date.now();
      
      const animate = () => {
        const elapsed = Date.now() - startTime;
        const t = elapsed / animateDuration;
        
        if (t >= 1) {
          div.remove();
          return;
        }
        
        offsetY = -100 * t;
        const opacity = 1 - t;
        const scale = 1 + t * 0.5;
        
        div.style.top = `${y + offsetY}px`;
        div.style.opacity = opacity;
        div.style.transform = `translate(-50%, -50%) scale(${scale})`;
        
        requestAnimationFrame(animate);
      };
      animate();
    }

    function showUpgradeModal() {
      const modal = document.getElementById('levelup-modal');
      const list = document.getElementById('upgrade-list');
      list.innerHTML = '';
      
      let choices = [];

      // --- POOL OF UPGRADES ---
      const commonUpgrades = [
        { 
          id: 'str', 
          title: 'MUSCLE JUICE', 
          desc: 'Damage +10%', 
          apply: () => { 
            playerStats.strength += 0.1; 
            showStatChange('+10% Damage');
          } 
        },
        { 
          id: 'aspd', 
          title: 'SPEEDY TRIGGER', 
          desc: 'Atk Speed +10%', 
          apply: () => { 
            playerStats.atkSpeed += 0.1; 
            weapons.gun.cooldown *= 0.9; 
            showStatChange('+10% Attack Speed');
          } 
        },
        { 
          id: 'armor', 
          title: 'THICC ARMOR', 
          desc: 'Damage Taken -10%', 
          apply: () => { 
            playerStats.armor = Math.min(80, playerStats.armor + 10); 
            showStatChange('+10% Armor');
          } 
        },
        { 
          id: 'hp', 
          title: 'CHONKY BODY', 
          desc: 'Max HP +20', 
          apply: () => { 
            playerStats.maxHp += 20; 
            playerStats.hp += 20; 
            showStatChange('+20 Max HP');
          } 
        },
        { 
          id: 'crit', 
          title: 'CRIT MACHINE', 
          desc: 'Crit Chance +5%', 
          apply: () => { 
            playerStats.critChance += 0.05; 
            showStatChange('+5% Crit Chance');
          } 
        },
        { 
          id: 'regen', 
          title: 'HEALING VIBES', 
          desc: 'HP Regen +1/sec', 
          apply: () => { 
            playerStats.hpRegen += 1; 
            showStatChange('+1 HP/sec Regen');
          } 
        },
        { 
          id: 'speed', 
          title: 'SPEEDY BOI', 
          desc: 'Move Speed +10%', 
          apply: () => { 
            playerStats.walkSpeed += 2.5; 
            showStatChange('+10% Move Speed');
          } 
        },
        { 
          id: 'critdmg', 
          title: 'GLASS CANNON', 
          desc: 'Crit Damage +20%', 
          apply: () => { 
            playerStats.critDmg += 0.2; 
            showStatChange('+20% Crit Damage');
          } 
        }
      ];

      // Weapon Upgrades (Only if active)
      if (weapons.gun.active) commonUpgrades.push({ 
        id: 'gun_up', 
        title: 'BIG BULLETS', 
        desc: 'Gun Damage +5', 
        apply: () => { 
          weapons.gun.damage += 5; 
          showStatChange('+5 Gun Damage');
        } 
      });
      if (weapons.sword.active) commonUpgrades.push({ 
        id: 'sword_up', 
        title: 'SHARP EDGE', 
        desc: 'Sword Damage +10', 
        apply: () => { 
          weapons.sword.damage += 10; 
          showStatChange('+10 Sword Damage');
        } 
      });
      if (weapons.aura.active) commonUpgrades.push({ 
        id: 'aura_up', 
        title: 'BIGGER AURA', 
        desc: 'Aura Range +1', 
        apply: () => { 
          weapons.aura.range += 1; 
          showStatChange('+1 Aura Range');
        } 
      });
      if (weapons.meteor.active) commonUpgrades.push({ 
        id: 'meteor_up', 
        title: 'FASTER METEORS', 
        desc: 'Meteor CD -0.5s', 
        apply: () => { 
          weapons.meteor.cooldown = Math.max(500, weapons.meteor.cooldown - 500); 
          showStatChange('-0.5s Meteor Cooldown');
        } 
      });

      // --- SPECIAL LEVELS ---
      
      // Levels 4, 8, 12, 16, 20: Weapon/Passive Choices
      if ([4, 8, 12, 16, 20].includes(playerStats.lvl)) {
        choices = commonUpgrades.sort(() => 0.5 - Math.random()).slice(0, 4);
      }
      // Level 5: Choose Secondary Weapon
      else if (playerStats.lvl === 5) {
        choices = [
          { 
            id: 'sword', 
            title: 'SLASHY SLASH', 
            desc: 'Slash enemies in front', 
            apply: () => { 
              weapons.sword.active = true; 
              showStatChange('New Weapon: Sword');
            } 
          },
          { 
            id: 'aura', 
            title: 'ZAP ZONE', 
            desc: 'Damage aura around you', 
            apply: () => { 
              weapons.aura.active = true; 
              showStatChange('New Weapon: Aura');
            } 
          },
          { 
            id: 'meteor', 
            title: 'SPACE ROCKS', 
            desc: 'Call meteors from sky', 
            apply: () => { 
              weapons.meteor.active = true; 
              showStatChange('New Weapon: Meteor');
            } 
          }
        ];
      }
      // Level 10: CLASS SELECTION
      else if (playerStats.lvl === 10) {
        modal.querySelector('h2').innerText = 'CHOOSE YOUR CLASS';
        modal.querySelector('h2').style.fontSize = '42px';
        
        choices = [
          { 
            id: 'class_tank', 
            title: 'TANK', 
            desc: 'HP+50, Regen+2, Armor+20%, Speed-15%', 
            apply: () => { 
              playerStats.maxHp+=50; 
              playerStats.hp+=50; 
              playerStats.hpRegen+=2; 
              playerStats.armor+=20;
              playerStats.walkSpeed *= 0.85;
              showStatChange('Class: TANK');
            } 
          },
          { 
            id: 'class_berserker', 
            title: 'BERSERKER', 
            desc: 'Str+30%, Crit+10%, Attack Speed+20%, Armor-10%', 
            apply: () => { 
              playerStats.strength+=0.3; 
              playerStats.critChance+=0.1; 
              playerStats.atkSpeed+=0.2;
              weapons.gun.cooldown *= 0.8;
              playerStats.armor = Math.max(0, playerStats.armor-10);
              showStatChange('Class: BERSERKER');
            } 
          },
          { 
            id: 'class_rogue', 
            title: 'ROGUE', 
            desc: 'Speed+25%, Crit+15%, Crit Dmg+30%, HP-20', 
            apply: () => { 
              playerStats.walkSpeed *= 1.25; 
              playerStats.critChance+=0.15; 
              playerStats.critDmg+=0.3;
              playerStats.maxHp = Math.max(50, playerStats.maxHp-20);
              playerStats.hp = Math.min(playerStats.hp, playerStats.maxHp);
              showStatChange('Class: ROGUE');
            } 
          },
          { 
            id: 'class_mage', 
            title: 'MAGE', 
            desc: 'Aura Range+2, Meteor CD-1s, Regen+3, Move Speed+10%', 
            apply: () => { 
              weapons.aura.range+=2; 
              weapons.meteor.cooldown = Math.max(500, weapons.meteor.cooldown-1000);
              playerStats.hpRegen+=3;
              playerStats.walkSpeed *= 1.1;
              showStatChange('Class: MAGE');
            } 
          }
        ];
      } 
      else {
        // Random 4
        choices = commonUpgrades.sort(() => 0.5 - Math.random()).slice(0, 4);
      }

      choices.forEach((u, index) => {
        const card = document.createElement('div');
        card.className = 'upgrade-card';
        card.innerHTML = `<div class="upgrade-title">${u.title}</div><div class="upgrade-desc">${u.desc}</div>`;
        
        // Add dramatic entrance animation - alternate left/right
        card.style.opacity = '0';
        if (index % 2 === 0) {
          card.style.animation = `swooshInLeft 0.6s ease-out ${index * 0.15}s forwards`;
        } else {
          card.style.animation = `swooshInRight 0.6s ease-out ${index * 0.15}s forwards`;
        }
        
        card.onclick = () => {
          playSound('splash'); // Water splash sound when picking
          u.apply();
          modal.style.display = 'none';
          modal.querySelector('h2').innerText = 'LEVEL UP!';
          modal.querySelector('h2').style.fontSize = '32px';
          isPaused = false;
          updateHUD();
        };
        list.appendChild(card);
      });

      modal.style.display = 'flex';
    }

    function updateHUD() {
      const hpPct = (playerStats.hp / playerStats.maxHp) * 100;
      document.getElementById('hp-fill').style.width = `${Math.max(0, hpPct)}%`;
      document.getElementById('hp-text').innerText = `HP: ${Math.max(0, Math.ceil(playerStats.hp))}/${playerStats.maxHp}`;
      
      const expPct = (playerStats.exp / playerStats.expReq) * 100;
      document.getElementById('exp-fill').style.width = `${Math.min(100, expPct)}%`;
      document.getElementById('exp-text').innerText = `EXP: ${Math.min(100, Math.ceil(expPct))}%`;
      document.getElementById('lvl-text').innerText = `LVL: ${playerStats.lvl}`;
      document.getElementById('score-text').innerText = `KILLS: ${playerStats.kills}`;
    }
    
    function updateWindmillQuestUI() {
      if (!windmillQuest.active || !windmillQuest.windmill) return;
      
      const hp = windmillQuest.windmill.userData.hp;
      const maxHp = windmillQuest.windmill.userData.maxHp;
      const hpPct = (hp / maxHp) * 100;
      
      document.getElementById('windmill-hp-fill').style.width = `${Math.max(0, hpPct)}%`;
      document.getElementById('windmill-hp-text').innerText = `WINDMILL: ${Math.max(0, Math.ceil(hp))}/${maxHp}`;
      document.getElementById('windmill-timer-text').innerText = `DEFEND: ${Math.ceil(windmillQuest.timer)}s`;
    }
    
    function startWindmillQuest(windmill) {
      if (windmillQuest.hasCompleted) return;
      
      windmillQuest.active = true;
      windmillQuest.timer = windmillQuest.duration;
      windmillQuest.windmill = windmill;
      windmill.userData.hp = 600;
      windmill.userData.maxHp = 600;
      
      document.getElementById('windmill-quest-ui').style.display = 'block';
      updateWindmillQuestUI();
      
      createFloatingText("DEFEND THE WINDMILL!", windmill.position);
    }
    
    function completeWindmillQuest() {
      windmillQuest.active = false;
      windmillQuest.hasCompleted = true;
      document.getElementById('windmill-quest-ui').style.display = 'none';
      
      createFloatingText("QUEST COMPLETE!", windmillQuest.windmill.position);
      
      // Grant passive level up
      playerStats.lvl++;
      playerStats.expReq = (playerStats.lvl * 2) * GAME_CONFIG.expValue;
      
      // Unlock Double Barrel Gun
      weapons.gun.barrels = 2;
      weapons.gun.damage += 10;
      
      createFloatingText("DOUBLE BARREL UNLOCKED!", player.mesh.position);
      playSound('levelup');
      updateHUD();
    }

    function createDamageNumber(amount, pos, isCrit = false) {
      const div = document.createElement('div');
      div.className = isCrit ? 'damage-number critical' : 'damage-number normal';
      div.innerText = isCrit ? `CRITICAL!\n${Math.floor(amount)}` : Math.floor(amount);
      
      // Project 3D pos to 2D screen
      const vec = pos.clone();
      vec.y += 1.5;
      vec.project(camera);
      
      const x = (vec.x * .5 + .5) * window.innerWidth;
      const y = (-(vec.y * .5) + .5) * window.innerHeight;
      
      div.style.left = `${x}px`;
      div.style.top = `${y}px`;
      div.style.whiteSpace = 'pre';
      div.style.textAlign = 'center';
      
      document.body.appendChild(div);
      setTimeout(() => div.remove(), 1000);
    }
    
    function showStatChange(text) {
      const div = document.createElement('div');
      div.style.position = 'fixed';
      div.style.bottom = '100px';
      div.style.left = '20px';
      div.style.color = '#5DADE2';
      div.style.fontSize = '20px';
      div.style.fontWeight = 'bold';
      div.style.textShadow = '0 0 10px rgba(93,173,226,0.8), 2px 2px 4px rgba(0,0,0,0.8)';
      div.style.padding = '10px 15px';
      div.style.background = 'rgba(30,30,30,0.8)';
      div.style.borderRadius = '10px';
      div.style.border = '2px solid #2a2a2a';
      div.style.zIndex = '100';
      div.innerText = text;
      
      document.body.appendChild(div);
      
      // Animate in
      div.style.opacity = '0';
      div.style.transform = 'translateY(20px)';
      setTimeout(() => {
        div.style.transition = 'all 0.3s ease-out';
        div.style.opacity = '1';
        div.style.transform = 'translateY(0)';
      }, 10);
      
      // Remove after 2 seconds
      setTimeout(() => {
        div.style.opacity = '0';
        div.style.transform = 'translateY(-20px)';
        setTimeout(() => div.remove(), 300);
      }, 2000);
    }

    function gameOver() {
      isGameOver = true;
      isPaused = true;
      document.getElementById('gameover-screen').style.display = 'flex';
      document.getElementById('final-score').innerText = `Kills: ${playerStats.kills} | Lvl: ${playerStats.lvl}`;
    }

    function resetGame() {
      // Reset Stats
      playerStats.lvl = 1;
      playerStats.exp = 0;
      playerStats.expReq = GAME_CONFIG.baseExpReq;
      playerStats.hp = 100;
      playerStats.maxHp = 100;
      playerStats.strength = 1;
      playerStats.walkSpeed = 25;
      playerStats.kills = 0;
      playerStats.atkSpeed = 1;
      playerStats.critChance = 0.1;
      playerStats.armor = 0;
      playerStats.hpRegen = 0;
      waveCount = 0;
      
      weapons.gun = { active: true, level: 1, damage: 15, cooldown: 1000, lastShot: 0, range: 12, barrels: 1 };
      weapons.sword.active = false;
      weapons.aura.active = false;
      weapons.meteor.active = false;
      
      windmillQuest = { active: false, timer: 0, duration: 30, windmill: null, hasCompleted: false };
      document.getElementById('windmill-quest-ui').style.display = 'none';
      
      // Reset windmill HP
      scene.children.forEach(c => {
        if (c.userData.isWindmill) {
          c.userData.hp = 600;
          c.userData.maxHp = 600;
        }
      });
      
      // Reset music
      musicOscillators.forEach(m => {
        m.osc.stop();
      });
      musicOscillators = [];
      currentMusicLevel = 0;
      updateBackgroundMusic();

      // Clear Entities
      enemies.forEach(e => {
        scene.remove(e.mesh);
        e.mesh.geometry.dispose();
        e.mesh.material.dispose();
      });
      enemies = [];
      
      expGems.forEach(e => {
        scene.remove(e.mesh);
        e.mesh.geometry.dispose();
        e.mesh.material.dispose();
      });
      expGems = [];

      projectiles.forEach(p => {
        scene.remove(p.mesh);
        p.mesh.geometry.dispose();
        p.mesh.material.dispose();
      });
      projectiles = [];
      
      particles.forEach(p => {
        scene.remove(p.mesh);
        p.mesh.geometry.dispose();
        p.mesh.material.dispose();
      });
      particles = [];
      
      meteors.forEach(m => {
        scene.remove(m.mesh);
        scene.remove(m.shadow);
        m.mesh.geometry.dispose();
        m.mesh.material.dispose();
      });
      meteors = [];

      // Reset Player
      player.mesh.position.set(0, 0.5, 0);
      player.mesh.material.color.setHex(COLORS.player);

      isGameOver = false;
      isPaused = false;
      document.getElementById('gameover-screen').style.display = 'none';
      updateHUD();
    }

    function toggleStats() {
      const modal = document.getElementById('stats-modal');
      const levelUpModal = document.getElementById('levelup-modal');
      
      if (modal.style.display === 'flex') {
        modal.style.display = 'none';
        if (levelUpModal.style.display !== 'flex' && !isGameOver) {
          isPaused = false;
        }
      } else {
        const content = document.getElementById('stats-content');
        content.innerHTML = 
          `LVL: ${playerStats.lvl}<br>
          HP: ${Math.floor(playerStats.hp)}/${playerStats.maxHp}<br>
          STR: ${playerStats.strength.toFixed(1)}x<br>
          SPD: ${playerStats.speed.toFixed(1)}x<br>
          ARMOR: ${playerStats.armor}%<br>
          REGEN: ${playerStats.hpRegen}/s<br>
          CRIT: ${(playerStats.critChance*100).toFixed(0)}%<br>
          ATK SPD: ${playerStats.atkSpeed.toFixed(1)}x<br>
          KILLS: ${playerStats.kills}
        `;
        modal.style.display = 'flex';
        isPaused = true;
      }
    }

    // --- INPUT SYSTEM ---
    function setupInputs() {
      const zone = document.getElementById('joystick-zone');
      const container = document.getElementById('game-container');
      
      let touchStartX = 0;
      let touchStartY = 0;
      let touchStartTime = 0;
      
      zone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.changedTouches[0];
        joystick.id = touch.identifier;
        joystick.active = true;
        joystick.originX = touch.clientX;
        joystick.originY = touch.clientY;
        
        // Visual feedback could be added here
      }, { passive: false });

      zone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!joystick.active) return;
        
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === joystick.id) {
            const touch = e.changedTouches[i];
            const dx = touch.clientX - joystick.originX;
            const dy = touch.clientY - joystick.originY;
            
            // Normalize
            const maxDist = 40;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const clampedDist = Math.min(dist, maxDist);
            
            if (dist > 0) {
              joystick.x = (dx / dist) * (clampedDist / maxDist);
              joystick.y = (dy / dist) * (clampedDist / maxDist);
            }
            break;
          }
        }
      }, { passive: false });

      const endJoystick = (e) => {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === joystick.id) {
            joystick.active = false;
            joystick.x = 0;
            joystick.y = 0;
            break;
          }
        }
      };

      zone.addEventListener('touchend', endJoystick);
      zone.addEventListener('touchcancel', endJoystick);

      // Restart Button
      document.getElementById('restart-btn').addEventListener('click', resetGame);
      document.getElementById('restart-btn').addEventListener('touchstart', (e) => {
        e.stopPropagation(); // Prevent joystick interference
      }, { passive: true });

      // Stats Button
      document.getElementById('stats-btn').addEventListener('click', toggleStats);
      document.getElementById('close-stats-btn').addEventListener('click', toggleStats);
      
      // Swipe Detection (Global)
      container.addEventListener('touchstart', (e) => {
        // Don't interfere with joystick if it's in the zone
        // But we need to track start for swipe
        const t = e.changedTouches[0];
        touchStartX = t.clientX;
        touchStartY = t.clientY;
        touchStartTime = Date.now();
      }, { passive: false });

      container.addEventListener('touchend', (e) => {
        const t = e.changedTouches[0];
        const dx = t.clientX - touchStartX;
        const dy = t.clientY - touchStartY;
        const dt = Date.now() - touchStartTime;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dt < 500 && dist > 20) { // Easier swipe
           player.dash(dx/dist, dy/dist);
        }
      }, { passive: false });
    }

    function onWindowResize() {
      const aspect = window.innerWidth / window.innerHeight;
      const d = 20;
      camera.left = -d * aspect;
      camera.right = d * aspect;
      camera.top = d;
      camera.bottom = -d;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- MAIN LOOP ---
    function animate(time) {
      requestAnimationFrame(animate);

      const dt = (time - lastTime) / 1000;
      lastTime = time;
      gameTime = time / 1000; // Update game time in seconds

      if (isPaused || isGameOver || !isGameActive) return;

      // Spawn Logic
      frameCount++;
      if (frameCount % GAME_CONFIG.waveInterval === 0) {
        spawnWave();
      }
      
      // HP Regen (Every 60 frames approx 1 sec)
      if (frameCount % 60 === 0 && playerStats.hpRegen > 0 && playerStats.hp < playerStats.maxHp) {
        playerStats.hp = Math.min(playerStats.maxHp, playerStats.hp + playerStats.hpRegen);
        updateHUD();
        // Green particle
        spawnParticles(player.mesh.position, 0x00FF00, 2);
      }

      // Player Update
      player.update(dt);
      
      // Check windmill quest trigger
      if (!windmillQuest.active && !windmillQuest.hasCompleted) {
        scene.children.forEach(child => {
          if (child.userData && child.userData.isWindmill) {
            const dist = player.mesh.position.distanceTo(child.position);
            // Check if player is in front of windmill (90 degree arc)
            const dx = player.mesh.position.x - child.position.x;
            const dz = player.mesh.position.z - child.position.z;
            const angle = Math.atan2(dz, dx);
            const isFront = Math.abs(angle) < Math.PI / 2; // Front 180 degree arc
            
            if (dist < 8 && isFront) {
              startWindmillQuest(child);
            }
          }
        });
      }
      
      // Update windmill quest
      if (windmillQuest.active) {
        windmillQuest.timer -= dt;
        updateWindmillQuestUI();
        
        if (windmillQuest.timer <= 0) {
          // Quest completed successfully
          completeWindmillQuest();
        } else if (windmillQuest.windmill && windmillQuest.windmill.userData.hp <= 0) {
          // Quest failed
          windmillQuest.active = false;
          document.getElementById('windmill-quest-ui').style.display = 'none';
        }
      }

      // --- WEAPONS ---
      
      // 1. GUN
      if (weapons.gun.active && time - weapons.gun.lastShot > weapons.gun.cooldown) {
        // Find nearest enemy
        let nearest = null;
        let minDst = Infinity;
        
        for (let e of enemies) {
          if (e.isDead) continue;
          const d = player.mesh.position.distanceTo(e.mesh.position);
          if (d < weapons.gun.range && d < minDst) {
            minDst = d;
            nearest = e;
          }
        }

        if (nearest) {
          // Fire based on barrels
          for(let i=0; i<weapons.gun.barrels; i++) {
            setTimeout(() => {
              projectiles.push(new Projectile(player.mesh.position.x, player.mesh.position.z, nearest.mesh.position));
              
              // Muzzle flash light effect
              const flashLight = new THREE.PointLight(0xFFFF00, 2, 10);
              flashLight.position.copy(player.mesh.position);
              flashLight.position.y += 1;
              scene.add(flashLight);
              
              // Remove flash after short time
              setTimeout(() => {
                scene.remove(flashLight);
              }, 50);
              
              // Lightning effect from gun
              const lightning = new LightningBolt(
                player.mesh.position.clone(),
                nearest.mesh.position.clone()
              );
              particles.push(lightning);
              
              // Muzzle flash particles (bright and intense)
              spawnParticles(player.mesh.position, 0xFFFF00, 5);
              spawnParticles(player.mesh.position, 0xFFFFFF, 3);
              spawnParticles(player.mesh.position, 0xFFA500, 3);
            }, i * 100);
          }
          weapons.gun.lastShot = time;
          playSound('shoot');
        }
      }

      // 2. SWORD
      if (weapons.sword.active && time - weapons.sword.lastShot > weapons.sword.cooldown) {
        // Find enemy in front or just slash in movement dir
        // If moving, slash forward. If idle, slash nearest?
        // Let's slash in player rotation direction
        const angle = player.mesh.rotation.y;
        projectiles.push(new SwordSlash(player.mesh.position.x, player.mesh.position.z, angle));
        weapons.sword.lastShot = time;
        playSound('shoot'); // Reuse sound for now
      }

      // 3. AURA
      if (weapons.aura.active && time - weapons.aura.lastShot > weapons.aura.cooldown) {
        // Damage all in range
        let hit = false;
        enemies.forEach(e => {
          if (e.isDead) return;
          const d = player.mesh.position.distanceTo(e.mesh.position);
          if (d < weapons.aura.range) {
            e.takeDamage(weapons.aura.damage * playerStats.strength);
            hit = true;
          }
        });
        if (hit) {
          // Visual effect for aura tick?
          // Maybe just damage numbers
        }
        weapons.aura.lastShot = time;
      }

      // 4. METEOR
      if (weapons.meteor.active && time - weapons.meteor.lastShot > weapons.meteor.cooldown) {
        // Target random enemy or random spot near player
        let targetX = player.mesh.position.x + (Math.random() - 0.5) * 10;
        let targetZ = player.mesh.position.z + (Math.random() - 0.5) * 10;
        
        if (enemies.length > 0) {
          const e = enemies[Math.floor(Math.random() * enemies.length)];
          targetX = e.mesh.position.x;
          targetZ = e.mesh.position.z;
        }
        
        meteors.push(new Meteor(targetX, targetZ));
        weapons.meteor.lastShot = time;
      }

      // Entities Update
      enemies.forEach(e => e.update(dt, player.mesh.position));
      // Projectiles update returns false if dead
      projectiles = projectiles.filter(p => p.update() !== false);
      meteors = meteors.filter(m => m.update() !== false);
      expGems.forEach(g => g.update(player.mesh.position));
      particles = particles.filter(p => p.update() !== false);
      
      // Windmill Rotation and Light Animation
      scene.children.forEach(c => {
        if (c.userData.isWindmill) {
          // Rotate the blades stored in userData
          if (c.userData.blades && c.userData.blades.length > 0) {
            c.userData.blades[0].rotation.z += 0.05;
            c.userData.blades[1].rotation.z += 0.05;
          }
          
          // Animate windmill light (pulsing) with null check
          if (c.userData.light && c.userData.light.material) {
            c.userData.light.material.opacity = 0.8 + Math.sin(gameTime * 3) * 0.2;
          }
        }
        // Water ripple animation
        if (c.userData.isWaterRipple) {
          c.userData.phase += 0.05;
          const scale = 1 + Math.sin(c.userData.phase) * 0.1;
          c.scale.set(scale, 1, scale);
          c.material.opacity = 0.3 + Math.sin(c.userData.phase) * 0.2;
        }
      });
      
      // Waterfall animation
      scene.traverse(obj => {
        if (obj.userData.isWaterfall) {
          obj.userData.phase += 0.05;
          obj.material.opacity = 0.6 + Math.sin(obj.userData.phase) * 0.1;
        }
        if (obj.userData.isWaterDrop) {
          obj.position.y -= obj.userData.speed;
          if (obj.position.y < 0) {
            obj.position.y = obj.userData.startY;
          }
        }
        if (obj.userData.isSplash) {
          obj.userData.phase += 0.1;
          const scale = 1 + Math.sin(obj.userData.phase) * 0.3;
          obj.scale.set(scale, 1, scale);
          obj.material.opacity = 0.4 + Math.sin(obj.userData.phase) * 0.2;
        }
      });

      // Cleanup
      enemies = enemies.filter(e => !e.isDead);
      expGems = expGems.filter(g => g.active);

      renderer.render(scene, camera);
    }

    // Init Game
    try { init(); } catch(e) { console.error(e); alert("Game Error: " + e.message); }

  </script>
</body>
</html>