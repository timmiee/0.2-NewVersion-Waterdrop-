<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Waterdrop Survivor</title>
<style>
  body { margin: 0; overflow: hidden; background: #0a0a0a; }
  canvas { display: block; }
  #levelUpPopup {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    font-size: 3em;
    color: #ffdd00;
    text-shadow: 0 0 15px #ff0, 0 0 30px #ff6600;
    pointer-events: none;
    z-index: 10;
    transition: transform 0.5s ease-out;
  }
</style>
</head>
<body>
<div id="levelUpPopup">‚ùóÔ∏èüí• LEVEL UP ‚ùóÔ∏èüí•</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.176.0/examples/js/controls/OrbitControls.js"></script>
<script>
// =================== GAME SETUP ===================
let scene, camera, renderer, clock;
let player, enemies = [], expGems = [], meteors = [], particles = [];
let level = 1;
let exp = 0;
let nextLevelExp = 10;
let dashCooldown = 0;
let swipeVector = null;
let levelUpPopup = document.getElementById('levelUpPopup');

// Player stats
let playerStats = {
    strength: 1,
    speed: 1,
    critChance: 0.1,
    critDamage: 1.05,
    damage: 1,
    atkSpeed: 1,
    dodge: 0,
    evasion: 0,
    physMagDamage: 1,
    health: 100,
    maxHealth: 100,
    healthRegen: 0,
    walkSpeed: 0.25,
    armor: 0
};

// =============== THREE.JS INIT ==================
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0a);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 20);

    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    clock = new THREE.Clock();

    // Player
    let geometry = new THREE.SphereGeometry(1, 16, 16);
    let material = new THREE.MeshStandardMaterial({color: 0x00aaff, transparent: true, opacity: 0.8});
    player = { mesh: new THREE.Mesh(geometry, material), stats: {...playerStats}, velocity: new THREE.Vector3() };
    scene.add(player.mesh);
    player.mesh.position.set(0,1,0);

    // Lighting
    let light = new THREE.PointLight(0xffffff, 1);
    light.position.set(10, 20, 10);
    scene.add(light);

    // Floor
    let floorGeo = new THREE.PlaneGeometry(100,100);
    let floorMat = new THREE.MeshStandardMaterial({color: 0x222222});
    let floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    // Event listeners
    initTouchControls();

    // Start loop
    animate();
}

// ================= INPUT / SWIPE DASH =================
let touchStartPos = null;
let touchEndPos = null;
function initTouchControls() {
    window.addEventListener('touchstart', e => {
        let t = e.touches[0];
        touchStartPos = {x: t.clientX, y: t.clientY};
    });
    window.addEventListener('touchend', e => {
        let t = e.changedTouches[0];
        touchEndPos = {x: t.clientX, y: t.clientY};
        handleSwipeDash();
    });
}

function handleSwipeDash() {
    if (!touchStartPos || !touchEndPos || dashCooldown > 0) return;

    let dx = touchEndPos.x - touchStartPos.x;
    let dz = touchEndPos.y - touchStartPos.y; // use y as forward/back for simplicity
    let dir = new THREE.Vector3(dx, 0, dz).normalize();
    let dashDistance = 5;

    // Apply dash
    player.mesh.position.add(dir.multiplyScalar(dashDistance));
    dashCooldown = 0.5; // 0.5s cooldown
    swipeVector = dir.clone();

    // Reset touch
    touchStartPos = null;
    touchEndPos = null;
}

// ================= LEVEL UP SYSTEM =================
function gainExp(amount) {
    exp += amount;
    if (exp >= nextLevelExp) {
        exp -= nextLevelExp;
        levelUp();
        // increase nextLevelExp slightly randomly for small variation
        nextLevelExp = Math.floor(nextLevelExp * (1.1 + Math.random()*0.05));
    }
}

function levelUp() {
    level++;
    // Player grows slightly for dopamin effect
    let scaleFactor = 1 + 0.05*(Math.random()*0.5+0.5); 
    player.mesh.scale.multiplyScalar(scaleFactor);

    // Show popup
    levelUpPopup.style.transform = 'translate(-50%, -50%) scale(1.2)';
    setTimeout(() => { levelUpPopup.style.transform = 'translate(-50%, -50%) scale(0)'; }, 800);

    // Sound effect
    let audio = new Audio('https://freesound.org/data/previews/341/341695_5121236-lq.mp3');
    audio.volume = 0.4;
    audio.play();

    // Weapon unlock progression
    if (level === 3) {
        unlockWeapon();
    }

    // Stat increases for player
    player.stats.strength += 0.5;
    player.stats.damage += 0.5;
    player.stats.maxHealth += 5;
    player.stats.health = player.stats.maxHealth;
}

function unlockWeapon() {
    // Example: Sword unlocked
    console.log("Weapon Unlocked: Sword!");
}

// ================= ENEMY SYSTEM =================
function spawnEnemy() {
    let geometry = new THREE.BoxGeometry(1,1,1);
    let material = new THREE.MeshStandardMaterial({color: 0xff0000});
    let enemy = { mesh: new THREE.Mesh(geometry, material), health: 100, isDead: false };
    enemy.mesh.position.set(Math.random()*20-10,1,Math.random()*20-10);
    scene.add(enemy.mesh);
    enemies.push(enemy);
}

// ================= EXP GEMS =================
function spawnExpGem(x,z) {
    let geo = new THREE.OctahedronGeometry(0.3);
    let mat = new THREE.MeshStandardMaterial({color: 0xffff00});
    let gem = { mesh: new THREE.Mesh(geo, mat), active: true };
    gem.mesh.position.set(x,1,z);
    scene.add(gem.mesh);
    expGems.push(gem);
}

// ================= PARTICLES =================
function spawnParticle(pos) {
    let geo = new THREE.SphereGeometry(0.1,8,8);
    let mat = new THREE.MeshStandardMaterial({color: 0xffffff});
    let p = { mesh: new THREE.Mesh(geo, mat), lifetime: 1 };
    p.mesh.position.copy(pos);
    scene.add(p.mesh);
    particles.push(p);
}

// =================== ANIMATE LOOP ===================
function animate() {
    requestAnimationFrame(animate);
    let delta = clock.getDelta();
    if (dashCooldown > 0) dashCooldown -= delta;

    // Player regen
    player.stats.health = Math.min(player.stats.maxHealth, player.stats.health + player.stats.healthRegen*delta);

    // Update enemies
    enemies.forEach(e => {
        if (!e.isDead) {
            let dir = new THREE.Vector3().subVectors(player.mesh.position, e.mesh.position).normalize();
            e.mesh.position.add(dir.multiplyScalar(0.5*delta));
            if (e.mesh.position.distanceTo(player.mesh.position) < 1) {
                player.stats.health -= 5*delta; // simple damage
            }
        }
    });

    // Update exp gems
    expGems.forEach(g => {
        if (player.mesh.position.distanceTo(g.mesh.position) < 1) {
            gainExp(1);
            scene.remove(g.mesh);
            g.active = false;
        }
    });

    // Update particles
    particles = particles.filter(p => {
        p.lifetime -= delta;
        if (p.lifetime <= 0) { scene.remove(p.mesh); return false; }
        return true;
    });

    renderer.render(scene, camera);
}

// =================== INIT GAME ===================
try { init(); spawnEnemy(); spawnEnemy(); spawnExpGem(5,5); spawnExpGem(-5,-5); } 
catch(e) { console.error(e); alert("Game Error: " + e.message); }

</script>
</body>
</html>