<!DOCTYPE html>
<html>
<head>
  <!--
  GAME REQUIREMENTS:
  - Genre: Survivor / Horde Survival (Vampire Survivors style)
  - Theme: Water drops (Player), Round/Soft/Squishy shapes
  - Map: Big map with Forest, Lake, Cabin, Farmlands
  - Map Updates: Small forest roads, Windmill, Mine, Remove Farmlands
  - Player: Starts at Lvl 1, Water drop character
  - Player Physics: Squishy, loses droplets on hit, feels gravity/inertia
  - Player Actions: Dash (Swipe to dash in direction)
  - Starting Stats:
    - Strength: 1
    - Speed: 1
    - Crit Chance: 0.1 (10%)
    - Crit Damage: 5% (interpreted as +5% or 1.05x, will use 1.5x base + upgrades for playability, or strict 1.05x if desired. Will stick to playable baseline)
    - Damage: 1
    - Atk Speed: 1
    - Dodge: 0
    - Evasion: 0
    - Phys/Mag Damage: 1
    - Health: 100
    - Health Regen: 0
    - Walk Speed: 25%
    - Armor: 0 (New stat, reduces damage)
  - Weapon: Gun (1 shot/sec, 15 Dmg)
  - Weapon Progression: 
    - Lvl 5: Sword (Front Slash)
    - Lvl 10: Double Barrel / Energy Aura
  - Enemies: Squares, Triangles, Rounds. Squishy. Spawn in Waves.
    - HP: 100
    - Walk Speed: 50%
    - Attack: Melee (33 dmg, ~3 hits to kill)
    - Visuals: Blood/Stains on hit
  - Drops: EXP (Small 8-sided stars)
  - Level Up: Even Faster (2 kills, 4 kills...)
  - Upgrades: Atk +10%, AtkSpd +10%, Armor +25%
  - Visual Style: Green ground, Brown/Beige Windmill, Blue Lakes, Trees with shadows/canopy
  - Controls: Mobile Touch (Joystick) + Portrait Mode
  -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="screen-orientation" content="portrait">
  <title>Water Drop Survivor</title>
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;500;700;800;900&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000000; /* Black background - no white space */
      font-family: 'M PLUS Rounded 1c', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    #game-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    /* HUD */
    .hud-top {
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .bar-container {
      width: 200px;
      height: 24px;
      background: linear-gradient(to bottom, #3a3a3a 0%, #3a3a3a 50%, #6a6a6a 50%, #6a6a6a 100%);
      border-radius: 12px;
      border: 3px solid #2a2a2a;
      overflow: hidden;
      position: relative;
      box-shadow: 0 3px 8px rgba(0,0,0,0.3), inset 0 2px 4px rgba(0,0,0,0.2), 0 0 15px rgba(0,0,0,0.5);
    }

    .bar-fill {
      height: 100%;
      width: 100%;
      transition: width 0.3s ease-out;
      box-shadow: inset 0 2px 4px rgba(255,255,255,0.2);
      position: relative;
    }

    .bar-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-weight: bold;
      font-size: 12px;
      text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
      pointer-events: none;
      z-index: 1;
    }

    #hp-fill { 
      background: linear-gradient(to bottom, #FF4444, #CC0000);
      width: 100%;
      box-shadow: 0 0 10px rgba(255,68,68,0.8), 0 0 20px rgba(255,68,68,0.4), inset 0 2px 4px rgba(255,255,255,0.2);
    }
    #exp-fill { 
      background: linear-gradient(to bottom, #5DADE2, #3498DB);
      width: 0%;
      box-shadow: 0 0 10px rgba(93,173,226,0.8), 0 0 20px rgba(93,173,226,0.4), inset 0 2px 4px rgba(255,255,255,0.2);
    }

    .stat-text {
      color: #8B4513;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5), -1px -1px 1px rgba(255,255,255,0.3), 0 0 5px rgba(139,69,19,0.3);
      font-size: 14px;
      margin-top: 4px;
    }

    .stat-text.gold-text {
      font-size: 12px;
      margin-top: 8px;
    }

    /* Joystick */
    #joystick-zone {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: auto;
      touch-action: none;
      z-index: 50;
    }
    
    .joystick-outer {
      position: absolute;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: rgba(93, 173, 226, 0.3);
      border: 3px solid rgba(93, 173, 226, 0.5);
      display: none;
      pointer-events: none;
    }
    
    .joystick-inner {
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(93, 173, 226, 0.7);
      border: 2px solid rgba(255, 255, 255, 0.8);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    /* Level Up Modal */
    #levelup-modal {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(40, 40, 40, 0.95); /* Slightly more opaque for better contrast */
      display: none; /* Flex when active */
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: none; /* Modal background should not block clicks */
      z-index: 20;
    }

    .modal-content {
      background: linear-gradient(to bottom, #5a5a5a, #3a3a3a); /* Lighter gradient for better visibility */
      padding: 20px;
      border-radius: 20px;
      border: 5px solid #FFD700; /* Golden border for level-up emphasis */
      width: 85%;
      max-width: 350px;
      max-height: none; /* Remove height restriction - no scrolling needed */
      overflow-y: visible; /* No scrolling */
      text-align: center;
      box-shadow: 0 15px 30px rgba(0,0,0,0.7), 0 0 50px rgba(255,215,0,0.7), inset 0 0 40px rgba(255,215,0,0.15); /* Golden glow */
      pointer-events: auto; /* Modal content should receive clicks */
    }

    h2 {
      color: #5DADE2;
      margin-top: 0;
      font-size: 32px;
      text-shadow: 0 0 10px rgba(93,173,226,0.8), 0 0 20px rgba(93,173,226,0.6), 0 0 30px rgba(93,173,226,0.4), 2px 2px 4px rgba(0,0,0,0.8);
    }

    .upgrade-card {
      background: linear-gradient(to bottom, #6a6a6a, #4a4a4a); /* Lighter gradient */
      margin: 10px 0;
      padding: 15px;
      border-radius: 15px;
      border: 3px solid #FFD700; /* Golden border */
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.1s;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3), 0 0 15px rgba(255,215,0,0.4); /* Golden glow */
    }

    .upgrade-card:hover {
      box-shadow: 0 6px 12px rgba(255,215,0,0.6), 0 0 25px rgba(255,215,0,0.5); /* Stronger golden glow on hover */
    }

    .upgrade-card:active {
      transform: scale(0.95);
    }

    .upgrade-title {
      font-weight: bold;
      color: #FFD700;
      font-size: 18px;
      text-shadow: 0 0 8px rgba(255,215,0,0.6), 0 0 15px rgba(255,215,0,0.3), 1px 1px 2px rgba(0,0,0,0.8);
    }

    .upgrade-desc {
      font-size: 12px;
      color: #bbb;
      display: none; /* Hidden - only show funny names */
    }
    
    /* Special upgrade cards */
    .upgrade-card.perk {
      border-color: #9b59b6;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3), 0 0 20px rgba(155,89,182,0.6);
      animation: perkPulse 2s infinite;
    }
    
    .upgrade-card.perk:hover {
      box-shadow: 0 6px 12px rgba(155,89,182,0.8), 0 0 30px rgba(155,89,182,0.7);
    }
    
    .upgrade-card.legendary {
      border-color: #ff6b6b;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3), 0 0 20px rgba(255,107,107,0.6);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    
    .upgrade-card.legendary:hover {
      box-shadow: 0 6px 12px rgba(255,107,107,0.8), 0 0 30px rgba(255,107,107,0.7);
    }
    
    @keyframes perkPulse {
      0%, 100% { box-shadow: 0 4px 8px rgba(0,0,0,0.3), 0 0 20px rgba(155,89,182,0.6); }
      50% { box-shadow: 0 4px 8px rgba(0,0,0,0.3), 0 0 30px rgba(155,89,182,0.9); }
    }

    /* Damage Numbers */
    .damage-number {
      position: absolute;
      font-weight: bold;
      font-size: 16px;
      pointer-events: none;
      animation: floatUp 1s forwards;
      z-index: 1000;
    }
    
    .damage-number.critical {
      color: #FFD700;
      text-shadow: -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000, 0 0 10px rgba(255,215,0,0.8), 0 0 20px rgba(255,215,0,0.5), 2px 2px 4px rgba(0,0,0,0.9);
      font-size: 24px;
    }
    
    .damage-number.normal {
      color: #FFFFFF;
      text-shadow: -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000, 0 0 8px rgba(93,173,226,0.6), 0 0 15px rgba(93,173,226,0.3), 2px 2px 3px rgba(0,0,0,0.8);
    }

    @keyframes floatUp {
      0% { transform: translateY(0) scale(1); opacity: 1; }
      100% { transform: translateY(-60px) scale(1.3); opacity: 0; }
    }

    @keyframes goldBagPop {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1) translateY(-50px); opacity: 0; }
    }

    @keyframes goldTextFloat {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1) translateY(-30px); opacity: 0; }
    }

    /* Game Over Screen */
    #gameover-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      z-index: 30;
      color: white;
    }

    .btn {
      background: #5A3A31;
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 20px;
      border-radius: 50px;
      margin-top: 20px;
      font-weight: bold;
      box-shadow: 0 4px 0 #3a2a21, 0 0 0 rgba(90,58,49,0);
      transition: all 0.15s ease;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }
    
    .btn:hover {
      box-shadow: 0 6px 0 #3a2a21, 0 0 20px rgba(90,58,49,0.6);
      filter: brightness(1.1);
    }
    
    .btn:active {
      transform: translateY(4px) scale(0.98);
      box-shadow: 0 0 30px rgba(255,255,255,0.8);
      animation: lightning-flash 0.3s ease;
    }
    
    .btn:active::before {
      width: 300px;
      height: 300px;
    }

    .btn-small {
      background: #5A3A31;
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 30px;
      font-weight: bold;
      box-shadow: 0 3px 0 #3a2a21, 0 0 0 rgba(90,58,49,0);
      cursor: pointer;
      transition: all 0.15s ease;
      position: relative;
      overflow: hidden;
    }
    
    .btn-small::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }
    
    .btn-small:hover {
      box-shadow: 0 5px 0 #3a2a21, 0 0 20px rgba(90,58,49,0.6);
      filter: brightness(1.1);
    }
    
    .btn-small:active {
      transform: translateY(3px) scale(0.98);
      box-shadow: 0 0 30px rgba(255,255,255,0.8);
      animation: lightning-flash 0.3s ease;
    }
    
    .btn-small:active::before {
      width: 200px;
      height: 200px;
    }

    /* Loading Screen */
    #loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url('321E5768-E77B-4471-8C32-5D7C1D715A4B.png');
      background-size: cover;
      background-position: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
      z-index: 10000;
      transition: opacity 0.5s ease-out;
    }

    #loading-screen.fade-out {
      opacity: 0;
      pointer-events: none;
    }

    .loading-splash-logo {
      max-width: 80%;
      max-height: 50%;
      width: auto;
      height: auto;
      object-fit: contain;
      margin-bottom: 40px;
      animation: pulse 2s infinite;
      display: block;
    }

    .game-title {
      font-size: 48px;
      color: #5DADE2;
      text-shadow: 0 0 20px rgba(93,173,226,0.8), 0 0 40px rgba(93,173,226,0.5);
      margin-bottom: 40px;
      animation: pulse 2s infinite;
      display: none;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .loading-bar-container {
      width: 300px;
      height: 20px;
      background: #1a1a1a; /* Black background */
      border-radius: 10px;
      overflow: hidden;
      border: 2px solid #8B4513; /* Brown border */
      margin-bottom: 40px;
    }

    .loading-bar {
      height: 100%;
      background: linear-gradient(to right, #FFD700, #FFA500, #CD5C5C); /* Yellow to orange to reddish */
      width: 0%;
      transition: width 0.3s ease;
      box-shadow: 0 0 10px rgba(255, 165, 0, 0.8); /* Orange glow */
    }

    /* Main Menu */
    #main-menu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, #1a1a2e, #16213e);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 50; /* Lower than UI layer buttons */
    }

    #main-menu::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url('654811F9-1760-4A74-B977-73ECB1A92913.png');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      opacity: 1;
      z-index: -1;
    }

    .menu-title {
      font-size: 42px;
      color: #5DADE2;
      text-shadow: 0 0 20px rgba(93,173,226,0.8), 0 0 40px rgba(93,173,226,0.5);
      margin-bottom: 40px;
      display: none;
    }

    .menu-buttons {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .menu-btn {
      background: transparent;
      color: transparent;
      border: none;
      padding: 0;
      font-size: 0;
      box-shadow: none;
      position: absolute;
      width: 300px;
      height: 60px;
      cursor: pointer;
      transition: all 0.2s ease;
      overflow: visible;
      left: 50%;
      transform: translateX(-50%);
    }

    #start-game-btn { top: 50.25%; } /* Moved 3.5% lower from 46.75% */
    #progression-btn { top: 61.25%; } /* Moved 3.5% lower from 57.75% */
    #achievements-btn { top: 72.25%; } /* Moved 3.5% lower from 68.75% */
    #credits-btn { top: min(82.75%, calc(100% - 60px)); } /* Clamp to avoid viewport cutoff on short screens */

    .menu-btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    .menu-btn:hover {
      box-shadow: 0 0 20px rgba(93, 173, 226, 0.8), 0 0 40px rgba(93, 173, 226, 0.6), inset 0 0 30px rgba(93, 173, 226, 0.3);
    }

    .menu-btn:active {
      box-shadow: 0 0 40px rgba(255, 255, 255, 1), 0 0 60px rgba(93, 173, 226, 1), inset 0 0 40px rgba(255, 255, 255, 0.8);
      animation: lightning-flash 0.3s ease;
    }

    .menu-btn:active::before {
      width: 300px;
      height: 300px;
    }

    @keyframes lightning-flash {
      0%, 100% { filter: brightness(1.1); }
      50% { filter: brightness(2); box-shadow: 0 0 40px rgba(255,255,255,1), 0 0 80px rgba(93,173,226,1); }
    }

    .gold-display {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 24px;
      color: #FFD700;
      font-weight: bold;
      text-shadow: 0 0 10px rgba(255,215,0,0.8), 2px 2px 4px #000;
      pointer-events: none; /* Allow clicks to pass through */
      z-index: 1;
    }

    /* Progression Shop */
    #progression-shop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, #1a1a2e, #16213e);
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 50; /* Lower than UI layer buttons */
      overflow-y: auto;
      padding: 20px;
    }

    .shop-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 90%;
      max-width: 800px;
      margin-bottom: 20px;
    }

    .shop-title {
      font-size: 36px;
      color: #5DADE2;
      text-shadow: 0 0 15px rgba(93,173,226,0.8);
    }

    .shop-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 15px;
      width: 90%;
      max-width: 1200px;
      margin-bottom: 80px;
    }

    .upgrade-shop-card {
      background: linear-gradient(to bottom, #2c3e50, #1a252f);
      border: 3px solid #34495e;
      border-radius: 15px;
      padding: 15px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .upgrade-shop-card.max-level {
      opacity: 0.6;
      border-color: #95a5a6;
    }

    .upgrade-shop-title {
      font-size: 20px;
      color: #5DADE2;
      font-weight: bold;
    }

    .upgrade-shop-desc {
      font-size: 14px;
      color: #bdc3c7;
    }

    .upgrade-shop-level {
      font-size: 16px;
      color: #f39c12;
      font-weight: bold;
    }

    .upgrade-shop-cost {
      font-size: 18px;
      color: #FFD700;
      font-weight: bold;
    }

    .upgrade-buy-btn {
      background: linear-gradient(to bottom, #27ae60, #229954);
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      margin-top: 5px;
      transition: all 0.15s ease;
      position: relative;
      overflow: hidden;
    }

    .upgrade-buy-btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    .upgrade-buy-btn:hover:not(:disabled) {
      box-shadow: 0 0 20px rgba(39,174,96,0.6);
      filter: brightness(1.1);
    }

    .upgrade-buy-btn:disabled {
      background: linear-gradient(to bottom, #7f8c8d, #95a5a6);
      cursor: not-allowed;
    }

    .upgrade-buy-btn:not(:disabled):active {
      transform: scale(0.95);
      animation: lightning-flash 0.3s ease;
    }

    .upgrade-buy-btn:not(:disabled):active::before {
      width: 200px;
      height: 200px;
    }

    .back-btn {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(to bottom, #e74c3c, #c0392b);
      color: white;
      border: none;
      padding: 15px 40px;
      font-size: 20px;
      border-radius: 40px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 0 #a93226, 0 0 0 rgba(231,76,60,0);
      transition: all 0.15s ease;
      position: relative;
      overflow: hidden;
    }

    .back-btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    .back-btn:hover {
      box-shadow: 0 6px 0 #a93226, 0 0 20px rgba(231,76,60,0.6);
      filter: brightness(1.1);
    }

    .back-btn:active {
      transform: translateX(-50%) translateY(4px) scale(0.98);
      box-shadow: 0 0 30px rgba(255,255,255,0.8);
      animation: lightning-flash 0.3s ease;
    }

    .back-btn:active::before {
      width: 300px;
      height: 300px;
    }

    /* Credits/Achievements Screens */
    #credits-screen, #achievements-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, #1a1a2e, #16213e);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      overflow-y: auto;
      z-index: 50; /* Lower than UI layer buttons */
      padding: 40px 40px 100px 40px;
    }

    .screen-title {
      font-size: 40px;
      color: #5DADE2;
      text-shadow: 0 0 15px rgba(93,173,226,0.8);
      margin-bottom: 30px;
    }

    .screen-content {
      font-size: 18px;
      color: #ecf0f1;
      text-align: center;
      line-height: 1.8;
      max-width: 600px;
    }

    /* Settings Modal */
    #settings-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      pointer-events: auto;
    }

    .settings-container {
      background: linear-gradient(to bottom, #2c3e50, #34495e);
      padding: 30px;
      border-radius: 20px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }

    .settings-title {
      font-size: 32px;
      color: #5DADE2;
      text-align: center;
      margin-bottom: 20px;
      text-shadow: 0 0 15px rgba(93,173,226,0.8);
    }

    .settings-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 15px 0;
      color: #ecf0f1;
      font-size: 16px;
    }

    .settings-item label {
      flex: 1;
    }

    .settings-item input[type="checkbox"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }

    .settings-item select {
      padding: 5px 10px;
      border-radius: 5px;
      background: #34495e;
      color: #ecf0f1;
      border: 2px solid #5DADE2;
      cursor: pointer;
      font-size: 14px;
    }

    .settings-close-btn {
      margin-top: 20px;
      width: 100%;
      background: linear-gradient(to bottom, #e74c3c, #c0392b);
      color: white;
      border: none;
      padding: 12px;
      font-size: 18px;
      border-radius: 10px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 0 #a93226;
      transition: all 0.15s ease;
    }

    .settings-close-btn:hover {
      box-shadow: 0 6px 0 #a93226;
      filter: brightness(1.1);
    }

    .settings-close-btn:active {
      transform: translateY(4px);
      box-shadow: 0 0 0 #a93226;
    }

    /* Responsive Media Queries */
    @media (orientation: portrait) {
      /* Portrait mode adjustments */
      .modal-content {
        width: 90%;
        max-width: 350px;
      }

      .bar-container {
        width: min(200px, 40vw);
        height: 24px;
      }

      .hud-top {
        padding: 10px;
      }
      
      #joystick-outer-right {
        display: none !important; /* Hide right joystick in portrait */
      }
    }

    @media (orientation: landscape) {
      /* Landscape mode adjustments */
      .modal-content {
        width: 70%;
        max-width: 500px;
      }

      .bar-container {
        width: min(200px, 25vw);
        height: 20px;
      }

      .hud-top {
        padding: 8px;
        flex-direction: row;
        justify-content: space-between;
      }
    }

  </style>
</head>
<body>

  <!-- Loading Screen -->
  <div id="loading-screen">
    <div class="game-title" style="display: block;">WATER DROP SURVIVOR</div>
    <div class="loading-bar-container">
      <div class="loading-bar" id="loading-bar"></div>
    </div>
  </div>

  <!-- Main Menu -->
  <div id="main-menu">
    <div class="gold-display" id="menu-gold">GOLD: 0</div>
    <div class="menu-title">WATER DROP SURVIVOR</div>
    <div class="menu-buttons">
      <button class="menu-btn" id="start-game-btn">START GAME</button>
      <button class="menu-btn" id="progression-btn">PROGRESSION</button>
      <button class="menu-btn" id="achievements-btn">ACHIEVEMENTS</button>
      <button class="menu-btn" id="credits-btn">CREDITS</button>
    </div>
  </div>

  <!-- Progression Shop -->
  <div id="progression-shop">
    <div class="shop-header">
      <div class="shop-title">PROGRESSION UPGRADES</div>
      <div class="gold-display" id="shop-gold">GOLD: 0</div>
    </div>
    <div class="shop-grid" id="shop-grid">
      <!-- Upgrade cards will be added dynamically -->
    </div>
    <button class="back-btn" id="shop-back-btn">BACK TO MENU</button>
  </div>

  <!-- Achievements Screen -->
  <div id="achievements-screen">
    <div class="screen-title">ACHIEVEMENTS</div>
    <div class="screen-content" id="achievements-content">
      <!-- Dynamically populated -->
    </div>
    <button class="back-btn" id="achievements-back-btn">BACK TO MENU</button>
  </div>

  <!-- Credits Screen -->
  <div id="credits-screen">
    <div class="screen-title">CREDITS</div>
    <div class="screen-content">
      <p><strong>Game Design & Development</strong></p>
      <p>Water Drop Survivor Team</p>
      <br>
      <p><strong>Special Thanks</strong></p>
      <p>To all the players who survive the horde!</p>
      <br>
      <p>Built with Three.js</p>
    </div>
    <button class="back-btn" id="credits-back-btn">BACK TO MENU</button>
  </div>

  <!-- Settings Modal -->
  <div id="settings-modal">
    <div class="settings-container">
      <div class="settings-title">SETTINGS</div>
      
      <div class="settings-item">
        <label for="auto-aim-checkbox">Auto-Aim (Portrait Mode)</label>
        <input type="checkbox" id="auto-aim-checkbox" checked>
      </div>
      
      <div class="settings-item">
        <label for="control-type-select">Control Type</label>
        <select id="control-type-select">
          <option value="touch">Touch (Joystick)</option>
          <option value="keyboard">Keyboard</option>
          <option value="gamepad">Gamepad</option>
        </select>
      </div>
      
      <div class="settings-item">
        <label for="sound-toggle">Sound Effects</label>
        <input type="checkbox" id="sound-toggle" checked>
      </div>
      
      <div class="settings-item">
        <label for="music-toggle">Background Music</label>
        <input type="checkbox" id="music-toggle" checked>
      </div>
      
      <button class="settings-close-btn" id="settings-close-btn">CLOSE</button>
    </div>
  </div>

  <div id="game-container"></div>

  <div id="ui-layer">
    <div class="hud-top">
      <div class="bar-container" id="hp-bar-container">
        <div class="bar-fill" id="hp-fill"></div>
        <div class="bar-text" id="hp-text" style="color: #FFFFFF;">HP: 100/100</div>
      </div>
      
      <div class="bar-container" id="exp-bar-container" style="border-color: #2a2a2a;">
        <div class="bar-fill" id="exp-fill"></div>
        <div class="bar-text" id="exp-text" style="color: #FFFFFF;">EXP: 0%</div>
      </div>
      
      <div class="stat-text" id="lvl-text" style="color: #5DADE2; text-shadow: 0 0 8px rgba(93,173,226,0.8), 0 0 12px rgba(93,173,226,0.5), 1px 1px 2px rgba(0,0,0,0.5);">LVL: 1</div>
      <div class="stat-text" id="score-text" style="color: #8B4513;">KILLS: 0</div>
      <div class="stat-text gold-text" id="gold-text" style="color: #FFD700; text-shadow: 0 0 10px rgba(255,215,0,0.9), 0 0 15px rgba(255,215,0,0.6), 1px 1px 2px rgba(0,0,0,0.5);">GOLD: 0</div>
      
      <!-- Windmill Quest UI -->
      <div id="windmill-quest-ui" style="display: none; margin-top: 10px;">
        <div class="bar-container" style="border-color: #8B4513;">
          <div class="bar-fill" id="windmill-hp-fill" style="background: #8B4513; width: 100%;"></div>
        </div>
        <div class="stat-text" id="windmill-hp-text" style="color: #8B4513;">WINDMILL: 600/600</div>
        <div class="stat-text" id="windmill-timer-text" style="color: #FFD700; font-size: 18px;">DEFEND: 30s</div>
      </div>
    </div>
    <button id="stats-btn" class="btn-small" style="position: absolute; top: 20px; right: 20px; pointer-events: auto; z-index: 100;">STATS</button>
    <button id="settings-btn" class="btn-small" style="position: absolute; top: 20px; right: 100px; pointer-events: auto; z-index: 100;">⚙️</button>

    <div id="joystick-zone">
      <div class="joystick-outer" id="joystick-outer">
        <div class="joystick-inner" id="joystick-inner"></div>
      </div>
      <div class="joystick-outer" id="joystick-outer-right">
        <div class="joystick-inner" id="joystick-inner-right"></div>
      </div>
    </div>
  </div>

  <!-- Level Up Modal -->
  <div id="levelup-modal">
    <div class="modal-content">
      <h2>LEVEL UP!</h2>
      <div id="upgrade-list">
        <!-- Cards injected by JS -->
      </div>
    </div>
  </div>

  <!-- Stats Modal -->
  <div id="stats-modal" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 25; align-items: center; justify-content: center; pointer-events: auto; flex-direction: column;">
    <div class="modal-content" style="max-height: 80vh; overflow-y: auto;">
      <h2>PLAYER STATS</h2>
      <div id="stats-content" style="text-align: left; margin-bottom: 20px; font-family: monospace; font-size: 14px; line-height: 1.8; color: #ecf0f1;"></div>
      <button class="btn" id="close-stats-btn">CLOSE</button>
    </div>
  </div>

  <!-- Game Over Screen -->
  <div id="gameover-screen">
    <h1 style="color: #5DADE2; font-size: 40px; text-shadow: 2px 2px 0 #000, 0 0 10px rgba(93,173,226,0.8);">GAME OVER</h1>
    <p id="final-score" style="font-size: 20px; margin: 10px 0;">Survived: 0s</p>
    <p id="final-kills" style="font-size: 20px; margin: 10px 0;">Kills: 0</p>
    <p id="gold-earned" style="font-size: 24px; margin: 10px 0; color: #FFD700; font-weight: bold;">Gold Earned: 0</p>
    <p id="total-gold" style="font-size: 20px; margin: 10px 0; color: #FFD700;">Total Gold: 0</p>
    <button class="btn" id="restart-btn">CONTINUE</button>
  </div>

  <!-- Import Map for Three.js -->
  <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.176.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.176.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // --- CONSTANTS & CONFIG ---
    const COLORS = {
      bg: 0xFFF0F5,
      player: 0x4FC3F7, // Light Blue - more like water droplet
      enemySquare: 0xFF69B4, // Hot Pink
      enemyTriangle: 0xFFD700, // Gold
      enemyRound: 0x9370DB, // Purple
      ground: 0x7CFC00, // Lawn Green (More vibrant)
      forest: 0x98FB98, // Pale Green
      lake: 0x1E90FF, // Dodger Blue (More water-like)
      cabin: 0xDEB887, // Burlywood
      farmland: 0xF0E68C, // Khaki
      exp: 0x5DADE2, // Light Blue (Matching EXP bar)
    };

    const GAME_CONFIG = {
      playerSpeedBase: 0.12, // Slower as requested
      enemySpeedBase: 0.05,  // Slower as requested
      waveInterval: 300, // Frames between waves (approx 5s)
      expValue: 10,
      baseExpReq: 20,
      // Lake configuration - used for spawn avoidance
      lakeCenterX: 30,
      lakeCenterZ: -30,
      lakeRadius: 18
    };

    // --- AUDIO SYSTEM (Oscillators) ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let musicOscillators = [];
    let musicGain = null;
    let currentMusicLevel = 0;
    
    function initMusic() {
      if (!musicGain) {
        musicGain = audioCtx.createGain();
        musicGain.gain.value = 0.05;
        musicGain.connect(audioCtx.destination);
      }
    }
    
    function updateBackgroundMusic() {
      initMusic();
      
      if (!gameSettings.musicEnabled) {
        // Stop all music if disabled
        if (musicGain) {
          musicGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
        }
        return;
      }
      
      // Restore music volume if enabled and currently at 0
      if (musicGain && musicGain.gain.value < 0.01 && musicOscillators.length > 0) {
        musicGain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.5);
      }
      
      const targetLevel = Math.min(playerStats.lvl, 10);
      
      if (targetLevel > currentMusicLevel) {
        currentMusicLevel = targetLevel;
        
        // Add new layer with happier, more upbeat sounds
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        
        osc.connect(gain);
        gain.connect(musicGain);
        
        // Major key frequencies - happier, more dopamine-inducing (C Major scale)
        const baseFreq = 261.63; // C4 (Middle C)
        const majorScaleFreqs = [
          baseFreq,           // C - Level 1
          baseFreq * 1.125,   // D - Level 2
          baseFreq * 1.26,    // E - Level 3
          baseFreq * 1.33,    // F - Level 4
          baseFreq * 1.5,     // G - Level 5
          baseFreq * 1.68,    // A - Level 6
          baseFreq * 1.89,    // B - Level 7
          baseFreq * 2,       // C - Level 8 (octave up)
          baseFreq * 2.25,    // D - Level 9
          baseFreq * 2.52     // E - Level 10
        ];
        
        // Use sine wave for happier, cleaner sound
        osc.type = 'sine';
        osc.frequency.value = majorScaleFreqs[currentMusicLevel - 1];
        
        // Add faster vibrato for more energetic feel
        const lfo = audioCtx.createOscillator();
        const lfoGain = audioCtx.createGain();
        lfo.frequency.value = 6 + currentMusicLevel * 0.5; // Faster vibrato
        lfoGain.gain.value = 8 + currentMusicLevel * 0.8; // More pronounced
        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);
        lfo.start();
        
        gain.gain.value = 0;
        gain.gain.linearRampToValueAtTime(0.25 + currentMusicLevel * 0.02, audioCtx.currentTime + 0.8);
        
        osc.start();
        musicOscillators.push({ osc, gain, lfo });
        
        // Add harmony layer (third above) for richer sound
        const harmony = audioCtx.createOscillator();
        const harmonyGain = audioCtx.createGain();
        harmony.connect(harmonyGain);
        harmonyGain.connect(musicGain);
        harmony.type = 'sine';
        harmony.frequency.value = majorScaleFreqs[currentMusicLevel - 1] * 1.26; // Major third
        harmonyGain.gain.value = 0;
        harmonyGain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.8);
        harmony.start();
        musicOscillators.push({ osc: harmony, gain: harmonyGain, lfo: null });
        
        // Add uplifting high melody for levels 3+
        if (currentMusicLevel >= 3) {
          const melody = audioCtx.createOscillator();
          const melodyGain = audioCtx.createGain();
          melody.connect(melodyGain);
          melodyGain.connect(musicGain);
          melody.type = 'triangle';
          melody.frequency.value = majorScaleFreqs[currentMusicLevel - 1] * 2; // Octave up
          melodyGain.gain.value = 0;
          melodyGain.gain.linearRampToValueAtTime(0.12, audioCtx.currentTime + 0.8);
          melody.start();
          musicOscillators.push({ osc: melody, gain: melodyGain, lfo: null });
        }
        
        // Add energetic rhythm layer for levels 5+
        if (currentMusicLevel >= 5) {
          const rhythm = audioCtx.createOscillator();
          const rhythmGain = audioCtx.createGain();
          rhythm.connect(rhythmGain);
          rhythmGain.connect(musicGain);
          rhythm.type = 'square';
          rhythm.frequency.value = majorScaleFreqs[currentMusicLevel - 1] * 0.5; // Bass line
          rhythmGain.gain.value = 0;
          rhythmGain.gain.linearRampToValueAtTime(0.18, audioCtx.currentTime + 0.8);
          rhythm.start();
          musicOscillators.push({ osc: rhythm, gain: rhythmGain, lfo: null });
        }
        
        // Add high frequency sparkle for levels 7+
        if (currentMusicLevel >= 7) {
          const sparkle = audioCtx.createOscillator();
          const sparkleGain = audioCtx.createGain();
          sparkle.connect(sparkleGain);
          sparkleGain.connect(musicGain);
          sparkle.type = 'sine';
          sparkle.frequency.value = majorScaleFreqs[currentMusicLevel - 1] * 4; // High sparkle
          sparkleGain.gain.value = 0;
          sparkleGain.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime + 0.8);
          sparkle.start();
          musicOscillators.push({ osc: sparkle, gain: sparkleGain, lfo: null });
        }
      }
    }
    
    function playSound(type) {
      if (!gameSettings.soundEnabled) return; // Respect sound settings
      if (audioCtx.state === 'suspended') audioCtx.resume();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      
      if (type === 'shoot') {
        // Realistic gun sound - sharper and snappier
        osc.type = 'square';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.03);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
        osc.start(now);
        osc.stop(now + 0.08);
      } else if (type === 'hit') {
        // Punchy hit sound with more bass
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.08);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
        osc.start(now);
        osc.stop(now + 0.08);
        
        // Add deep bass punch
        const osc2 = audioCtx.createOscillator();
        const gain2 = audioCtx.createGain();
        osc2.connect(gain2);
        gain2.connect(audioCtx.destination);
        osc2.type = 'sine';
        osc2.frequency.setValueAtTime(80, now);
        osc2.frequency.exponentialRampToValueAtTime(30, now + 0.06);
        gain2.gain.setValueAtTime(0.25, now);
        gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.06);
        osc2.start(now);
        osc2.stop(now + 0.06);
      } else if (type === 'levelup') {
        // Hi-Fi Level Up Sound - Ascending arpeggio
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.linearRampToValueAtTime(500, now + 0.08);
        osc.frequency.linearRampToValueAtTime(633, now + 0.16);
        osc.frequency.linearRampToValueAtTime(800, now + 0.24);
        osc.frequency.linearRampToValueAtTime(1000, now + 0.32);
        gain.gain.setValueAtTime(0.25, now);
        gain.gain.linearRampToValueAtTime(0.2, now + 0.3);
        gain.gain.linearRampToValueAtTime(0, now + 0.6);
        osc.start(now);
        osc.stop(now + 0.6);
        
        // Update background music
        updateBackgroundMusic();
      } else if (type === 'splash') {
        // Water splash sound
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.2);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
        
        // Add bubbles layer
        const osc2 = audioCtx.createOscillator();
        const gain2 = audioCtx.createGain();
        osc2.connect(gain2);
        gain2.connect(audioCtx.destination);
        osc2.type = 'triangle';
        osc2.frequency.setValueAtTime(1500, now);
        osc2.frequency.exponentialRampToValueAtTime(500, now + 0.15);
        gain2.gain.setValueAtTime(0.15, now);
        gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        osc2.start(now);
        osc2.stop(now + 0.15);
      } else if (type === 'collect') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(1200, now);
        osc.frequency.exponentialRampToValueAtTime(2000, now + 0.1);
        gain.gain.setValueAtTime(0.05, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
      } else if (type === 'coin') {
        // Gold Pickup Sound - Ascending jingle
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.linearRampToValueAtTime(800, now + 0.05);
        osc.frequency.linearRampToValueAtTime(1000, now + 0.08);
        osc.frequency.linearRampToValueAtTime(1200, now + 0.11);
        gain.gain.setValueAtTime(0.08, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
      } else if (type === 'coinDrop') {
        // Gold Drop Sound - Metallic coin drop
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.15);
        gain.gain.setValueAtTime(0.06, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15); // Use 0.001 instead of 0.01 for exponential ramps
        osc.start(now);
        osc.stop(now + 0.15);
      } else if (type === 'dash') {
        // Dash/Swoosh sound - Quick whoosh
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
        
        // Add wind layer
        const osc2 = audioCtx.createOscillator();
        const gain2 = audioCtx.createGain();
        osc2.connect(gain2);
        gain2.connect(audioCtx.destination);
        osc2.type = 'triangle';
        osc2.frequency.setValueAtTime(1200, now);
        osc2.frequency.exponentialRampToValueAtTime(300, now + 0.12);
        gain2.gain.setValueAtTime(0.1, now);
        gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
        osc2.start(now);
        osc2.stop(now + 0.12);
      }
    }

    // --- GAME STATE ---
    let scene, camera, renderer;
    let player;
    let enemies = [];
    let projectiles = [];
    let expGems = [];
    let goldCoins = [];
    let particles = [];
    let damageNumbers = [];
    let meteors = [];
    let flashLights = []; // Track temporary flash lights for cleanup
    let activeTimeouts = []; // Track active timeouts for cleanup
    let lastTime = 0;
    let frameCount = 0;
    let isPaused = false;
    let isGameOver = false;
    let isGameActive = false;  // Changed to false - start with menu
    let gameTime = 0;
    let gameStartTime = 0;
    let waveCount = 0;
    let windmillQuest = { active: false, timer: 0, duration: 30, windmill: null, hasCompleted: false };
    let runStartGold = 0;  // Track gold at start of run for end-of-run calculation

    // Game Settings
    const gameSettings = {
      autoAim: true,
      controlType: 'touch', // 'touch', 'keyboard', 'gamepad'
      soundEnabled: true,
      musicEnabled: true,
      isPortrait: null,
      inputListenersRegistered: false
    };

    // Input - Twin-Stick Controls
    const joystickLeft = { x: 0, y: 0, active: false, id: null, originX: 0, originY: 0 }; // Movement
    const joystickRight = { x: 0, y: 0, active: false, id: null, originX: 0, originY: 0 }; // Aiming
    
    // Swipe detection for dash
    let swipeStart = null;
    
    // Stats
    const playerStats = {
      lvl: 1,
      exp: 0,
      expReq: GAME_CONFIG.baseExpReq,
      hp: 100,
      maxHp: 100,
      strength: 1,
      armor: 0, // Percentage reduction (0-100)
      speed: 1, // Multiplier
      critChance: 0.1,
      critDmg: 1.5, // 150% base (User said 5%, assuming +5% or 1.05x, but 1.5x is standard)
      damage: 1, // Multiplier
      atkSpeed: 1, // Multiplier
      walkSpeed: 25, // Display value
      kills: 0,
      hpRegen: 0,
      gold: 0,
      survivalTime: 0,
      dashesPerformed: 0,
      damageTaken: 0,
      weaponsUnlocked: 0,
      // Perk System
      perks: {
        vampire: 0,      // Life steal %
        juggernaut: 0,   // Damage reduction %
        swift: 0,        // Move speed %
        lucky: 0,        // Crit chance %
        berserker: 0     // Low HP attack speed bonus
      },
      // Skill upgrades
      dashCooldownReduction: 0,
      dashDistanceBonus: 0,
      hasSecondWind: false,
      lifeStealPercent: 0,
      thornsPercent: 0,
      hasBerserkerRage: false,
      treasureHunterChance: 0,
      doubleCritChance: 0
    };

    // Weapons State
    const weapons = {
      gun: { active: true, level: 1, damage: 15, cooldown: 1000, lastShot: 0, range: 12, barrels: 1 },
      sword: { active: false, level: 0, damage: 30, cooldown: 1500, lastShot: 0, range: 3.5 },
      aura: { active: false, level: 0, damage: 5, cooldown: 500, lastShot: 0, range: 3 },
      meteor: { active: false, level: 0, damage: 60, cooldown: 2500, lastShot: 0, area: 5 },
      lightning: { active: false, level: 0, damage: 25, cooldown: 3000, lastShot: 0, targets: 4 },
      doubleBarrel: { active: false, level: 0, damage: 25, cooldown: 1200, lastShot: 0, range: 12, spread: 0.3 },
      iceSpear: { active: false, level: 0, damage: 20, cooldown: 1500, lastShot: 0, range: 15, slowPercent: 0.4, slowDuration: 2000 },
      fireRing: { active: false, level: 0, damage: 8, cooldown: 800, lastShot: 0, range: 4, orbs: 3, rotationSpeed: 2 }
    };

    // Magnet range for XP collection
    let magnetRange = 2; // Base range for XP magnet
    
    // Dash mechanics
    let dashCooldown = 1000; // Base cooldown in ms (1 second)
    let dashDistance = 2.5; // Base dash distance multiplier

    // Upgrade Config
    const UPGRADES = {
      damage: { name: "Base Damage", cost: 100, inc: 0.1, max: 10 },
      health: { name: "Max Health", cost: 100, inc: 10, max: 10 },
      speed: { name: "Move Speed", cost: 150, inc: 0.05, max: 5 },
      armor: { name: "Armor", cost: 200, inc: 2, max: 10 },
      magnet: { name: "Magnet Range", cost: 100, inc: 0.5, max: 5 }
    };

    // --- CLASSES ---

    class Player {
      constructor() {
        // Create water droplet shape (teardrop)
        const geometry = new THREE.SphereGeometry(0.5, 32, 32);
        
        // Modify geometry to make it more teardrop-shaped
        const positions = geometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
          const y = positions.getY(i);
          const x = positions.getX(i);
          const z = positions.getZ(i);
          
          // Stretch top to make teardrop
          if (y > 0) {
            positions.setY(i, y * 1.2);
            const squeeze = 1 - (y / 0.5) * 0.3;
            positions.setX(i, x * squeeze);
            positions.setZ(i, z * squeeze);
          }
        }
        geometry.computeVertexNormals();
        
        const material = new THREE.MeshPhysicalMaterial({ 
          color: COLORS.player,
          transparent: true,
          opacity: 0.75,
          metalness: 0.1,
          roughness: 0.2,
          transmission: 0.3,
          thickness: 0.5,
          envMapIntensity: 1,
          clearcoat: 1,
          clearcoatRoughness: 0.1
        });
        
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.y = 0.5;
        this.mesh.castShadow = true;
        scene.add(this.mesh);
        
        // Add water shine effect (multiple layers)
        const shineGeo = new THREE.SphereGeometry(0.52, 16, 16);
        const shineMat = new THREE.MeshBasicMaterial({ 
          color: 0xFFFFFF, 
          transparent: true, 
          opacity: 0.25,
          side: THREE.BackSide
        });
        this.shine = new THREE.Mesh(shineGeo, shineMat);
        this.mesh.add(this.shine);
        
        // Add reflection highlight
        const highlightGeo = new THREE.SphereGeometry(0.15, 16, 16);
        const highlightMat = new THREE.MeshBasicMaterial({ 
          color: 0xFFFFFF, 
          transparent: true, 
          opacity: 0.8
        });
        this.highlight = new THREE.Mesh(highlightGeo, highlightMat);
        this.highlight.position.set(-0.2, 0.3, 0.2);
        this.mesh.add(this.highlight);
        
        // Add player face: eyes (white spheres + black pupils)
        const eyeGeo = new THREE.SphereGeometry(0.08, 8, 8);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        
        this.leftEye = new THREE.Mesh(eyeGeo, eyeMat);
        this.leftEye.position.set(-0.12, 0.1, 0.4);
        this.mesh.add(this.leftEye);
        
        this.rightEye = new THREE.Mesh(eyeGeo, eyeMat);
        this.rightEye.position.set(0.12, 0.1, 0.4);
        this.mesh.add(this.rightEye);
        
        // Pupils (black)
        const pupilGeo = new THREE.SphereGeometry(0.04, 8, 8);
        const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        
        this.leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
        this.leftPupil.position.set(-0.12, 0.1, 0.45);
        this.mesh.add(this.leftPupil);
        
        this.rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
        this.rightPupil.position.set(0.12, 0.1, 0.45);
        this.mesh.add(this.rightPupil);
        
        // Smile (curved shape using torus segment)
        const smileGeo = new THREE.TorusGeometry(0.15, 0.02, 8, 16, Math.PI);
        const smileMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        this.smile = new THREE.Mesh(smileGeo, smileMat);
        this.smile.position.set(0, -0.05, 0.4);
        this.smile.rotation.x = Math.PI / 2;
        this.smile.rotation.z = Math.PI;
        this.mesh.add(this.smile);
        
        // Cigar accessory with glowing tip
        const cigarGeo = new THREE.CylinderGeometry(0.02, 0.025, 0.25, 8);
        const cigarMat = new THREE.MeshToonMaterial({ color: 0x8B4513 }); // Brown
        this.cigar = new THREE.Mesh(cigarGeo, cigarMat);
        this.cigar.position.set(0.2, -0.1, 0.35);
        this.cigar.rotation.z = -Math.PI / 6; // Angled
        this.mesh.add(this.cigar);
        
        // Glowing cigar tip
        const tipGeo = new THREE.SphereGeometry(0.03, 8, 8);
        const tipMat = new THREE.MeshBasicMaterial({ 
          color: 0xFF4500, // Orange-red
          transparent: true,
          opacity: 1
        });
        this.cigarTip = new THREE.Mesh(tipGeo, tipMat);
        this.cigarTip.position.set(0.28, -0.05, 0.35);
        this.mesh.add(this.cigarTip);
        
        // Smoke particles timer
        this.smokeTimer = 0;
        
        // Pulsing glow
        const glowGeo = new THREE.SphereGeometry(0.55, 16, 16);
        const glowMat = new THREE.MeshBasicMaterial({ 
          color: 0x4FC3F7, 
          transparent: true, 
          opacity: 0.2,
          side: THREE.BackSide
        });
        this.glow = new THREE.Mesh(glowGeo, glowMat);
        this.mesh.add(this.glow);
        
        // Aura Circle (visible when aura weapon is active)
        const auraGeo = new THREE.RingGeometry(2.5, 3, 32); // Initial range 3
        const auraMat = new THREE.MeshBasicMaterial({ 
          color: 0x5DADE2, 
          transparent: true, 
          opacity: 0.3,
          side: THREE.DoubleSide
        });
        this.auraCircle = new THREE.Mesh(auraGeo, auraMat);
        this.auraCircle.rotation.x = -Math.PI / 2; // Lay flat on ground
        this.auraCircle.position.y = 0.1;
        this.auraCircle.visible = false;
        scene.add(this.auraCircle);
        
        // Fire Ring Orbs (visible when fireRing weapon is active)
        this.fireRingOrbs = [];
        this.fireRingAngle = 0;
        
        // Physics/Visuals
        this.velocity = new THREE.Vector3(0, 0, 0);
        this.targetScale = new THREE.Vector3(1, 1, 1);
        this.trailTimer = 0;
        this.wobblePhase = 0;
        
        // Dash
        this.isDashing = false;
        this.dashTime = 0;
        this.dashDuration = 0.2;
        this.dashVec = new THREE.Vector3();
      }

      update(dt) {
        // Dash Logic
        if (this.isDashing) {
          this.dashTime -= dt;
          const t = 1 - (this.dashTime / this.dashDuration);
          // Dash distance uses the upgradeable dashDistance variable
          const dashSpeed = (dashDistance / this.dashDuration); // units per second
          const speed = Math.sin(t * Math.PI) * dashSpeed; // Slow-Fast-Slow curve
          this.mesh.position.x += this.dashVec.x * speed * dt;
          this.mesh.position.z += this.dashVec.z * speed * dt;
          
          // Splash effect trail during dash
          if (Math.random() < 0.5) {
            spawnParticles(this.mesh.position, COLORS.player, 2);
            spawnWaterDroplet(this.mesh.position);
          }
          
          if (this.dashTime <= 0) {
            this.isDashing = false;
          }
        }
        // Movement
        else {
          const targetVel = new THREE.Vector3(0, 0, 0);
        
          // Movement with LEFT stick
          if (joystickLeft.active) {
            const speed = GAME_CONFIG.playerSpeedBase * (playerStats.walkSpeed / 25) * 60; // Base speed for 60fps
            targetVel.x = joystickLeft.x * speed * dt; // Frame-rate independent
            targetVel.z = joystickLeft.y * speed * dt;
          
            this.mesh.position.x += targetVel.x;
            this.mesh.position.z += targetVel.z;

            // Water droplet trail when moving
            this.trailTimer += dt;
            if (this.trailTimer > 0.15) {
              this.trailTimer = 0;
              spawnWaterDroplet(this.mesh.position);
            }
          } else {
            // Idle
            this.trailTimer = 0;
          }
          
          // Rotation/Aiming with RIGHT stick (independent of movement)
          if (joystickRight.active) {
            // Turn to face the direction of right stick
            const angle = Math.atan2(joystickRight.x, joystickRight.y);
            this.mesh.rotation.y = angle;
          } else if (gameSettings.autoAim && gameSettings.isPortrait && enemies.length > 0) {
            // Auto-aim in portrait mode: aim at nearest enemy
            let nearestEnemy = null;
            let minDist = Infinity;
            enemies.forEach(e => {
              if (!e.isDead) {
                const dist = this.mesh.position.distanceTo(e.mesh.position);
                if (dist < minDist) {
                  minDist = dist;
                  nearestEnemy = e;
                }
              }
            });
            if (nearestEnemy) {
              const dx = nearestEnemy.mesh.position.x - this.mesh.position.x;
              const dz = nearestEnemy.mesh.position.z - this.mesh.position.z;
              const angle = Math.atan2(dx, dz);
              this.mesh.rotation.y = angle;
            }
          } else if (joystickLeft.active) {
            // If no right stick input, rotate to face movement direction
            const angle = Math.atan2(targetVel.x, targetVel.z);
            this.mesh.rotation.y = angle;
          }

          // Inertia / Squish Effect
          // Lerp velocity for smooth transition
          this.velocity.lerp(targetVel, 0.1);
        }
        
        const speedMag = this.velocity.length();
        
        // Realistic water droplet physics with MORE PRONOUNCED wobble
        // Wobble increases with speed
        this.wobblePhase += dt * (10 + speedMag * 40); // Increased from 8 + speedMag * 30
        const wobble = Math.sin(this.wobblePhase) * (0.08 + speedMag * 0.25); // Increased from 0.05 + speedMag * 0.15
        
        // Squish effect: stretch in direction of movement (MORE DRAMATIC)
        const stretchX = 1 + Math.abs(this.velocity.x) * 2.5; // Increased from 1.5
        const stretchZ = 1 + Math.abs(this.velocity.z) * 2.5; // Increased from 1.5
        const squishY = 1 / Math.sqrt(stretchX * stretchZ);
        
        // Apply deformation with wobble (MORE PRONOUNCED)
        this.mesh.scale.set(
          stretchX * (1 + wobble * 0.5), // Increased from 0.3
          squishY * (1 - wobble * 0.35), // Increased from 0.2
          stretchZ * (1 + wobble * 0.5)  // Increased from 0.3
        );
        
        // Animate water shine
        this.shine.rotation.y += 0.05;
        this.shine.rotation.x += 0.03;
        
        // Pulse highlight
        this.highlight.material.opacity = 0.6 + Math.sin(gameTime * 3) * 0.2;
        
        // Pulse glow effect
        this.glow.material.opacity = 0.15 + Math.sin(gameTime * 2) * 0.1;
        this.glow.scale.set(
          1 + Math.sin(gameTime * 2) * 0.05,
          1 + Math.sin(gameTime * 2) * 0.05,
          1 + Math.sin(gameTime * 2) * 0.05
        );
        
        // Animate cigar tip (pulsing emissive glow)
        if (this.cigarTip) {
          const tipBrightness = 0.7 + Math.sin(gameTime * 8) * 0.3;
          this.cigarTip.material.opacity = tipBrightness;
          
          // Smoke particles from cigar
          this.smokeTimer += dt;
          if (this.smokeTimer > 0.2) { // Every 0.2 seconds
            this.smokeTimer = 0;
            
            // Create smoke particle
            const smokeGeo = new THREE.SphereGeometry(0.05, 6, 6);
            const smokeMat = new THREE.MeshBasicMaterial({ 
              color: 0xCCCCCC,
              transparent: true,
              opacity: 0.5
            });
            const smoke = new THREE.Mesh(smokeGeo, smokeMat);
            
            // Position at cigar tip
            const tipWorldPos = new THREE.Vector3();
            this.cigarTip.getWorldPosition(tipWorldPos);
            smoke.position.copy(tipWorldPos);
            scene.add(smoke);
            
            // Animate smoke rising
            let smokeLife = 80;
            const updateSmoke = () => {
              smokeLife--;
              smoke.position.y += 0.02; // Rise up
              smoke.position.x += (Math.random() - 0.5) * 0.01; // Drift
              smoke.position.z += (Math.random() - 0.5) * 0.01;
              smoke.scale.multiplyScalar(1.02); // Expand
              smoke.material.opacity = (smokeLife / 80) * 0.5; // Fade out
              
              if (smokeLife <= 0) {
                scene.remove(smoke);
                smoke.geometry.dispose();
                smoke.material.dispose();
              } else {
                requestAnimationFrame(updateSmoke);
              }
            };
            updateSmoke();
          }
        }
        
        // Update aura circle
        if (weapons.aura.active) {
          this.auraCircle.visible = true;
          this.auraCircle.position.x = this.mesh.position.x;
          this.auraCircle.position.z = this.mesh.position.z;
          
          // Scale based on aura range
          const scale = weapons.aura.range * 2;
          this.auraCircle.geometry.dispose();
          this.auraCircle.geometry = new THREE.RingGeometry(scale - 0.5, scale, 32);
          
          // Rotate and pulse
          this.auraCircle.rotation.z += 0.02;
          this.auraCircle.material.opacity = 0.25 + Math.sin(gameTime * 4) * 0.15;
        } else {
          this.auraCircle.visible = false;
        }
        
        // Update fire ring orbs
        if (weapons.fireRing.active) {
          const currentOrbCount = weapons.fireRing.orbs;
          
          // Add orbs if needed
          while (this.fireRingOrbs.length < currentOrbCount) {
            const geo = new THREE.SphereGeometry(0.3, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ 
              color: 0xFF4500, 
              transparent: true, 
              opacity: 0.8 
            });
            const orb = new THREE.Mesh(geo, mat);
            scene.add(orb);
            this.fireRingOrbs.push(orb);
          }
          
          // Remove extra orbs if downgraded (shouldn't happen but safety)
          while (this.fireRingOrbs.length > currentOrbCount) {
            const orb = this.fireRingOrbs.pop();
            scene.remove(orb);
            orb.geometry.dispose();
            orb.material.dispose();
          }
          
          // Update orb positions (orbit around player)
          this.fireRingAngle += weapons.fireRing.rotationSpeed * dt;
          const radius = weapons.fireRing.range;
          
          for (let i = 0; i < this.fireRingOrbs.length; i++) {
            const angle = this.fireRingAngle + (i * Math.PI * 2 / currentOrbCount);
            const orb = this.fireRingOrbs[i];
            orb.position.x = this.mesh.position.x + Math.cos(angle) * radius;
            orb.position.z = this.mesh.position.z + Math.sin(angle) * radius;
            orb.position.y = this.mesh.position.y + Math.sin(gameTime * 5 + i) * 0.3; // Bob up and down
            
            // Glow effect
            orb.material.opacity = 0.7 + Math.sin(gameTime * 8 + i) * 0.2;
          }
        } else {
          // Hide orbs when weapon not active
          for (let orb of this.fireRingOrbs) {
            orb.visible = false;
          }
        }

        // Camera Follow
        camera.position.x = this.mesh.position.x;
        camera.position.z = this.mesh.position.z + 20; // Isometric offset
        camera.lookAt(this.mesh.position);

        // Bounds (Map is 400x400, from -200 to 200)
        this.mesh.position.x = Math.max(-195, Math.min(195, this.mesh.position.x));
        this.mesh.position.z = Math.max(-195, Math.min(195, this.mesh.position.z));
      }

      dash(dx, dz) {
        if (this.isDashing) return;
        this.isDashing = true;
        this.dashTime = this.dashDuration;
        
        // Splash effect on dash start - more dramatic
        spawnParticles(this.mesh.position, COLORS.player, 20);
        for(let i=0; i<8; i++) {
          spawnWaterDroplet(this.mesh.position);
        }
        
        // Direct mapping: Screen coordinates to World coordinates
        // Screen X-axis maps to World X-axis
        // Screen Y-axis maps to World Z-axis
        // This gives us proper 360-degree directional dash
        this.dashVec.set(dx, 0, dz).normalize();
        
        // Water splash sound
        playSound('splash');
      }

      takeDamage(amount) {
        // Armor reduction
        const reduced = Math.max(1, amount * (1 - playerStats.armor / 100));
        playerStats.hp -= reduced;
        updateHUD();
        playSound('hit');
        
        // Visual flash
        this.mesh.material.color.setHex(0xFF0000);
        setTimeout(() => {
          this.mesh.material.color.setHex(COLORS.player);
        }, 100);
        
        // Drop water particles and squishy deformation
        spawnParticles(this.mesh.position, COLORS.player, 8);
        for(let i=0; i<3; i++) {
          spawnWaterDroplet(this.mesh.position);
        }
        
        // Squishy deformation animation
        this.mesh.scale.set(1.3, 0.7, 1.3);
        setTimeout(() => {
          this.mesh.scale.set(0.8, 1.2, 0.8);
          setTimeout(() => {
            this.mesh.scale.set(1, 1, 1);
          }, 50);
        }, 50);
        
        // Screen shake on damage
        const originalCameraPos = { 
          x: camera.position.x, 
          y: camera.position.y, 
          z: camera.position.z 
        };
        let shakeTime = 0;
        const shakeDuration = 0.2;
        
        const shakeAnim = () => {
          shakeTime += 0.016;
          if (shakeTime < shakeDuration) {
            const intensity = (1 - shakeTime / shakeDuration) * 0.5;
            camera.position.x = originalCameraPos.x + (Math.random() - 0.5) * intensity;
            camera.position.y = originalCameraPos.y + (Math.random() - 0.5) * intensity;
            camera.position.z = originalCameraPos.z + (Math.random() - 0.5) * intensity;
            requestAnimationFrame(shakeAnim);
          } else {
            camera.position.x = originalCameraPos.x;
            camera.position.y = originalCameraPos.y;
            camera.position.z = originalCameraPos.z;
          }
        };
        shakeAnim();

        if (playerStats.hp <= 0) {
          // Death splash: 30 particles + ground pool with fade
          spawnParticles(this.mesh.position, COLORS.player, 30);
          
          // Create ground pool (flat circle that fades out)
          const poolGeo = new THREE.CircleGeometry(1.5, 16);
          const poolMat = new THREE.MeshBasicMaterial({ 
            color: COLORS.player, 
            transparent: true, 
            opacity: 0.6,
            side: THREE.DoubleSide
          });
          const pool = new THREE.Mesh(poolGeo, poolMat);
          pool.rotation.x = -Math.PI / 2;
          pool.position.set(this.mesh.position.x, 0.05, this.mesh.position.z);
          scene.add(pool);
          
          // Fade out pool over time
          const fadePool = () => {
            poolMat.opacity -= 0.01;
            if (poolMat.opacity > 0) {
              setTimeout(fadePool, 50);
            } else {
              scene.remove(pool);
              poolGeo.dispose();
              poolMat.dispose();
            }
          };
          setTimeout(fadePool, 500);
          
          gameOver();
        }
      }
    }

    // Cached deformed geometry for Hard Tank (performance optimization)
    // Note: All Hard Tank enemies share the same deformed shape for performance.
    // This is intentional - visual variety comes from animations and positioning.
    let hardTankGeometryCache = null;
    function getHardTankGeometry() {
      if (!hardTankGeometryCache) {
        const geometry = new THREE.SphereGeometry(0.6, 8, 8);
        const positions = geometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
          const x = positions.getX(i);
          const y = positions.getY(i);
          const z = positions.getZ(i);
          const noiseX = 1 + (Math.random() - 0.5) * 0.3;
          const noiseY = 1 + (Math.random() - 0.5) * 0.3;
          const noiseZ = 1 + (Math.random() - 0.5) * 0.3;
          positions.setX(i, x * noiseX);
          positions.setY(i, y * noiseY);
          positions.setZ(i, z * noiseZ);
        }
        geometry.computeVertexNormals();
        hardTankGeometryCache = geometry;
      }
      return hardTankGeometryCache;
    }

    class Enemy {
      constructor(type, x, z, playerLevel = 1) {
        this.type = type; // 0: Tank, 1: Fast, 2: Balanced, 3: Slowing, 4: Ranged, 5: Flying, 6: Hard Tank, 7: Hard Fast, 8: Hard Balanced, 9: Elite, 10: MiniBoss
        let geometry;
        let color;
        
        // Enemy scaling based on player level - NOT SPEED, just HP and DAMAGE
        const levelScaling = 1 + (playerLevel - 1) * 0.10; // Reduced from 15% to 10% increase per level for better balance
        
        if (type === 0) {
          // Bacteria/Amoeba - Squishy organic blob shape
          geometry = new THREE.SphereGeometry(0.6, 8, 8);
          // Modify geometry to make it irregular/organic
          const positions = geometry.attributes.position;
          for (let i = 0; i < positions.count; i++) {
            const x = positions.getX(i);
            const y = positions.getY(i);
            const z = positions.getZ(i);
            // Add different randomness for each axis for truly organic look
            const noiseX = 1 + (Math.random() - 0.5) * 0.3;
            const noiseY = 1 + (Math.random() - 0.5) * 0.3;
            const noiseZ = 1 + (Math.random() - 0.5) * 0.3;
            positions.setX(i, x * noiseX);
            positions.setY(i, y * noiseY);
            positions.setZ(i, z * noiseZ);
          }
          geometry.computeVertexNormals();
          color = COLORS.enemySquare; // Pink/Hot Pink - Tanky
        } else if (type === 1) {
          // Water Bug - Elongated with segments
          geometry = new THREE.CapsuleGeometry(0.3, 0.8, 6, 8);
          color = COLORS.enemyTriangle; // Gold - Fast
        } else if (type === 2) {
          // Microbe - Round squishy
          geometry = new THREE.DodecahedronGeometry(0.5, 0);
          color = COLORS.enemyRound; // Purple - Balanced
        } else if (type === 3) {
          // Slowing Enemy - Spiky/icy appearance
          geometry = new THREE.IcosahedronGeometry(0.55, 0);
          color = 0x00FFFF; // Cyan - Slowing
        } else if (type === 4) {
          // Ranged Enemy - Different shape, angular
          geometry = new THREE.TetrahedronGeometry(0.6, 0);
          color = 0xFF6347; // Tomato red - Ranged
        } else if (type === 5) {
          // Flying Enemy - Octahedron
          geometry = new THREE.OctahedronGeometry(0.5, 1);
          color = 0x87CEEB; // Sky blue - Flying
        } else if (type === 6) {
          // Hard Tank - use cached deformed geometry for performance
          geometry = getHardTankGeometry();
          color = 0xFF1493; // Deep pink - Hard Tank
        } else if (type === 7) {
          // Hard Fast
          geometry = new THREE.CapsuleGeometry(0.3, 0.8, 6, 8);
          color = 0xFFD700; // Gold - Hard Fast
        } else if (type === 8) {
          // Hard Balanced
          geometry = new THREE.DodecahedronGeometry(0.5, 0);
          color = 0x9932CC; // Dark orchid - Hard Balanced
        } else if (type === 9) {
          // Elite
          geometry = new THREE.IcosahedronGeometry(0.6, 0);
          color = 0xFF0000; // Red - Elite
        } else if (type === 10) {
          // MiniBoss
          geometry = new THREE.DodecahedronGeometry(1.0, 1);
          color = 0xFFD700; // Gold - MiniBoss
        }

        const material = new THREE.MeshPhysicalMaterial({ 
          color: color,
          transparent: true,
          opacity: 0.85,
          metalness: type === 10 ? 0.4 : 0.1,
          roughness: 0.6,
          transmission: 0.2,
          thickness: 0.5,
          emissive: type === 10 ? color : 0x000000,
          emissiveIntensity: type === 10 ? 0.3 : 0
        });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(x, type === 5 ? 2 : 0.5, z);
        this.mesh.castShadow = true;
        scene.add(this.mesh);

        // Stats based on type - SCALED BY LEVEL (Rebalanced for better gameplay)
        if (type === 0) { // Tank
          this.hp = 120 * levelScaling; // Reduced from 150
          this.speed = GAME_CONFIG.enemySpeedBase * 0.6; // Speed NOT scaled
        } else if (type === 1) { // Fast, Low HP
          this.hp = 35 * levelScaling; // Reduced from 40
          this.speed = GAME_CONFIG.enemySpeedBase * 1.6; // Speed NOT scaled
        } else if (type === 2) { // Balanced
          this.hp = 70 * levelScaling; // Reduced from 80
          this.speed = GAME_CONFIG.enemySpeedBase; // Speed NOT scaled
        } else if (type === 3) { // Slowing
          this.hp = 85 * levelScaling; // Reduced from 100
          this.speed = GAME_CONFIG.enemySpeedBase * 0.8; // Speed NOT scaled
          this.slowDuration = 2000; // 2 seconds slow
          this.slowAmount = 0.5; // 50% slow
        } else if (type === 4) { // Ranged
          this.hp = 50 * levelScaling; // Reduced from 60
          this.speed = GAME_CONFIG.enemySpeedBase * 0.7; // Speed NOT scaled
          this.attackRange = 8; // Range for ranged attacks
          this.projectileSpeed = 0.15;
        } else if (type === 5) { // Flying
          this.hp = 60 * levelScaling;
          this.speed = GAME_CONFIG.enemySpeedBase * 1.3;
          this.isFlying = true;
        } else if (type === 6) { // Hard Tank
          this.hp = 180 * levelScaling;
          this.speed = GAME_CONFIG.enemySpeedBase * 0.65;
        } else if (type === 7) { // Hard Fast
          this.hp = 55 * levelScaling;
          this.speed = GAME_CONFIG.enemySpeedBase * 1.8;
        } else if (type === 8) { // Hard Balanced
          this.hp = 110 * levelScaling;
          this.speed = GAME_CONFIG.enemySpeedBase * 1.1;
        } else if (type === 9) { // Elite
          this.hp = 200 * levelScaling;
          this.speed = GAME_CONFIG.enemySpeedBase * 0.9;
        } else if (type === 10) { // MiniBoss
          const miniBossStartLevel = 10;
          this.hp = 500 * (1 + (playerLevel - miniBossStartLevel) * 0.15);
          this.speed = GAME_CONFIG.enemySpeedBase * 0.5;
          this.isMiniBoss = true;
        }
        
        this.maxHp = this.hp;
        this.damage = (type === 9 ? 25 * 1.5 : 25) * levelScaling; // Elite does 1.5x damage
        if (type === 10) this.damage = 50 * levelScaling; // MiniBoss damage
        this.isDead = false;
        this.isDamaged = false; // Track if enemy has been visually damaged
        this.pulsePhase = Math.random() * Math.PI;
        this.wobbleOffset = Math.random() * 100;
        this.lastAttackTime = 0;
        this.attackCooldown = 1000; // 1 second cooldown
      }

      update(dt, playerPos) {
        if (this.isDead) return;

        // Windmill Quest: Attack windmill instead of player
        let targetPos = playerPos;
        if (windmillQuest.active && windmillQuest.windmill) {
          targetPos = windmillQuest.windmill.position;
        }

        // Move towards target
        const dx = targetPos.x - this.mesh.position.x;
        const dz = targetPos.z - this.mesh.position.z;
        const dist = Math.sqrt(dx*dx + dz*dz);

        // Ranged Enemy behavior - stop at range and shoot
        if (this.type === 4 && dist < this.attackRange) {
          // Stop moving and attack from range
          const now = Date.now();
          if (now - this.lastAttackTime > this.attackCooldown) {
            // Fire projectile at player
            this.fireProjectile(targetPos);
            this.lastAttackTime = now;
          }
          this.mesh.lookAt(targetPos);
        } else if (dist > 0.5) {
          // Check if slow effect expired
          if (this.slowedUntil && this.slowedUntil < Date.now()) {
            this.speed = this.originalSpeed || this.speed;
            this.slowedUntil = null;
          }
          
          // Move towards target
          let vx = (dx / dist) * this.speed;
          let vz = (dz / dist) * this.speed;
          
          // Type 1 (Fast) - Zigzag perpendicular oscillation
          if (this.type === 1) {
            const wobble = Math.sin(gameTime * 12 + this.wobbleOffset) * 0.08;
            vx += wobble * (dz/dist); // Perpendicular oscillation
            vz -= wobble * (dx/dist);
          }
          
          // Type 2 (Balanced) - Slight weaving instead of circle strafe
          if (this.type === 2) {
            const weavePhase = gameTime * 4 + this.wobbleOffset;
            const weave = Math.sin(weavePhase) * 0.05;
            vx += weave * (-dz/dist);
            vz += weave * (dx/dist);
          }
          
          // Type 0 (Tank/Slow) - Weaving approach pattern
          if (this.type === 0) {
            const weavePhase = gameTime * 3 + this.wobbleOffset;
            const weave = Math.sin(weavePhase) * 0.06;
            vx += weave * (-dz/dist); // Weave side to side
            vz += weave * (dx/dist);
          }
          
          // Type 5 (Flying) - Wavy flying pattern
          if (this.type === 5) {
            const wavePhase = gameTime * 5 + this.wobbleOffset;
            const wave = Math.sin(wavePhase) * 0.1;
            vx += wave * (dz/dist);
            vz -= wave * (dx/dist);
            // Flying height with sin wave
            this.mesh.position.y = 2 + Math.sin(gameTime * 3 + this.wobbleOffset) * 0.5;
          }
          
          this.mesh.position.x += vx;
          this.mesh.position.z += vz;
          this.mesh.lookAt(targetPos);
        }

        // Collision with target
        if (windmillQuest.active && windmillQuest.windmill && dist < 3.0) {
          // Attack windmill with cooldown
          const now = Date.now();
          if (now - this.lastAttackTime > this.attackCooldown) {
            windmillQuest.windmill.userData.hp -= this.damage;
            updateWindmillQuestUI();
            this.lastAttackTime = now;
            playSound('hit');
          }
          // Knockback
          this.mesh.position.x -= (dx / dist) * 2;
          this.mesh.position.z -= (dz / dist) * 2;
          
          if (windmillQuest.windmill.userData.hp <= 0) {
            windmillQuest.active = false;
            createFloatingText("WINDMILL DESTROYED!", windmillQuest.windmill.position);
            document.getElementById('windmill-quest-ui').style.display = 'none';
          }
        } else if (dist < 1.0 && this.type !== 4) { // Ranged enemies don't melee attack
          // Attack player
          player.takeDamage(this.damage);
          
          // Slowing enemy slows player on hit
          if (this.type === 3) {
            playerStats.walkSpeed *= this.slowAmount;
            // Remove slow after duration
            setTimeout(() => {
              playerStats.walkSpeed /= this.slowAmount;
            }, this.slowDuration);
            // Visual effect for slow
            spawnParticles(player.mesh.position, 0x00FFFF, 10);
          }
          
          // Knockback
          this.mesh.position.x -= (dx / dist) * 2;
          this.mesh.position.z -= (dz / dist) * 2;
        }

        // Squishy idle with more gravity-based wobble
        this.pulsePhase += dt * 6; // Slightly faster
        const squish = Math.sin(this.pulsePhase) * 0.08; // More pronounced from 0.05
        
        // MiniBoss glowing effect
        if (this.isMiniBoss) {
          const glowIntensity = 0.3 + Math.sin(this.pulsePhase * 2) * 0.2;
          this.mesh.material.emissiveIntensity = glowIntensity;
          // Larger breathing effect for mini-boss
          this.mesh.scale.set(1+squish*2, 1-squish*2, 1+squish*2);
        } else if (this.type === 0 || this.type === 3 || this.type === 6) {
           // Tank, Slowing, and Hard Tank breathe more dramatically
           this.mesh.scale.set(1+squish*1.5, 1-squish*1.5, 1+squish*1.5);
        } else {
           this.mesh.scale.set(1-squish, 1+squish*1.5, 1-squish);
        }
      }

      fireProjectile(targetPos) {
        // Create enemy projectile
        const projectile = {
          startPos: this.mesh.position.clone(),
          targetPos: targetPos.clone(),
          mesh: null,
          speed: this.projectileSpeed,
          damage: this.damage,
          lifetime: 100, // frames
          isEnemyProjectile: true
        };
        
        // Create visual
        const geo = new THREE.SphereGeometry(0.2, 8, 8);
        const mat = new THREE.MeshBasicMaterial({ color: 0xFF6347 });
        projectile.mesh = new THREE.Mesh(geo, mat);
        projectile.mesh.position.copy(this.mesh.position);
        projectile.mesh.position.y = 0.5;
        scene.add(projectile.mesh);
        
        // Direction
        const dx = targetPos.x - this.mesh.position.x;
        const dz = targetPos.z - this.mesh.position.z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        projectile.direction = new THREE.Vector3(dx/dist, 0, dz/dist);
        
        // Add to projectiles array (will be updated in main loop)
        projectiles.push(projectile);
        
        playSound('shoot');
      }

      takeDamage(amount, isCrit = false) {
        const oldHp = this.hp;
        this.hp -= amount;
        createDamageNumber(amount, this.mesh.position, isCrit);
        
        const hpPercent = this.hp / this.maxHp;
        const oldHpPercent = oldHp / this.maxHp;
        
        // 75% HP: Blood spots, darken color by 20%
        if (oldHpPercent >= 0.75 && hpPercent < 0.75 && !this.stage1Damage) {
          this.stage1Damage = true;
          
          // Darken color
          const currentColor = this.mesh.material.color;
          currentColor.r *= 0.8;
          currentColor.g *= 0.8;
          currentColor.b *= 0.8;
          
          // Blood spots (small red particles)
          spawnParticles(this.mesh.position, 0x8B0000, 10);
          playSound('hit');
        }
        
        // 50% HP: Add flesh/hole meshes
        if (oldHpPercent >= 0.5 && hpPercent < 0.5 && !this.stage2Damage) {
          this.stage2Damage = true;
          
          // Add visible wounds/holes
          for(let i=0; i<3; i++) {
            const holeGeo = new THREE.SphereGeometry(0.1, 6, 6);
            const holeMat = new THREE.MeshBasicMaterial({ color: 0x220000 }); // Dark red
            const hole = new THREE.Mesh(holeGeo, holeMat);
            hole.position.set(
              (Math.random() - 0.5) * 0.5,
              (Math.random() - 0.5) * 0.5,
              (Math.random() - 0.5) * 0.5
            );
            this.mesh.add(hole);
          }
          
          spawnParticles(this.mesh.position, 0x8B0000, 15);
          playSound('hit');
        }
        
        // 25% HP: Limbs fly off, walkSpeed *= 0.6
        if (oldHpPercent >= 0.25 && hpPercent < 0.25 && !this.stage3Damage) {
          this.stage3Damage = true;
          
          // Reduce speed
          this.speed *= 0.6;
          
          // Spawn limb pieces
          const enemyColor = this.mesh.material.color.getHex();
          for(let i = 0; i < 4; i++) {
            const limb = new THREE.Mesh(
              new THREE.BoxGeometry(0.3, 0.1, 0.1),
              new THREE.MeshBasicMaterial({ color: enemyColor })
            );
            limb.position.copy(this.mesh.position);
            scene.add(limb);
            
            const vel = new THREE.Vector3(
              (Math.random() - 0.5) * 0.4,
              Math.random() * 0.5,
              (Math.random() - 0.5) * 0.4
            );
            
            let life = 50;
            const updateLimb = () => {
              life--;
              limb.position.add(vel);
              vel.y -= 0.02; // Gravity
              limb.rotation.x += 0.15;
              limb.rotation.y += 0.15;
              
              if (life <= 0 || limb.position.y < 0) {
                scene.remove(limb);
                limb.geometry.dispose();
                limb.material.dispose();
              } else {
                requestAnimationFrame(updateLimb);
              }
            };
            updateLimb();
          }
          
          spawnParticles(this.mesh.position, enemyColor, 20);
          playSound('hit');
        }
        
        // Destruction effect at 20% HP threshold (keep existing behavior)
        if (oldHpPercent >= 0.2 && hpPercent < 0.2 && !this.isDamaged) {
          this.isDamaged = true;
          
          // Visually damage the enemy - make smaller and break off pieces
          const damagePercent = 0.35 + Math.random() * 0.15; // 35-50%
          const newScale = 1 - damagePercent;
          this.mesh.scale.multiplyScalar(newScale);
          
          // Spawn broken pieces
          const enemyColor = this.mesh.material.color.getHex();
          for(let i = 0; i < 5; i++) {
            const piece = new THREE.Mesh(
              new THREE.BoxGeometry(0.2, 0.2, 0.2),
              new THREE.MeshBasicMaterial({ color: enemyColor })
            );
            piece.position.copy(this.mesh.position);
            scene.add(piece);
            
            const vel = new THREE.Vector3(
              (Math.random() - 0.5) * 0.3,
              Math.random() * 0.4,
              (Math.random() - 0.5) * 0.3
            );
            
            let life = 40;
            const updatePiece = () => {
              life--;
              piece.position.add(vel);
              vel.y -= 0.02; // Gravity
              piece.rotation.x += 0.1;
              piece.rotation.y += 0.1;
              
              if (life <= 0 || piece.position.y < 0) {
                scene.remove(piece);
                piece.geometry.dispose();
                piece.material.dispose();
              } else {
                requestAnimationFrame(updatePiece);
              }
            };
            updatePiece();
          }
          
          // Enhanced particles for destruction
          spawnParticles(this.mesh.position, enemyColor, 15);
          playSound('hit');
        }
        
        // Flash
        const oldColor = this.mesh.material.color.getHex();
        this.mesh.material.color.setHex(0xFFFFFF);
        
        // Enhanced splash particles using enemy's own color
        const enemyColor = oldColor;
        const particleCount = isCrit ? 8 : 3;
        spawnParticles(this.mesh.position, enemyColor, particleCount);
        
        // Additional impact particles
        if (isCrit) {
          spawnParticles(this.mesh.position, enemyColor, 5);
          spawnParticles(this.mesh.position, 0xFFFFFF, 3);
        }
        
        // Enhanced squishy deformation on hit
        const squishScale = isCrit ? 0.7 : 0.85;
        this.mesh.scale.set(squishScale, 1.3, squishScale);
        setTimeout(() => {
          this.mesh.scale.set(1, 1, 1);
        }, 100);
        
        setTimeout(() => this.mesh.material.color.setHex(oldColor), 50);

        if (this.hp <= 0) {
          this.die();
        }
      }

      die() {
        this.isDead = true;
        
        // More dramatic explosion effect on death
        const enemyColor = this.mesh.material.color.getHex();
        
        // Main explosion
        spawnParticles(this.mesh.position, enemyColor, 25);
        spawnParticles(this.mesh.position, 0xFFFFFF, 10);
        
        // Explode into pieces
        for(let i = 0; i < 8; i++) {
          const piece = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.3, 0.3),
            new THREE.MeshBasicMaterial({ color: enemyColor })
          );
          piece.position.copy(this.mesh.position);
          scene.add(piece);
          
          const angle = (i / 8) * Math.PI * 2;
          const vel = new THREE.Vector3(
            Math.cos(angle) * 0.4,
            0.3 + Math.random() * 0.3,
            Math.sin(angle) * 0.4
          );
          
          let life = 50;
          const updatePiece = () => {
            life--;
            piece.position.add(vel);
            vel.y -= 0.02; // Gravity
            piece.rotation.x += 0.15;
            piece.rotation.y += 0.15;
            piece.material.opacity = life / 50;
            
            if (life <= 0 || piece.position.y < 0) {
              scene.remove(piece);
              piece.geometry.dispose();
              piece.material.dispose();
            } else {
              requestAnimationFrame(updatePiece);
            }
          };
          updatePiece();
        }
        
        // Screen flash on kill (dopamine boost)
        const flash = document.createElement('div');
        flash.style.position = 'fixed';
        flash.style.top = '0';
        flash.style.left = '0';
        flash.style.width = '100%';
        flash.style.height = '100%';
        flash.style.background = 'rgba(255, 255, 255, 0.2)';
        flash.style.pointerEvents = 'none';
        flash.style.zIndex = '500';
        document.body.appendChild(flash);
        setTimeout(() => flash.remove(), 50);
        
        scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        
        // Drop EXP
        const expMultiplier = this.isMiniBoss ? 3 : 1;
        for (let i = 0; i < expMultiplier; i++) {
          spawnExp(this.mesh.position.x, this.mesh.position.z);
        }
        
        // Drop GOLD based on enemy type
        let goldAmount = 0;
        if (this.isMiniBoss) {
          // MiniBoss: guaranteed 50-100 gold
          goldAmount = 50 + Math.floor(Math.random() * 51);
        } else if (this.type === 0) { // Tank
          goldAmount = 3 + Math.floor(Math.random() * 3); // 3-5 gold
        } else if (this.type === 1) { // Fast
          goldAmount = 1 + Math.floor(Math.random() * 2); // 1-2 gold
        } else if (this.type === 2) { // Balanced
          goldAmount = 2 + Math.floor(Math.random() * 2); // 2-3 gold
        } else if (this.type === 3) { // Slowing
          goldAmount = 3 + Math.floor(Math.random() * 2); // 3-4 gold
        } else if (this.type === 4) { // Ranged
          goldAmount = 2 + Math.floor(Math.random() * 3); // 2-4 gold
        } else if (this.type === 5) { // Flying
          goldAmount = 3 + Math.floor(Math.random() * 3); // 3-5 gold
        } else if (this.type === 6) { // Hard Tank
          goldAmount = 5 + Math.floor(Math.random() * 4); // 5-8 gold
        } else if (this.type === 7) { // Hard Fast
          goldAmount = 4 + Math.floor(Math.random() * 3); // 4-6 gold
        } else if (this.type === 8) { // Hard Balanced
          goldAmount = 4 + Math.floor(Math.random() * 4); // 4-7 gold
        } else if (this.type === 9) { // Elite
          goldAmount = 8 + Math.floor(Math.random() * 5); // 8-12 gold
        } else {
          goldAmount = 2 + Math.floor(Math.random() * 2); // 2-3 gold (fallback)
        }
        spawnGold(this.mesh.position.x, this.mesh.position.z, goldAmount);
        
        playerStats.kills++;
        updateHUD();
        checkAchievements(); // Check for achievements after kill
      }
    }

    class Projectile {
      constructor(x, z, target) {
        const geometry = new THREE.SphereGeometry(0.2, 8, 8);
        const material = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(x, 0.5, z);
        scene.add(this.mesh);

        this.speed = 0.4;
        this.active = true;
        this.life = 60; // Frames

        // Calculate direction
        const dx = target.x - x;
        const dz = target.z - z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        this.vx = (dx / dist) * this.speed;
        this.vz = (dz / dist) * this.speed;
      }

      update() {
        if (!this.active) return;
        
        // Handle enemy projectiles separately
        if (this.isEnemyProjectile) {
          this.mesh.position.add(this.direction.clone().multiplyScalar(this.speed));
          this.lifetime--;
          
          if (this.lifetime <= 0) {
            this.destroy();
            return;
          }
          
          // Check collision with player
          const dx = this.mesh.position.x - player.mesh.position.x;
          const dz = this.mesh.position.z - player.mesh.position.z;
          if (dx*dx + dz*dz < 0.8) { // Hit radius
            player.takeDamage(this.damage);
            spawnParticles(player.mesh.position, 0xFF6347, 5);
            this.destroy();
            playSound('hit');
          }
          return;
        }
        
        // Player projectiles
        this.mesh.position.x += this.vx;
        this.mesh.position.z += this.vz;
        this.life--;

        if (this.life <= 0) {
          this.destroy();
          return;
        }

        // Collision Check
        for (let enemy of enemies) {
          if (enemy.isDead) continue;
          const dx = this.mesh.position.x - enemy.mesh.position.x;
          const dz = this.mesh.position.z - enemy.mesh.position.z;
          if (dx*dx + dz*dz < 0.6) { // Hit radius
            // Calculate Damage
            let dmg = weapons.gun.damage * playerStats.damage * playerStats.strength;
            
            // Double barrel uses its own damage
            if (weapons.doubleBarrel.active && this.isDoubleBarrel) {
              dmg = weapons.doubleBarrel.damage * playerStats.damage * playerStats.strength;
            }
            
            const isCrit = Math.random() < playerStats.critChance;
            if (isCrit) dmg *= playerStats.critDmg;
            
            enemy.takeDamage(Math.floor(dmg), isCrit);
            
            // Knockback effect
            const knockbackForce = 0.5;
            enemy.mesh.position.x += this.vx * knockbackForce;
            enemy.mesh.position.z += this.vz * knockbackForce;
            
            // Water splash effect on hit
            spawnParticles(enemy.mesh.position, COLORS.player, 5);
            spawnParticles(enemy.mesh.position, 0xFFFFFF, 3);
            
            this.destroy();
            playSound('hit');
            break;
          }
        }
      }

      destroy() {
        this.active = false;
        scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
      }
    }

    class SwordSlash {
      constructor(x, z, angle) {
        // Arc geometry
        const geometry = new THREE.RingGeometry(1.5, 2.5, 8, 1, -Math.PI/4, Math.PI/2);
        const material = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.rotation.x = -Math.PI / 2;
        this.mesh.rotation.z = angle - Math.PI/4; // Adjust for arc center
        this.mesh.position.set(x, 0.6, z);
        scene.add(this.mesh);
        
        this.life = 10; // frames
        this.maxLife = 10;
        
        // Deal damage immediately
        const dmg = weapons.sword.damage * playerStats.strength * playerStats.damage;
        
        enemies.forEach(e => {
          const dx = e.mesh.position.x - x;
          const dz = e.mesh.position.z - z;
          const dist = Math.sqrt(dx*dx + dz*dz);
          
          if (dist < 3.5) {
            // Check angle
            const eAngle = Math.atan2(dz, dx); // -PI to PI
            // Normalize angles
            let diff = eAngle - angle;
            while (diff < -Math.PI) diff += Math.PI*2;
            while (diff > Math.PI) diff -= Math.PI*2;
            
            if (Math.abs(diff) < Math.PI/3) {
              e.takeDamage(dmg);
            }
          }
        });
      }
      
      update() {
        this.life--;
        this.mesh.material.opacity = this.life / this.maxLife;
        if (this.life <= 0) {
          scene.remove(this.mesh);
          this.mesh.geometry.dispose();
          this.mesh.material.dispose();
          return false;
        }
        return true;
      }
    }

    class IceSpear {
      constructor(x, z, target) {
        // Ice spear shape - elongated diamond
        const geometry = new THREE.ConeGeometry(0.15, 0.6, 4);
        const material = new THREE.MeshBasicMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.9 });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(x, 0.5, z);
        scene.add(this.mesh);

        this.speed = 0.35;
        this.active = true;
        this.life = 70; // Frames - longer range than normal projectile

        // Calculate direction
        const dx = target.x - x;
        const dz = target.z - z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        this.vx = (dx / dist) * this.speed;
        this.vz = (dz / dist) * this.speed;
        
        // Rotate spear to face direction
        this.mesh.rotation.z = -Math.atan2(dz, dx) + Math.PI/2;
        this.mesh.rotation.x = Math.PI/2;
        
        // Trailing particles
        this.particleTimer = 0;
      }

      update() {
        if (!this.active) return false;
        
        this.mesh.position.x += this.vx;
        this.mesh.position.z += this.vz;
        this.life--;
        
        // Ice trail particles
        this.particleTimer++;
        if (this.particleTimer % 3 === 0) {
          spawnParticles(this.mesh.position, 0x87CEEB, 2);
        }

        if (this.life <= 0) {
          this.destroy();
          return false;
        }

        // Collision Check
        for (let enemy of enemies) {
          if (enemy.isDead) continue;
          const dx = this.mesh.position.x - enemy.mesh.position.x;
          const dz = this.mesh.position.z - enemy.mesh.position.z;
          if (dx*dx + dz*dz < 0.6) {
            // Calculate Damage
            let dmg = weapons.iceSpear.damage * playerStats.damage * playerStats.strength;
            const isCrit = Math.random() < playerStats.critChance;
            if (isCrit) dmg *= playerStats.critDmg;
            
            enemy.takeDamage(Math.floor(dmg), isCrit);
            
            // Apply slow effect
            if (!enemy.slowedUntil || enemy.slowedUntil < Date.now()) {
              enemy.originalSpeed = enemy.speed;
            }
            enemy.slowedUntil = Date.now() + weapons.iceSpear.slowDuration;
            enemy.speed = enemy.originalSpeed * (1 - weapons.iceSpear.slowPercent);
            
            // Ice impact particles
            spawnParticles(enemy.mesh.position, 0x87CEEB, 8);
            spawnParticles(enemy.mesh.position, 0xFFFFFF, 5);
            
            // Visual ice effect on enemy
            if (enemy.mesh.material.color) {
              const originalColor = enemy.mesh.material.color.getHex();
              enemy.mesh.material.color.setHex(0xADD8E6); // Light blue
              setTimeout(() => {
                if (enemy.mesh.material.color) {
                  enemy.mesh.material.color.setHex(originalColor);
                }
              }, 200);
            }
            
            this.destroy();
            playSound('hit');
            break;
          }
        }
        return true;
      }

      destroy() {
        this.active = false;
        scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
      }
    }

    class Meteor {
      constructor(targetX, targetZ) {
        this.target = new THREE.Vector3(targetX, 0, targetZ);
        
        // Falling sphere
        const geo = new THREE.DodecahedronGeometry(1.5);
        const mat = new THREE.MeshToonMaterial({ color: 0xFF4500, emissive: 0x8B0000 });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.set(targetX, 20, targetZ);
        scene.add(this.mesh);
        
        // Shadow indicator
        const shadowGeo = new THREE.CircleGeometry(2.5, 16);
        const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.3, transparent: true });
        this.shadow = new THREE.Mesh(shadowGeo, shadowMat);
        this.shadow.rotation.x = -Math.PI/2;
        this.shadow.position.set(targetX, 0.1, targetZ);
        scene.add(this.shadow);
        
        this.speed = 0.5;
        this.active = true;
      }
      
      update() {
        if (!this.active) return false;
        
        this.mesh.position.y -= this.speed;
        this.speed += 0.05; // Gravity
        
        if (this.mesh.position.y <= 0) {
          this.explode();
          return false;
        }
        return true;
      }
      
      explode() {
        this.active = false;
        scene.remove(this.mesh);
        scene.remove(this.shadow);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        this.shadow.geometry.dispose();
        this.shadow.material.dispose();
        
        // AOE Damage
        const range = weapons.meteor.area;
        const dmg = weapons.meteor.damage * playerStats.strength;
        
        enemies.forEach(e => {
          const d = e.mesh.position.distanceTo(this.target);
          if (d < range) {
            e.takeDamage(dmg);
          }
        });
        
        // Visuals
        spawnParticles(this.target, 0xFF4500, 10);
        spawnParticles(this.target, 0xFFFF00, 5);
        playSound('hit'); // Boom
      }
    }

    class Particle {
      constructor(pos, color) {
        const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const mat = new THREE.MeshBasicMaterial({ color: color });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.copy(pos);
        
        this.vel = new THREE.Vector3(
          (Math.random() - 0.5) * 0.3,
          Math.random() * 0.3,
          (Math.random() - 0.5) * 0.3
        );
        
        scene.add(this.mesh);
        this.life = 30;
      }
      
      update() {
        this.life--;
        this.mesh.position.add(this.vel);
        this.vel.y -= 0.02; // Gravity
        this.mesh.rotation.x += 0.1;
        this.mesh.rotation.y += 0.1;
        
        if (this.mesh.position.y < 0) {
          this.mesh.position.y = 0;
          this.vel.y = 0;
          this.vel.x *= 0.8;
          this.vel.z *= 0.8;
        }
        
        if (this.life <= 0) {
          scene.remove(this.mesh);
          this.mesh.geometry.dispose();
          this.mesh.material.dispose();
          return false;
        }
        return true;
      }
    }

    class ExpGem {
      constructor(x, z) {
        // Create 6-sided star shape
        const starShape = new THREE.Shape();
        const outerRadius = 0.36;
        const innerRadius = 0.18;
        const points = 6;
        
        for (let i = 0; i < points * 2; i++) {
          const angle = (i / (points * 2)) * Math.PI * 2;
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          
          if (i === 0) {
            starShape.moveTo(x, y);
          } else {
            starShape.lineTo(x, y);
          }
        }
        starShape.closePath();
        
        const extrudeSettings = {
          depth: 0.1,
          bevelEnabled: true,
          bevelThickness: 0.05,
          bevelSize: 0.05,
          bevelSegments: 2
        };
        
        const geometry = new THREE.ExtrudeGeometry(starShape, extrudeSettings);
        geometry.center();
        
        const material = new THREE.MeshPhysicalMaterial({ 
          color: COLORS.exp, // Light blue matching EXP bar
          transparent: true,
          opacity: 0.8,
          metalness: 0.3,
          roughness: 0.2,
          transmission: 0.2,
          thickness: 0.5,
          envMapIntensity: 1,
          clearcoat: 1,
          clearcoatRoughness: 0.1,
          emissive: COLORS.exp,
          emissiveIntensity: 0.3
        });
        
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(x, 0.5, z);
        this.mesh.rotation.x = Math.PI / 2; // Lay flat
        scene.add(this.mesh);
        this.active = true;
        this.rotSpeed = Math.random() * 0.1 + 0.05;
        this.bobPhase = Math.random() * Math.PI * 2;
        this.sparklePhase = Math.random() * Math.PI * 2;
      }

      update(playerPos) {
        if (!this.active) return;

        // Spin on Z axis (since it's rotated to lay flat)
        this.mesh.rotation.z += this.rotSpeed;
        
        // Bob up and down
        this.bobPhase += 0.05;
        this.mesh.position.y = 0.5 + Math.sin(this.bobPhase) * 0.1;
        
        // Sparkle effect
        this.sparklePhase += 0.1;
        this.mesh.material.emissiveIntensity = 0.3 + Math.sin(this.sparklePhase) * 0.2;

        // Magnet
        const dx = playerPos.x - this.mesh.position.x;
        const dz = playerPos.z - this.mesh.position.z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        
        if (dist < magnetRange) { // Use magnetRange variable
          this.mesh.position.x += (dx / dist) * 0.3;
          this.mesh.position.z += (dz / dist) * 0.3;
          
          // Visual Trail when pulled - water particles with sparkle
          if (Math.random() < 0.3) {
             spawnParticles(this.mesh.position, COLORS.exp, 1);
          }
        }

        if (dist < 0.8) { // Collect
          this.collect();
        }
      }

      collect() {
        this.active = false;
        
        // SPLASH EFFECT when collected - more intense with stars
        const splashPos = this.mesh.position.clone();
        const SPLASH_PARTICLE_COUNT = 20;
        
        // Star-shaped splash particles
        for(let i=0; i<SPLASH_PARTICLE_COUNT; i++) {
          const angle = (i / SPLASH_PARTICLE_COUNT) * Math.PI * 2;
          const speed = 0.15 + Math.random() * 0.2;
          const particle = new THREE.Mesh(
            new THREE.SphereGeometry(0.08, 8, 8),
            new THREE.MeshBasicMaterial({ 
              color: COLORS.exp, 
              transparent: true, 
              opacity: 0.9
            })
          );
          particle.position.copy(splashPos);
          scene.add(particle);
          
          const vel = new THREE.Vector3(
            Math.cos(angle) * speed,
            0.2 + Math.random() * 0.15,
            Math.sin(angle) * speed
          );
          
          let life = 30;
          const updateParticle = () => {
            life--;
            particle.position.add(vel);
            vel.y -= 0.02; // Gravity
            particle.material.opacity = life / 30;
            
            if (life <= 0 || particle.position.y < 0.05) {
              scene.remove(particle);
              particle.geometry.dispose();
              particle.material.dispose();
            } else {
              requestAnimationFrame(updateParticle);
            }
          };
          updateParticle();
        }
        
        // Screen flash effect
        const flash = document.createElement('div');
        flash.style.position = 'fixed';
        flash.style.top = '0';
        flash.style.left = '0';
        flash.style.width = '100%';
        flash.style.height = '100%';
        flash.style.background = 'rgba(93, 173, 226, 0.3)';
        flash.style.pointerEvents = 'none';
        flash.style.zIndex = '500';
        document.body.appendChild(flash);
        setTimeout(() => flash.remove(), 100);
        
        scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        
        addExp(GAME_CONFIG.expValue);
        playSound('collect');
      }
    }

    class GoldCoin {
      constructor(x, z, amount) {
        const geometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 8);
        const material = new THREE.MeshBasicMaterial({ 
          color: 0xFFD700,
          transparent: true,
          opacity: 0.95
        });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(x, 0.3, z);
        this.mesh.rotation.x = Math.PI / 2;
        scene.add(this.mesh);
        
        this.active = true;
        this.amount = amount;
        this.magnetRange = 4;
        this.collectRange = 0.8;
        this.vx = 0;
        this.vz = 0;
        this.wobblePhase = Math.random() * Math.PI * 2;
        this.bounceTime = 0;
        
        // Play gold drop sound
        playSound('coinDrop');
        
        // Spawn 8 sparkles on creation
        spawnParticles(this.mesh.position, 0xFFD700, 8);
        spawnParticles(this.mesh.position, 0xFFFFFF, 2);
      }
      
      update(playerPos) {
        if (!this.active) return;
        
        // Spinning
        this.mesh.rotation.y += 0.15;
        
        // Bounce physics on spawn
        if (this.bounceTime < 1) {
          this.mesh.position.y = 0.3 + Math.abs(Math.sin(this.bounceTime * Math.PI * 3)) * 0.5 * (1 - this.bounceTime);
          this.bounceTime += 0.02;
        } else {
          // Wobble after bounce
          this.wobblePhase += 0.1;
          this.mesh.position.y = 0.3 + Math.sin(this.wobblePhase) * 0.1;
        }
        
        // NO MAGNET - player must walk over gold to collect it
        const dx = playerPos.x - this.mesh.position.x;
        const dz = playerPos.z - this.mesh.position.z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        
        // Collect ONLY when player is very close
        if (dist < this.collectRange) {
          addGold(this.amount);
          playSound('coin');
          
          // Gold collect particles - 20 sparkles + flash
          spawnParticles(this.mesh.position, 0xFFD700, 15);
          spawnParticles(this.mesh.position, 0xFFFFFF, 5); // White flash sparkles
          
          // Flash effect - bright point light
          const flashLight = new THREE.PointLight(0xFFD700, 4, 8);
          flashLight.position.copy(this.mesh.position);
          flashLight.position.y += 1;
          scene.add(flashLight);
          flashLights.push(flashLight);
          const timeoutId = setTimeout(() => {
            scene.remove(flashLight);
            const idx = flashLights.indexOf(flashLight);
            if (idx > -1) flashLights.splice(idx, 1);
            const tidx = activeTimeouts.indexOf(timeoutId);
            if (tidx > -1) activeTimeouts.splice(tidx, 1);
          }, 100);
          activeTimeouts.push(timeoutId);
          
          this.destroy();
        }
      }
      
      destroy() {
        this.active = false;
        scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
      }
    }

    // --- NOTIFICATION/INBOX SYSTEM ---
    const notifications = [];
    const inventory = [];
    const RARITY = {
      COMMON: { name: 'Common', color: 0xAAAAAA, multiplier: 1.0 },
      RARE: { name: 'Rare', color: 0x5DADE2, multiplier: 1.25 },
      EPIC: { name: 'Epic', color: 0x9B59B6, multiplier: 1.5 },
      LEGENDARY: { name: 'Legendary', color: 0xF39C12, multiplier: 2.0 },
      MYTHIC: { name: 'Mythic', color: 0xE74C3C, multiplier: 3.0 }
    };

    // --- SAVE SYSTEM ---
    const SAVE_KEY = 'waterDropSurvivorSave';

    const defaultSaveData = {
      gold: 0,
      totalGoldEarned: 0,
      totalRuns: 0,
      bestTime: 0,
      bestKills: 0,
      upgrades: {
        maxHp: 0,
        hpRegen: 0,
        moveSpeed: 0,
        attackDamage: 0,
        attackSpeed: 0,
        critChance: 0,
        critDamage: 0,
        armor: 0,
        cooldownReduction: 0,
        goldEarned: 0,
        expEarned: 0,
        maxWeapons: 0
      },
      achievements: []
    };

    let saveData = { ...defaultSaveData };

    function loadSaveData() {
      try {
        const saved = localStorage.getItem(SAVE_KEY);
        if (saved) {
          saveData = JSON.parse(saved);
          // Ensure all fields exist
          saveData.upgrades = { ...defaultSaveData.upgrades, ...saveData.upgrades };
        }
      } catch (e) {
        console.error('Failed to load save data:', e);
        saveData = { ...defaultSaveData };
      }
    }

    function saveSaveData() {
      try {
        localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
      } catch (e) {
        console.error('Failed to save data:', e);
      }
    }

    // --- ACHIEVEMENTS SYSTEM ---
    const ACHIEVEMENTS = {
      kills10: { id: 'kills10', name: 'First Blood', desc: 'Kill 10 enemies', reward: 25, check: () => playerStats.kills >= 10, claimed: false },
      kills50: { id: 'kills50', name: 'Killer Instinct', desc: 'Kill 50 enemies', reward: 50, check: () => playerStats.kills >= 50, claimed: false },
      kills100: { id: 'kills100', name: 'Century Slayer', desc: 'Kill 100 enemies', reward: 100, check: () => playerStats.kills >= 100, claimed: false },
      kills500: { id: 'kills500', name: 'Mass Destroyer', desc: 'Kill 500 enemies', reward: 250, check: () => playerStats.kills >= 500, claimed: false },
      kills1000: { id: 'kills1000', name: 'Legendary Warrior', desc: 'Kill 1000 enemies', reward: 500, check: () => playerStats.kills >= 1000, claimed: false },
      
      gold100: { id: 'gold100', name: 'Small Fortune', desc: 'Collect 100 gold in one run', reward: 50, check: () => playerStats.gold >= 100, claimed: false },
      gold500: { id: 'gold500', name: 'Treasure Hunter', desc: 'Collect 500 gold in one run', reward: 150, check: () => playerStats.gold >= 500, claimed: false },
      gold1000: { id: 'gold1000', name: 'Gold Baron', desc: 'Collect 1000 gold in one run', reward: 300, check: () => playerStats.gold >= 1000, claimed: false },
      
      dasher: { id: 'dasher', name: 'Dash Master', desc: 'Perform 50 dashes in one run', reward: 100, check: () => playerStats.dashesPerformed >= 50, claimed: false },
      survivor: { id: 'survivor', name: 'Time Warrior', desc: 'Survive for 10 minutes', reward: 200, check: () => playerStats.survivalTime >= 600, claimed: false },
      weaponMaster: { id: 'weaponMaster', name: 'Weapon Master', desc: 'Unlock all 3 weapons', reward: 150, check: () => playerStats.weaponsUnlocked >= 3, claimed: false },
      untouchable: { id: 'untouchable', name: 'Untouchable', desc: 'Take no damage for 3 minutes', reward: 300, check: () => playerStats.survivalTime >= 180 && playerStats.damageTaken === 0, claimed: false },
      
      level10: { id: 'level10', name: 'Rising Star', desc: 'Reach Level 10', reward: 100, check: () => playerStats.lvl >= 10, claimed: false },
      level25: { id: 'level25', name: 'Experienced Fighter', desc: 'Reach Level 25', reward: 250, check: () => playerStats.lvl >= 25, claimed: false },
      level50: { id: 'level50', name: 'Master Champion', desc: 'Reach Level 50', reward: 500, check: () => playerStats.lvl >= 50, claimed: false }
    };

    function updateAchievementsScreen() {
      const content = document.getElementById('achievements-content');
      if (!content) return;
      
      let html = '<div style="display: grid; gap: 15px; width: 100%; max-width: 600px; margin: 0 auto;">';
      
      let unclaimedCount = 0;
      for (const key in ACHIEVEMENTS) {
        const achievement = ACHIEVEMENTS[key];
        const isClaimed = saveData.achievements && saveData.achievements.includes(achievement.id);
        const canClaim = !isClaimed && achievement.check();
        
        if (canClaim) unclaimedCount++;
        
        html += `
          <div style="
            background: linear-gradient(to bottom, ${isClaimed ? '#2c5530' : (canClaim ? '#4a4a2a' : '#3a3a3a')}, ${isClaimed ? '#1a3020' : (canClaim ? '#3a3a1a' : '#2a2a2a')});
            border: 3px solid ${isClaimed ? '#FFD700' : (canClaim ? '#FFFF00' : '#5a5a5a')};
            border-radius: 15px;
            padding: 15px;
            text-align: left;
            position: relative;
            cursor: ${canClaim ? 'pointer' : 'default'};
            transition: all 0.2s ease;
            ${canClaim ? 'box-shadow: 0 0 15px rgba(255, 255, 0, 0.5);' : ''}
          " ${canClaim ? `onclick="claimAchievement('${achievement.id}')"` : ''}>
            <div style="color: ${isClaimed ? '#FFD700' : (canClaim ? '#FFFF00' : '#bbb')}; font-size: 20px; font-weight: bold; margin-bottom: 5px;">
              ${isClaimed ? '✓ ' : ''}${achievement.name}
            </div>
            <div style="color: ${isClaimed ? '#90ee90' : (canClaim ? '#dddd00' : '#888')}; font-size: 14px; margin-bottom: 8px;">
              ${achievement.desc}
            </div>
            <div style="color: #FFD700; font-size: 16px; font-weight: bold;">
              Reward: ${achievement.reward} Gold ${canClaim ? '- CLICK TO CLAIM!' : ''}
            </div>
          </div>
        `;
      }
      
      html += '</div>';
      content.innerHTML = html;
      
      // Update notification badge on achievements button
      updateAchievementBadge(unclaimedCount);
    }

    function updateAchievementBadge(count) {
      let badge = document.getElementById('achievement-badge');
      if (count > 0) {
        if (!badge) {
          badge = document.createElement('div');
          badge.id = 'achievement-badge';
          badge.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: #FF0000;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
            z-index: 100;
          `;
          document.getElementById('achievements-btn').appendChild(badge);
        }
        badge.textContent = count;
      } else if (badge) {
        badge.remove();
      }
    }

    function claimAchievement(achievementId) {
      const achievement = Object.values(ACHIEVEMENTS).find(a => a.id === achievementId);
      if (!achievement) return;
      
      const isClaimed = saveData.achievements && saveData.achievements.includes(achievement.id);
      const canClaim = !isClaimed && achievement.check();
      
      if (!canClaim) return;
      
      // Mark as claimed
      if (!saveData.achievements) saveData.achievements = [];
      saveData.achievements.push(achievement.id);
      
      // Award gold
      addGold(achievement.reward);
      
      // Play sound
      playSound('coin');
      
      // Show gold bag animation
      showGoldBagAnimation(achievement.reward);
      
      // Save
      saveSaveData();
      
      // Refresh screen
      updateAchievementsScreen();
    }

    function showGoldBagAnimation(amount) {
      const bag = document.createElement('div');
      bag.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 64px;
        z-index: 10000;
        pointer-events: none;
        animation: goldBagPop 1s ease-out forwards;
      `;
      bag.textContent = '💰';
      document.body.appendChild(bag);
      
      const text = document.createElement('div');
      text.style.cssText = `
        position: fixed;
        top: 55%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 32px;
        font-weight: bold;
        color: #FFD700;
        text-shadow: 0 0 10px rgba(255, 215, 0, 0.8), -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000;
        z-index: 10000;
        pointer-events: none;
        animation: goldTextFloat 1s ease-out forwards;
      `;
      text.textContent = `+${amount} GOLD!`;
      document.body.appendChild(text);
      
      setTimeout(() => {
        bag.remove();
        text.remove();
      }, 1000);
    }

    function checkAchievements() {
      // This function just checks if achievements are unlocked (not auto-claiming)
      // Players must click to claim in the achievements menu
      let hasNewAchievement = false;
      
      for (const key in ACHIEVEMENTS) {
        const achievement = ACHIEVEMENTS[key];
        
        // Skip if already claimed
        if (saveData.achievements && saveData.achievements.includes(achievement.id)) {
          continue;
        }
        
        // Check if achieved - mark internally but don't auto-claim
        if (achievement.check()) {
          hasNewAchievement = true;
          
          // Show notification that achievement is available
          if (!achievement.notified) {
            achievement.notified = true;
            createFloatingText(`NEW ACHIEVEMENT UNLOCKED!`, player.mesh.position);
            createFloatingText(`Check Achievements Menu`, player.mesh.position);
            playSound('levelup');
          }
        }
      }
      
      // Update achievement badge
      if (hasNewAchievement) {
        updateAchievementsScreen();
      }
    }

    // Upgrade definitions for the progression shop
    const PERMANENT_UPGRADES = {
      maxHp: {
        name: 'Max HP',
        description: '+10 HP per level',
        maxLevel: 20,
        baseCost: 50,
        costIncrease: 25,
        effect: (level) => 10 * level
      },
      hpRegen: {
        name: 'HP Regen',
        description: '+0.5 HP/sec per level',
        maxLevel: 10,
        baseCost: 100,
        costIncrease: 50,
        effect: (level) => 0.5 * level
      },
      moveSpeed: {
        name: 'Move Speed',
        description: '+5% per level',
        maxLevel: 10,
        baseCost: 75,
        costIncrease: 25,
        effect: (level) => 0.05 * level
      },
      attackDamage: {
        name: 'Attack Damage',
        description: '+10% per level',
        maxLevel: 15,
        baseCost: 100,
        costIncrease: 50,
        effect: (level) => 0.1 * level
      },
      attackSpeed: {
        name: 'Attack Speed',
        description: '+5% per level',
        maxLevel: 10,
        baseCost: 100,
        costIncrease: 50,
        effect: (level) => 0.05 * level
      },
      critChance: {
        name: 'Crit Chance',
        description: '+2% per level',
        maxLevel: 10,
        baseCost: 150,
        costIncrease: 50,
        effect: (level) => 0.02 * level
      },
      critDamage: {
        name: 'Crit Damage',
        description: '+10% per level',
        maxLevel: 10,
        baseCost: 150,
        costIncrease: 50,
        effect: (level) => 0.1 * level
      },
      armor: {
        name: 'Armor',
        description: '+2 per level',
        maxLevel: 15,
        baseCost: 100,
        costIncrease: 50,
        effect: (level) => 2 * level
      },
      cooldownReduction: {
        name: 'Cooldown Reduction',
        description: '-3% per level',
        maxLevel: 10,
        baseCost: 200,
        costIncrease: 50,
        effect: (level) => 0.03 * level
      },
      goldEarned: {
        name: 'Gold Earned',
        description: '+10% per level',
        maxLevel: 10,
        baseCost: 300,
        costIncrease: 100,
        effect: (level) => 0.1 * level
      },
      expEarned: {
        name: 'EXP Earned',
        description: '+10% per level',
        maxLevel: 10,
        baseCost: 250,
        costIncrease: 100,
        effect: (level) => 0.1 * level
      },
      maxWeapons: {
        name: 'Max Weapons',
        description: '+1 weapon slot',
        maxLevel: 3,
        baseCost: 500,
        costIncrease: 500,
        effect: (level) => level
      }
    };

    function getCost(upgradeKey) {
      const upgrade = PERMANENT_UPGRADES[upgradeKey];
      const currentLevel = saveData.upgrades[upgradeKey];
      return upgrade.baseCost + (currentLevel * upgrade.costIncrease);
    }

    // --- WORLD GENERATION ---
    function createWorld() {
      // Ground - EXPANDED MAP
      const groundGeo = new THREE.PlaneGeometry(400, 400); // Expanded from 200x200 to 400x400
      const groundMat = new THREE.MeshToonMaterial({ color: COLORS.ground });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Features
      // NOTE: Old lake removed - using enhanced reflective lake defined later (line ~3747)
      
      // Add water ripple effect
      const rippleGeo = new THREE.RingGeometry(14, 15, 32);
      const rippleMat = new THREE.MeshBasicMaterial({ color: 0x3399FF, transparent: true, opacity: 0.5 });
      const ripple = new THREE.Mesh(rippleGeo, rippleMat);
      ripple.rotation.x = -Math.PI / 2;
      ripple.position.set(30, 0.02, -30);
      ripple.userData = { isWaterRipple: true, phase: 0 };
      scene.add(ripple);

      // Smooth nice roads connecting areas
      const roadMat = new THREE.MeshPhysicalMaterial({ 
        color: 0xD3D3D3, // Light gray - smooth and polished
        metalness: 0.05,
        roughness: 0.3,
        clearcoat: 0.8, // Makes it look polished
        clearcoatRoughness: 0.2
      });
      const roadGeo = new THREE.PlaneGeometry(4, 4);
      
      // Road to windmill - smooth curved path
      for(let i=0; i<30; i++) {
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI/2;
        const t = i / 30;
        const x = t * 40;
        const z = t * 40;
        road.position.set(x, 0.03, z);
        road.receiveShadow = true;
        scene.add(road);
      }
      
      // Circular path around center - smooth ring road
      for(let i=0; i<50; i++) {
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI/2;
        const angle = (i / 50) * Math.PI * 2;
        const x = Math.cos(angle) * 25;
        const z = Math.sin(angle) * 25;
        road.position.set(x, 0.03, z);
        road.receiveShadow = true;
        scene.add(road);
      }
      
      // Additional main roads (cross pattern)
      for(let i=-20; i<20; i++) {
        // Horizontal road
        const road1 = new THREE.Mesh(roadGeo, roadMat);
        road1.rotation.x = -Math.PI/2;
        road1.position.set(i * 2, 0.03, 0);
        road1.receiveShadow = true;
        scene.add(road1);
        
        // Vertical road
        const road2 = new THREE.Mesh(roadGeo, roadMat);
        road2.rotation.x = -Math.PI/2;
        road2.position.set(0, 0.03, i * 2);
        road2.receiveShadow = true;
        scene.add(road2);
      }

      // Wooden fences around play area
      const fenceMat = new THREE.MeshToonMaterial({ color: 0x8B4513 });
      const postGeo = new THREE.BoxGeometry(0.3, 2, 0.3);
      const railGeo = new THREE.BoxGeometry(4, 0.2, 0.2);
      
      // Create fence segments around perimeter
      for(let i=0; i<40; i++) {
        const angle = (i / 40) * Math.PI * 2;
        const x = Math.cos(angle) * 85;
        const z = Math.sin(angle) * 85;
        
        // Fence post
        const post = new THREE.Mesh(postGeo, fenceMat);
        post.position.set(x, 1, z);
        post.castShadow = true;
        scene.add(post);
        
        // Fence rail
        if (i % 2 === 0) {
          const rail = new THREE.Mesh(railGeo, fenceMat);
          rail.position.set(x, 1, z);
          rail.rotation.y = angle;
          scene.add(rail);
        }
      }

      // Cabin (Box)
      const cabinGeo = new THREE.BoxGeometry(6, 5, 6);
      const cabinMat = new THREE.MeshToonMaterial({ color: COLORS.cabin });
      const cabin = new THREE.Mesh(cabinGeo, cabinMat);
      cabin.position.set(-20, 2.5, -20);
      cabin.castShadow = true;
      scene.add(cabin);

      // Windmill with improvements
      const wmGroup = new THREE.Group();
      wmGroup.position.set(40, 0, 40);
      const wmBase = new THREE.Mesh(new THREE.CylinderGeometry(2, 3, 8, 8), new THREE.MeshToonMaterial({color: 0xD2B48C})); // Beige
      wmBase.position.y = 4;
      wmGroup.add(wmBase);
      
      // Add door to windmill
      const wmDoor = new THREE.Mesh(
        new THREE.BoxGeometry(1.5, 3, 0.3),
        new THREE.MeshToonMaterial({color: 0x3a2a1a})
      );
      wmDoor.position.set(0, 1.5, 2.8);
      wmGroup.add(wmDoor);
      
      // Add light on windmill (glowing sphere)
      const wmLight = new THREE.Mesh(
        new THREE.SphereGeometry(0.3, 16, 16),
        new THREE.MeshBasicMaterial({color: 0xFFFF00})
      );
      wmLight.position.set(0, 9, 0);
      wmGroup.add(wmLight);
      
      // Add ground light circle
      const groundLightGeo = new THREE.CircleGeometry(5, 32);
      const groundLightMat = new THREE.MeshBasicMaterial({
        color: 0xFFFFAA,
        transparent: true,
        opacity: 0.2
      });
      const groundLight = new THREE.Mesh(groundLightGeo, groundLightMat);
      groundLight.rotation.x = -Math.PI/2;
      groundLight.position.set(40, 0.05, 40);
      scene.add(groundLight);
      
      const wmBlades = new THREE.Mesh(new THREE.BoxGeometry(12, 1, 1), new THREE.MeshBasicMaterial({color: 0x8B4513})); // Brown
      wmBlades.position.set(0, 7, 2);
      wmGroup.add(wmBlades);
      const wmBlades2 = wmBlades.clone();
      wmBlades2.rotation.z = Math.PI/2;
      wmGroup.add(wmBlades2);
      // Store blades reference for rotation animation
      wmGroup.userData = { isWindmill: true, blades: [wmBlades, wmBlades2], hp: 600, maxHp: 600, questActive: false, light: wmLight };
      scene.add(wmGroup);
      
      // Mine
      const mineGeo = new THREE.DodecahedronGeometry(5);
      const mineMat = new THREE.MeshToonMaterial({ color: 0x555555 });
      const mine = new THREE.Mesh(mineGeo, mineMat);
      mine.position.set(-40, 2, 40);
      scene.add(mine);
      const mineEnt = new THREE.Mesh(new THREE.CircleGeometry(2, 16), new THREE.MeshBasicMaterial({color: 0x000000}));
      mineEnt.position.set(-40, 2, 44);
      mineEnt.rotation.y = Math.PI;
      scene.add(mineEnt);

      // Stonehenge - Circle of big rocks - MADE MORE VISIBLE
      const stonehengeGroup = new THREE.Group();
      stonehengeGroup.position.set(-60, 0, -20);
      
      const stoneMat = new THREE.MeshToonMaterial({ color: 0x808080 }); // Gray stone
      const numStones = 30; // Real Stonehenge has ~30 stones in outer circle
      const stoneRadius = 15; // Larger circle for more realistic proportions
      
      for(let i=0; i<numStones; i++) {
        const angle = (i / numStones) * Math.PI * 2;
        const x = Math.cos(angle) * stoneRadius;
        const z = Math.sin(angle) * stoneRadius;
        
        // Vertical standing stone - realistic proportions (approx 1.5m wide × 5m tall × 1m thick)
        const stoneGeo = new THREE.BoxGeometry(1.5, 5, 1); 
        const stone = new THREE.Mesh(stoneGeo, stoneMat);
        stone.position.set(x, 2.5, z);
        stone.rotation.y = angle + Math.PI/2; // Face center
        stone.castShadow = true;
        stonehengeGroup.add(stone);
        
        // Horizontal cap stone on top (placed on every 6th stone pair for sparse distribution)
        if (i % 6 === 0 && i < 24) { // Places 4 caps total (at indices 0, 6, 12, 18)
          const nextAngle = ((i + 1) / numStones) * Math.PI * 2;
          const nextX = Math.cos(nextAngle) * stoneRadius;
          const nextZ = Math.sin(nextAngle) * stoneRadius;
          
          const capGeo = new THREE.BoxGeometry(3, 0.8, 1);
          const cap = new THREE.Mesh(capGeo, stoneMat);
          cap.position.set((x + nextX)/2, 5.4, (z + nextZ)/2);
          cap.rotation.y = angle + Math.PI/2;
          cap.castShadow = true;
          stonehengeGroup.add(cap);
        }
      }
      
      // Central altar stone removed - was appearing as visual artifact
      
      scene.add(stonehengeGroup);

      // Mayan Pyramid - Stepped pyramid - MADE MORE VISIBLE
      const mayanGroup = new THREE.Group();
      mayanGroup.position.set(50, 0, -50);
      
      const pyramidMat = new THREE.MeshToonMaterial({ color: 0xD2B48C }); // Tan/beige like ancient stone
      const pyramidSteps = 6; // Increased from 5
      
      for(let i=0; i<pyramidSteps; i++) {
        const stepSize = 14 - i * 2; // Increased from (10 - i * 1.5)
        const stepHeight = 2.5; // Increased from 2
        const stepGeo = new THREE.BoxGeometry(stepSize, stepHeight, stepSize);
        const step = new THREE.Mesh(stepGeo, pyramidMat);
        step.position.set(0, i * stepHeight + stepHeight/2, 0);
        step.castShadow = true;
        mayanGroup.add(step);
      }
      
      // Temple on top - MADE LARGER
      const templeGeo = new THREE.BoxGeometry(4, 4, 4); // Increased from (3, 3, 3)
      const templeMat = new THREE.MeshToonMaterial({ color: 0x8B7355 }); // Darker brown
      const temple = new THREE.Mesh(templeGeo, templeMat);
      temple.position.set(0, pyramidSteps * 2.5 + 2, 0); // Adjusted for new step height
      temple.castShadow = true;
      mayanGroup.add(temple);
      
      // Add some decorative blocks on sides - MADE LARGER
      for(let side=0; side<4; side++) {
        const angle = (side / 4) * Math.PI * 2;
        const decorGeo = new THREE.BoxGeometry(0.8, 1.5, 0.8); // Increased from (0.5, 1, 0.5)
        const decor = new THREE.Mesh(decorGeo, new THREE.MeshToonMaterial({ color: 0xFFD700 })); // Gold
        const decorDist = 2.5; // Increased from 2
        decor.position.set(
          Math.cos(angle) * decorDist,
          pyramidSteps * 2.5 + 2.5,
          Math.sin(angle) * decorDist
        );
        decor.castShadow = true;
        mayanGroup.add(decor);
      }
      
      scene.add(mayanGroup);

      // Water Statue in Center - Replace brown square
      const statueGroup = new THREE.Group();
      statueGroup.position.set(0, 0, 0); // Center of map
      
      // Pedestal
      const pedestalGeo = new THREE.CylinderGeometry(1.5, 2, 1.5, 8);
      const pedestalMat = new THREE.MeshToonMaterial({ color: 0xD3D3D3 }); // Light gray stone
      const pedestal = new THREE.Mesh(pedestalGeo, pedestalMat);
      pedestal.position.y = 0.75;
      pedestal.castShadow = true;
      statueGroup.add(pedestal);
      
      // Water droplet statue (large blue droplet)
      const statueGeo = new THREE.SphereGeometry(1, 16, 16);
      const statueMat = new THREE.MeshPhysicalMaterial({ 
        color: COLORS.player,
        metalness: 0.3,
        roughness: 0.2,
        clearcoat: 1,
        clearcoatRoughness: 0.1
      });
      const statue = new THREE.Mesh(statueGeo, statueMat);
      statue.position.y = 2.5;
      statue.scale.y = 1.3; // Elongate to droplet shape
      statue.castShadow = true;
      statueGroup.add(statue);
      
      scene.add(statueGroup);

      // Comet Stone - Beside the lake where player spawns (brings the water droplet to life)
      const cometGroup = new THREE.Group();
      cometGroup.position.set(37, 0, -30); // Right beside lake where player spawns
      
      // Impact crater (dark brown ring)
      const craterGeo = new THREE.RingGeometry(2, 3, 32);
      const craterMat = new THREE.MeshToonMaterial({ color: 0x3E2723 }); // Dark brown
      const crater = new THREE.Mesh(craterGeo, craterMat);
      crater.rotation.x = -Math.PI/2;
      crater.position.y = 0.02;
      cometGroup.add(crater);
      
      // Comet stone (dark metallic rock with glow)
      const cometGeo = new THREE.DodecahedronGeometry(1.2, 1);
      const cometMat = new THREE.MeshPhysicalMaterial({ 
        color: 0x1a1a1a, // Very dark gray, almost black
        metalness: 0.8,
        roughness: 0.3,
        emissive: 0x4FC3F7, // Blue glow
        emissiveIntensity: 0.3
      });
      const cometStone = new THREE.Mesh(cometGeo, cometMat);
      cometStone.position.y = 0.6;
      cometStone.castShadow = true;
      // Slight tilt for dramatic effect
      cometStone.rotation.x = 0.2;
      cometStone.rotation.z = 0.3;
      cometGroup.add(cometStone);
      
      // Glowing particles around comet stone
      for(let i=0; i<8; i++) {
        const particleGeo = new THREE.SphereGeometry(0.1, 8, 8);
        const particleMat = new THREE.MeshBasicMaterial({ 
          color: 0x4FC3F7,
          transparent: true,
          opacity: 0.6
        });
        const particle = new THREE.Mesh(particleGeo, particleMat);
        const angle = (i / 8) * Math.PI * 2;
        particle.position.set(
          Math.cos(angle) * 1.5,
          0.6 + Math.random() * 0.5,
          Math.sin(angle) * 1.5
        );
        particle.userData = { 
          isCometParticle: true,
          angle: angle,
          radius: 1.5,
          speed: 0.5 + Math.random() * 0.5,
          height: particle.position.y
        };
        cometGroup.add(particle);
      }
      
      scene.add(cometGroup);

      // Farm Area near windmill
      const farmGroup = new THREE.Group();
      farmGroup.position.set(35, 0, 35); // Near windmill
      
      // Wheat field (50 stalks)
      const wheatGeo = new THREE.ConeGeometry(0.1, 0.8, 4);
      const wheatMat = new THREE.MeshToonMaterial({ color: 0xF4A460 }); // Sandy brown
      for(let i=0; i<50; i++) {
        const wheat = new THREE.Mesh(wheatGeo, wheatMat);
        wheat.position.set(
          (Math.random() - 0.5) * 8,
          0.4,
          (Math.random() - 0.5) * 8
        );
        wheat.rotation.z = (Math.random() - 0.5) * 0.2;
        farmGroup.add(wheat);
      }
      
      // Barn (8x6x10)
      const barnGeo = new THREE.BoxGeometry(8, 6, 10);
      const barnMat = new THREE.MeshToonMaterial({ color: 0x8B0000 }); // Dark red
      const barn = new THREE.Mesh(barnGeo, barnMat);
      barn.position.set(12, 3, 0);
      barn.castShadow = true;
      farmGroup.add(barn);
      
      // Barn roof
      const roofGeo = new THREE.ConeGeometry(7, 3, 4);
      const roofMat = new THREE.MeshToonMaterial({ color: 0x654321 }); // Brown
      const roof = new THREE.Mesh(roofGeo, roofMat);
      roof.position.set(12, 7.5, 0);
      roof.rotation.y = Math.PI/4;
      farmGroup.add(roof);
      
      // Tractor with wheels
      const tractorBody = new THREE.Mesh(
        new THREE.BoxGeometry(2, 1.5, 3),
        new THREE.MeshToonMaterial({ color: 0x228B22 }) // Forest green
      );
      tractorBody.position.set(-8, 0.75, 0);
      farmGroup.add(tractorBody);
      
      // Tractor wheels (4 wheels)
      const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 8);
      const wheelMat = new THREE.MeshToonMaterial({ color: 0x333333 });
      const wheelPositions = [
        [-8.8, 0.5, 1.2], [-8.8, 0.5, -1.2],
        [-7.2, 0.5, 1.2], [-7.2, 0.5, -1.2]
      ];
      wheelPositions.forEach(pos => {
        const wheel = new THREE.Mesh(wheelGeo, wheelMat);
        wheel.position.set(...pos);
        wheel.rotation.z = Math.PI/2;
        farmGroup.add(wheel);
      });
      
      scene.add(farmGroup);

      // Crystal Tower - 6 floating crystals with animation
      const crystalGroup = new THREE.Group();
      crystalGroup.position.set(-50, 0, 0);
      
      const crystalGeo = new THREE.OctahedronGeometry(1);
      for(let i=0; i<6; i++) {
        const crystalMat = new THREE.MeshPhysicalMaterial({
          color: 0x9B59B6, // Purple
          metalness: 0.5,
          roughness: 0.1,
          emissive: 0x9B59B6,
          emissiveIntensity: 0.3,
          transparent: true,
          opacity: 0.9
        });
        const crystal = new THREE.Mesh(crystalGeo, crystalMat);
        const angle = (i / 6) * Math.PI * 2;
        crystal.position.set(
          Math.cos(angle) * 5,
          3 + i * 1.5,
          Math.sin(angle) * 5
        );
        crystal.rotation.x = Math.random() * Math.PI;
        crystal.rotation.y = Math.random() * Math.PI;
        crystal.userData = { 
          isCrystal: true, 
          phase: i * Math.PI / 3,
          orbitSpeed: 0.5 + Math.random() * 0.5
        };
        crystal.castShadow = true;
        crystalGroup.add(crystal);
      }
      
      scene.add(crystalGroup);

      // Enhanced Waterfall - 3-tier cliffs with water drops and mist
      const waterfallGroup = new THREE.Group();
      waterfallGroup.position.set(20, 0, -50);
      
      // 3-tier cliffs
      const cliffMat = new THREE.MeshToonMaterial({ color: 0x708090 }); // Slate gray
      for(let tier=0; tier<3; tier++) {
        const cliffGeo = new THREE.BoxGeometry(10, 3, 2);
        const cliff = new THREE.Mesh(cliffGeo, cliffMat);
        cliff.position.set(0, tier * 3 + 1.5, tier * 2);
        cliff.castShadow = true;
        waterfallGroup.add(cliff);
        
        // Water flow (blue plane)
        const waterGeo = new THREE.PlaneGeometry(8, 3);
        const waterMat = new THREE.MeshBasicMaterial({ 
          color: COLORS.lake,
          transparent: true,
          opacity: 0.6
        });
        const water = new THREE.Mesh(waterGeo, waterMat);
        water.position.set(0, tier * 3 + 1.5, tier * 2 + 1.1);
        water.userData = { isWaterfall: true, tier: tier };
        waterfallGroup.add(water);
      }
      
      scene.add(waterfallGroup);

      // Reflective Lake - Enhanced with realistic water properties
      const enhancedLakeGeo = new THREE.CircleGeometry(18, 32);
      const enhancedLakeMat = new THREE.MeshPhysicalMaterial({ 
        color: COLORS.lake,
        metalness: 0.3, // Reduced for more natural water look
        roughness: 0.2, // Slightly rougher for less distortion
        transparent: true,
        opacity: 0.85, // Slightly more transparent
        reflectivity: 0.8 // Reduced for more natural reflections
      });
      const enhancedLake = new THREE.Mesh(enhancedLakeGeo, enhancedLakeMat);
      enhancedLake.rotation.x = -Math.PI / 2;
      enhancedLake.position.set(30, 0.01, -30);
      scene.add(enhancedLake);
      
      // Sun sparkles on lake
      for(let i=0; i<10; i++) {
        const sparkleGeo = new THREE.CircleGeometry(0.3, 6);
        const sparkleMat = new THREE.MeshBasicMaterial({ 
          color: 0xFFFFFF,
          transparent: true,
          opacity: 0.8
        });
        const sparkle = new THREE.Mesh(sparkleGeo, sparkleMat);
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * 15;
        sparkle.position.set(
          30 + Math.cos(angle) * dist,
          0.02,
          -30 + Math.sin(angle) * dist
        );
        sparkle.rotation.x = -Math.PI/2;
        sparkle.userData = { 
          isSparkle: true,
          phase: Math.random() * Math.PI * 2,
          speed: 1 + Math.random() * 2
        };
        scene.add(sparkle);
      }

      // More fences around farm area
      for(let i=0; i<20; i++) {
        const angle = (i / 20) * Math.PI * 2;
        const x = 35 + Math.cos(angle) * 15;
        const z = 35 + Math.sin(angle) * 15;
        
        const post = new THREE.Mesh(postGeo, fenceMat);
        post.position.set(x, 1, z);
        post.castShadow = true;
        scene.add(post);
        
        if (i % 2 === 0) {
          const rail = new THREE.Mesh(railGeo, fenceMat);
          rail.position.set(x, 1, z);
          rail.rotation.y = angle;
          scene.add(rail);
        }
      }

      // Forest (Various tree types with better shadows)
      const trunkGeo = new THREE.CylinderGeometry(0.5, 0.7, 2, 6);
      const trunkMat = new THREE.MeshToonMaterial({ color: 0x8B4513 });
      const leavesGeo = new THREE.ConeGeometry(2.5, 5, 8);
      const treeMat = new THREE.MeshToonMaterial({ color: COLORS.forest });
      
      // Additional tree types
      const leavesGeo2 = new THREE.SphereGeometry(2, 8, 8); // Round tree
      const treeMat2 = new THREE.MeshToonMaterial({ color: 0x90EE90 }); // Light green
      const leavesGeo3 = new THREE.ConeGeometry(2, 6, 6); // Tall pine
      const treeMat3 = new THREE.MeshToonMaterial({ color: 0x228B22 }); // Forest green
      
      // Shadow circle under trees
      const shadowGeo = new THREE.CircleGeometry(2, 16);
      const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
      
      for (let i = 0; i < 120; i++) { // Increased from 50 to 120
        const group = new THREE.Group();
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 1;
        trunk.castShadow = true;
        
        // Randomly choose tree type
        const treeType = Math.floor(Math.random() * 3);
        let leaves;
        if (treeType === 0) {
          leaves = new THREE.Mesh(leavesGeo, treeMat);
          leaves.position.y = 4;
        } else if (treeType === 1) {
          leaves = new THREE.Mesh(leavesGeo2, treeMat2);
          leaves.position.y = 3.5;
        } else {
          leaves = new THREE.Mesh(leavesGeo3, treeMat3);
          leaves.position.y = 5;
        }
        leaves.castShadow = true;
        
        // Add shadow
        const shadow = new THREE.Mesh(shadowGeo, shadowMat);
        shadow.rotation.x = -Math.PI/2;
        shadow.position.y = 0.01;
        
        group.add(trunk);
        group.add(leaves);
        group.add(shadow);
        
        // Random pos in forest area and spread across map
        // Lake exclusion zone constants
        const LAKE_CENTER_X = 30;
        const LAKE_CENTER_Z = -30;
        const LAKE_EXCLUSION_RADIUS = 18; // Lake radius 15 + buffer 3
        const MAX_SPAWN_ATTEMPTS = 20;
        
        let tx, tz;
        let inLake = true;
        let attempts = 0;
        
        // Avoid spawning trees in lake area
        while (inLake && attempts < MAX_SPAWN_ATTEMPTS) {
          if (i < 80) {
            // First 80 trees in forest area (Top Left quadrant mostly)
            tx = (Math.random() * 100) - 90;
            tz = (Math.random() * 100) - 90;
          } else {
            // Remaining 40 trees spread across entire map
            tx = (Math.random() * 180) - 90;
            tz = (Math.random() * 180) - 90;
          }
          
          // Check if tree would be in lake
          const distToLake = Math.sqrt((tx - LAKE_CENTER_X) * (tx - LAKE_CENTER_X) + (tz - LAKE_CENTER_Z) * (tz - LAKE_CENTER_Z));
          inLake = distToLake < LAKE_EXCLUSION_RADIUS;
          attempts++;
        }
        
        // Only add tree if not in lake
        if (!inLake) {
          group.position.set(tx, 0, tz);
          scene.add(group);
        }
      }
      
      // Waterfall from cliff into lake
      const waterfallGroup2 = new THREE.Group();
      
      // Cliff/rock formation
      const cliffGeo2 = new THREE.BoxGeometry(8, 12, 6);
      const cliffMat2 = new THREE.MeshToonMaterial({ color: 0x696969 }); // Dark gray
      const cliff2 = new THREE.Mesh(cliffGeo2, cliffMat2);
      cliff2.position.set(30, 6, -45); // Above and behind the lake
      cliff2.castShadow = true;
      waterfallGroup2.add(cliff2);
      
      // Waterfall - multiple planes to simulate water flow
      const waterfallGeo = new THREE.PlaneGeometry(3, 12);
      const waterfallMat = new THREE.MeshBasicMaterial({ 
        color: 0x87CEEB, 
        transparent: true, 
        opacity: 0.6,
        side: THREE.DoubleSide
      });
      
      const waterfall = new THREE.Mesh(waterfallGeo, waterfallMat);
      waterfall.position.set(30, 6, -39);
      waterfall.rotation.x = -0.2; // Slight angle
      waterfall.userData = { isWaterfall: true, phase: 0 };
      waterfallGroup2.add(waterfall);
      
      // Add flowing water particles
      for(let i=0; i<5; i++) {
        const dropGeo = new THREE.SphereGeometry(0.3, 8, 8);
        const dropMat = new THREE.MeshBasicMaterial({ 
          color: 0x4ECDC4, 
          transparent: true, 
          opacity: 0.7 
        });
        const drop = new THREE.Mesh(dropGeo, dropMat);
        drop.position.set(30 + (Math.random()-0.5)*2, 12 - i*2, -39);
        drop.userData = { isWaterDrop: true, speed: 0.1 + Math.random()*0.1, startY: 12 - i*2 };
        waterfallGroup2.add(drop);
      }
      
      // Splash at bottom
      const splashGeo = new THREE.CircleGeometry(2, 16);
      const splashMat = new THREE.MeshBasicMaterial({ 
        color: 0xFFFFFF, 
        transparent: true, 
        opacity: 0.4 
      });
      const splash = new THREE.Mesh(splashGeo, splashMat);
      splash.rotation.x = -Math.PI/2;
      splash.position.set(30, 0.1, -33);
      splash.userData = { isSplash: true, phase: 0 };
      waterfallGroup2.add(splash);
      
      scene.add(waterfallGroup2);
      
      // Scatter flowers around environment
      const flowerGeo = new THREE.ConeGeometry(0.2, 0.5, 6);
      const flowerColors = [0xFF69B4, 0xFFFF00, 0xFF0000, 0xFFA500, 0xFFFFFF];
      
      for(let i=0; i<250; i++) {
        const flower = new THREE.Mesh(flowerGeo, new THREE.MeshBasicMaterial({ 
          color: flowerColors[Math.floor(Math.random() * flowerColors.length)] 
        }));
        flower.position.set(
          (Math.random() - 0.5) * 160,
          0.25,
          (Math.random() - 0.5) * 160
        );
        flower.rotation.x = -Math.PI/2;
        scene.add(flower);
      }
    }

    // --- GAME LOGIC ---

    function init() {
      // Load save data first
      loadSaveData();
      
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(COLORS.bg);
      // Fog for depth
      scene.fog = new THREE.Fog(COLORS.bg, 20, 60);

      // Camera (Orthographic for miniature look)
      const aspect = window.innerWidth / window.innerHeight;
      const d = 20;
      camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
      camera.position.set(20, 20, 20); // Isometric angle
      camera.lookAt(scene.position);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('game-container').appendChild(renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(50, 100, 50);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      dirLight.shadow.camera.left = -100;
      dirLight.shadow.camera.right = 100;
      dirLight.shadow.camera.top = 100;
      dirLight.shadow.camera.bottom = -100;
      scene.add(dirLight);

      // Setup
      createWorld();
      player = new Player();
      
      // Initialize background music
      updateBackgroundMusic();
      
      // Listeners
      setupInputs();
      setupMenus();
      window.addEventListener('resize', onWindowResize, false);
      
      // Show loading screen, then main menu
      showLoadingScreen();

      // Start Loop
      requestAnimationFrame(animate);
    }
    
    function showLoadingScreen() {
      const loadingScreen = document.getElementById('loading-screen');
      const loadingBar = document.getElementById('loading-bar');
      let progress = 0;
      
      // Extended loading duration: 20 iterations × 400ms = 8000ms (8 seconds total)
      const interval = setInterval(() => {
        progress += 5;
        loadingBar.style.width = progress + '%';
        
        if (progress >= 100) {
          clearInterval(interval);
          setTimeout(() => {
            loadingScreen.classList.add('fade-out');
            setTimeout(() => {
              loadingScreen.style.display = 'none';
              showMainMenu();
            }, 500);
          }, 600); // Extended delay before fade
        }
      }, 400); // Slower progress updates for longer duration
    }
    
    function showMainMenu() {
      document.getElementById('main-menu').style.display = 'flex';
      updateGoldDisplays();
      isGameActive = false;
      isPaused = true;
    }
    
    function hideMainMenu() {
      document.getElementById('main-menu').style.display = 'none';
    }
    
    function showProgressionShop() {
      const shopGrid = document.getElementById('shop-grid');
      shopGrid.innerHTML = '';
      
      // Create upgrade cards for each permanent upgrade
      Object.keys(PERMANENT_UPGRADES).forEach(key => {
        const upgrade = PERMANENT_UPGRADES[key];
        const currentLevel = saveData.upgrades[key];
        const isMaxLevel = currentLevel >= upgrade.maxLevel;
        const cost = getCost(key);
        const canAfford = saveData.gold >= cost;
        
        const card = document.createElement('div');
        card.className = 'upgrade-shop-card' + (isMaxLevel ? ' max-level' : '');
        
        const effectText = upgrade.description;
        
        card.innerHTML = `
          <div class="upgrade-shop-title">${upgrade.name}</div>
          <div class="upgrade-shop-desc">${effectText}</div>
          <div class="upgrade-shop-level">Level: ${currentLevel} / ${upgrade.maxLevel}</div>
          ${!isMaxLevel ? `
            <div class="upgrade-shop-cost">Cost: ${cost} Gold</div>
            <button class="upgrade-buy-btn" ${!canAfford ? 'disabled' : ''}>
              ${canAfford ? 'BUY' : 'NOT ENOUGH GOLD'}
            </button>
          ` : '<div class="upgrade-shop-cost" style="color: #27ae60;">MAX LEVEL</div>'}
        `;
        
        if (!isMaxLevel) {
          const btn = card.querySelector('.upgrade-buy-btn');
          btn.onclick = () => {
            playSound('levelup');
            buyUpgrade(key);
          };
        }
        
        shopGrid.appendChild(card);
      });
      
      document.getElementById('progression-shop').style.display = 'flex';
      updateGoldDisplays();
    }
    
    function buyUpgrade(upgradeKey) {
      const upgrade = PERMANENT_UPGRADES[upgradeKey];
      const currentLevel = saveData.upgrades[upgradeKey];
      const cost = getCost(upgradeKey);
      
      if (currentLevel >= upgrade.maxLevel) return;
      if (saveData.gold < cost) return;
      
      saveData.gold -= cost;
      saveData.upgrades[upgradeKey]++;
      saveSaveData();
      
      playSound('levelup');
      showProgressionShop(); // Refresh the shop
    }
    
    function setupMenus() {
      // Settings button
      document.getElementById('settings-btn').onclick = () => {
        playSound('levelup');
        isPaused = true;
        document.getElementById('settings-modal').style.display = 'flex';
      };
      
      document.getElementById('settings-close-btn').onclick = () => {
        playSound('levelup');
        isPaused = false;
        document.getElementById('settings-modal').style.display = 'none';
      };
      
      // Settings handlers
      document.getElementById('auto-aim-checkbox').onchange = (e) => {
        gameSettings.autoAim = e.target.checked;
      };
      
      document.getElementById('control-type-select').onchange = (e) => {
        gameSettings.controlType = e.target.value;
        // Clear joystick states when switching control types
        joystickLeft.active = false;
        joystickLeft.x = 0;
        joystickLeft.y = 0;
        joystickRight.active = false;
        joystickRight.x = 0;
        joystickRight.y = 0;
        // Clear keyboard state when switching control types
        gameSettings.keysPressed = {};
        updateControlType();
      };
      
      document.getElementById('sound-toggle').onchange = (e) => {
        gameSettings.soundEnabled = e.target.checked;
      };
      
      document.getElementById('music-toggle').onchange = (e) => {
        gameSettings.musicEnabled = e.target.checked;
        updateBackgroundMusic();
      };

      // Sync settings UI controls with current gameSettings state
      const autoAimCheckbox = document.getElementById('auto-aim-checkbox');
      if (autoAimCheckbox) {
        autoAimCheckbox.checked = !!gameSettings.autoAim;
      }

      const controlTypeSelect = document.getElementById('control-type-select');
      if (controlTypeSelect && typeof gameSettings.controlType === 'string') {
        controlTypeSelect.value = gameSettings.controlType;
      }

      const soundToggle = document.getElementById('sound-toggle');
      if (soundToggle) {
        soundToggle.checked = !!gameSettings.soundEnabled;
      }

      const musicToggle = document.getElementById('music-toggle');
      if (musicToggle) {
        musicToggle.checked = !!gameSettings.musicEnabled;
      }

      // Ensure game systems reflect the current settings
      updateControlType();
      updateBackgroundMusic();
      
      // Main Menu Buttons
      document.getElementById('start-game-btn').onclick = () => {
        playSound('levelup');
        hideMainMenu();
        resetGame();
      };
      
      document.getElementById('progression-btn').onclick = () => {
        playSound('levelup');
        hideMainMenu();
        showProgressionShop();
      };
      
      document.getElementById('achievements-btn').onclick = () => {
        playSound('levelup');
        hideMainMenu();
        updateAchievementsScreen();
        document.getElementById('achievements-screen').style.display = 'flex';
      };
      
      document.getElementById('credits-btn').onclick = () => {
        playSound('levelup');
        hideMainMenu();
        document.getElementById('credits-screen').style.display = 'flex';
      };
      
      // Back buttons
      document.getElementById('shop-back-btn').onclick = () => {
        playSound('levelup');
        document.getElementById('progression-shop').style.display = 'none';
        showMainMenu();
      };
      
      document.getElementById('achievements-back-btn').onclick = () => {
        playSound('levelup');
        document.getElementById('achievements-screen').style.display = 'none';
        showMainMenu();
      };
      
      document.getElementById('credits-back-btn').onclick = () => {
        playSound('levelup');
        document.getElementById('credits-screen').style.display = 'none';
        showMainMenu();
      };
      
      // Restart button now returns to menu
      document.getElementById('restart-btn').onclick = () => {
        playSound('levelup');
        document.getElementById('gameover-screen').style.display = 'none';
        showMainMenu();
      };
      
      // Initialize control type UI on startup
      updateControlType();
    }
    

    function spawnWave() {
      waveCount++;
      
      // Check if this is a mini-boss wave (levels 10, 15, 20, and every 5 levels after)
      const isMiniBossWave = playerStats.lvl >= 10 && playerStats.lvl % 5 === 0;
      
      if (isMiniBossWave) {
        // Spawn mini-boss with 2-3 regular enemies
        const angle = Math.random() * Math.PI * 2;
        const dist = 28;
        const ex = player.mesh.position.x + Math.cos(angle) * dist;
        const ez = player.mesh.position.z + Math.sin(angle) * dist;
        enemies.push(new Enemy(10, ex, ez, playerStats.lvl));
        createFloatingText("MINI-BOSS INCOMING!", player.mesh.position);
        
        // Spawn 2-3 regular enemies with the mini-boss
        const supportCount = 2 + Math.floor(Math.random() * 2);
        for (let i = 0; i < supportCount; i++) {
          const supportAngle = Math.random() * Math.PI * 2;
          const supportDist = 25 + Math.random() * 5;
          const supportX = player.mesh.position.x + Math.cos(supportAngle) * supportDist;
          const supportZ = player.mesh.position.z + Math.sin(supportAngle) * supportDist;
          const supportType = Math.floor(Math.random() * Math.min(3, Math.max(1, playerStats.lvl / 3)));
          enemies.push(new Enemy(supportType, supportX, supportZ, playerStats.lvl));
        }
        // Don't spawn additional regular wave enemies on mini-boss waves
        return;
      }
      
      // Scale spawn count with player level for increased difficulty - Rebalanced
      const baseCount = 3 + Math.floor(waveCount / 3); // Increased from 2
      const levelBonus = Math.floor(playerStats.lvl / 5); // Increased from /6
      const count = Math.min(baseCount + levelBonus, 15); // Cap at 15 enemies per wave
      
      for(let i=0; i<count; i++) {
        // Spawn at edge of camera view approx - avoid lake area
        let ex, ez, inLake;
        let attempts = 0;
        const MAX_ATTEMPTS = 10;
        
        do {
          const angle = Math.random() * Math.PI * 2;
          const dist = 25 + Math.random() * 10; // Just outside view
          ex = player.mesh.position.x + Math.cos(angle) * dist;
          ez = player.mesh.position.z + Math.sin(angle) * dist;
          
          // Check if spawn position is in lake
          const distToLake = Math.sqrt(
            (ex - GAME_CONFIG.lakeCenterX) * (ex - GAME_CONFIG.lakeCenterX) + 
            (ez - GAME_CONFIG.lakeCenterZ) * (ez - GAME_CONFIG.lakeCenterZ)
          );
          inLake = distToLake < GAME_CONFIG.lakeRadius + 5; // Add buffer
          attempts++;
        } while (inLake && attempts < MAX_ATTEMPTS);
        
        // Fallback: if still in lake after max attempts, push spawn further away from lake
        if (inLake) {
          const angleFromLake = Math.atan2(ez - GAME_CONFIG.lakeCenterZ, ex - GAME_CONFIG.lakeCenterX);
          ex = GAME_CONFIG.lakeCenterX + Math.cos(angleFromLake) * (GAME_CONFIG.lakeRadius + 10);
          ez = GAME_CONFIG.lakeCenterZ + Math.sin(angleFromLake) * (GAME_CONFIG.lakeRadius + 10);
        }
        
        // Random type - include new enemy types as level increases
        // 0: Tank, 1: Fast, 2: Balanced, 3: Slowing (lvl 8+), 4: Ranged (lvl 10+)
        // 5: Flying (lvl 8+), 6-9: Hard variants (lvl 12+)
        let maxType = 2; // Start with 3 base types
        if (playerStats.lvl >= 8) maxType = 5; // Add slowing (3), ranged placeholder, and flying (5)
        if (playerStats.lvl >= 10) maxType = 5; // Add ranged enemies (4)
        if (playerStats.lvl >= 12) maxType = 6; // Add hard tank
        if (playerStats.lvl >= 14) maxType = 7; // Add hard fast
        if (playerStats.lvl >= 16) maxType = 8; // Add hard balanced
        if (playerStats.lvl >= 18) maxType = 9; // Add elite
        
        let type = Math.floor(Math.random() * (maxType + 1));
        
        // Special spawning logic for specific types
        // Exclude type 4 (ranged) from random selection at level 8-9, only available at 10+
        if (type === 4 && playerStats.lvl < 10) {
          type = 3; // Fall back to slowing
        }
        
        // Flying enemies (type 5) - 15% chance at level 8+
        if (playerStats.lvl >= 8 && Math.random() < 0.15) {
          type = 5;
        }
        
        // Ranged enemies (type 4) - only 20% chance
        if (type === 4 && Math.random() > 0.2) {
          type = Math.floor(Math.random() * 3);
        }
        
        // Hard variants (6-9) - reduce spawn rate to 30%
        if (type >= 6 && type <= 9 && Math.random() > 0.3) {
          // Fallback to types 0-5 (all basic types)
          const fallbackMax = playerStats.lvl >= 8 ? 6 : 3;
          type = Math.floor(Math.random() * fallbackMax);
          // Exclude type 4 if not unlocked
          if (type === 4 && playerStats.lvl < 10) {
            type = Math.floor(Math.random() * 3);
          }
        }
        
        enemies.push(new Enemy(type, ex, ez, playerStats.lvl));
      }
    }

    function spawnParticles(pos, color, count) {
      for(let i=0; i<count; i++) particles.push(new Particle(pos, color));
    }

    function spawnExp(x, z) {
      expGems.push(new ExpGem(x, z));
    }
    
    function spawnGold(x, z, amount) {
      goldCoins.push(new GoldCoin(x, z, amount));
    }
    
    function addGold(amount) {
      // Apply gold bonus from permanent upgrades
      const bonus = PERMANENT_UPGRADES.goldEarned.effect(saveData.upgrades.goldEarned);
      const finalAmount = Math.floor(amount * (1 + bonus));
      playerStats.gold += finalAmount;
      saveData.gold += finalAmount;
      saveData.totalGoldEarned += finalAmount;
      updateHUD();
      updateGoldDisplays();
    }
    
    function updateGoldDisplays() {
      const goldText = `GOLD: ${saveData.gold}`;
      const menuGold = document.getElementById('menu-gold');
      const shopGold = document.getElementById('shop-gold');
      if (menuGold) menuGold.innerText = goldText;
      if (shopGold) shopGold.innerText = goldText;
    }
    
    function spawnWaterDroplet(pos) {
      // Create small water droplet that falls and disappears
      const geo = new THREE.SphereGeometry(0.1, 8, 8);
      const mat = new THREE.MeshBasicMaterial({ color: COLORS.player, transparent: true, opacity: 0.6 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.copy(pos);
      mesh.position.y = 0.3;
      scene.add(mesh);
      
      // Animate falling
      let life = 20;
      const update = () => {
        life--;
        mesh.position.y -= 0.02;
        mat.opacity = life / 20;
        if (life <= 0 || mesh.position.y <= 0.05) {
          scene.remove(mesh);
          mesh.geometry.dispose();
          mesh.material.dispose();
        } else {
          requestAnimationFrame(update);
        }
      };
      update();
    }

    function addExp(amount) {
      playerStats.exp += amount;
      if (playerStats.exp >= playerStats.expReq) {
        levelUp();
      }
      updateHUD();
    }

    function levelUp() {
      isPaused = true;
      playerStats.lvl++;
      playerStats.exp -= playerStats.expReq;
      
      // Custom XP Curve: 3, 5, 7, 10...
      // Lvl 1->2 (3 kills=30), 2->3 (5 kills=50), 3->4 (7 kills=70), 4->5 (10 kills=100)
      const nextKills = [1, 2, 3, 4, 5, 6, 8, 10]; // Even Faster
      const killsNeeded = nextKills[Math.min(playerStats.lvl-1, nextKills.length-1)] || 25;
      playerStats.expReq = killsNeeded * GAME_CONFIG.expValue;
      
      // Check for level achievements
      checkAchievements();
      
      // SLOW MOTION EFFECT - Time slows, sounds pitch down
      createSlowMotionEffect();
      
      // Level up visual effects with delay for slow-mo
      setTimeout(() => {
        createLevelUpEffects();
        playSound('levelup');
      }, 300);
      
      // Show upgrade modal with dramatic entrance after effects - FASTER
      setTimeout(() => {
        showUpgradeModal();
      }, 800);
    }
    
    function createSmallFloatingText(text, pos) {
      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.color = '#5DADE2';
      div.style.fontSize = '18px';
      div.style.fontWeight = 'bold';
      div.style.textShadow = '0 0 10px rgba(93,173,226,0.8), 0 0 20px rgba(93,173,226,0.5), 2px 2px 4px #000';
      div.style.pointerEvents = 'none';
      div.style.zIndex = '1000';
      div.innerText = text;
      
      const vec = pos.clone();
      vec.y += 1;
      vec.project(camera);
      
      const x = (vec.x * .5 + .5) * window.innerWidth;
      const y = (-(vec.y * .5) + .5) * window.innerHeight;
      
      div.style.left = `${x}px`;
      div.style.top = `${y}px`;
      div.style.transform = 'translate(-50%, -50%)';
      
      document.body.appendChild(div);
      
      // Animate upward (same as damage numbers)
      setTimeout(() => div.remove(), 1000);
    }
    
    function createSlowMotionEffect() {
      // Create slow motion visual overlay
      const slowMoOverlay = document.createElement('div');
      slowMoOverlay.style.position = 'fixed';
      slowMoOverlay.style.top = '0';
      slowMoOverlay.style.left = '0';
      slowMoOverlay.style.width = '100%';
      slowMoOverlay.style.height = '100%';
      slowMoOverlay.style.background = 'radial-gradient(circle, rgba(93,173,226,0.3), rgba(0,0,0,0.6))';
      slowMoOverlay.style.zIndex = '15';
      slowMoOverlay.style.pointerEvents = 'none';
      slowMoOverlay.style.animation = 'slowMoPulse 1.5s ease-in-out';
      document.body.appendChild(slowMoOverlay);
      
      // Add CSS animation for slow-mo effect
      if (!document.getElementById('slowMoStyle')) {
        const style = document.createElement('style');
        style.id = 'slowMoStyle';
        style.textContent = `
          @keyframes slowMoPulse {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
          }
          @keyframes swooshInLeft {
            0% { transform: translateX(-200%) scale(0.5); opacity: 0; }
            60% { transform: translateX(10%) scale(1.1); opacity: 1; }
            100% { transform: translateX(0) scale(1); opacity: 1; }
          }
          @keyframes swooshInRight {
            0% { transform: translateX(200%) scale(0.5); opacity: 0; }
            60% { transform: translateX(-10%) scale(1.1); opacity: 1; }
            100% { transform: translateX(0) scale(1); opacity: 1; }
          }
        `;
        document.head.appendChild(style);
      }
      
      setTimeout(() => {
        slowMoOverlay.remove();
      }, 1500);
    }
    
    function createLevelUpEffects() {
      // Water Fountain Effect - 60 water droplet particles explode from character
      for(let i=0; i<60; i++) {
        const angle = (i / 60) * Math.PI * 2;
        const speed = 0.2 + Math.random() * 0.4;
        const height = 0.6 + Math.random() * 0.8;
        
        // Water droplets
        const dropletGeo = new THREE.SphereGeometry(0.08, 8, 8);
        const dropletMat = new THREE.MeshPhysicalMaterial({ 
          color: COLORS.player,
          transparent: true,
          opacity: 0.9,
          metalness: 0.3,
          roughness: 0.1
        });
        const droplet = new THREE.Mesh(dropletGeo, dropletMat);
        droplet.position.copy(player.mesh.position);
        droplet.position.y += 1;
        scene.add(droplet);
        
        const vel = new THREE.Vector3(
          Math.cos(angle) * speed,
          height,
          Math.sin(angle) * speed
        );
        
        let life = 80;
        const updateDroplet = () => {
          life--;
          droplet.position.add(vel);
          vel.y -= 0.03; // Gravity
          droplet.rotation.y += 0.1;
          droplet.material.opacity = life / 80;
          
          if (life <= 0 || droplet.position.y < 0) {
            scene.remove(droplet);
            droplet.geometry.dispose();
            droplet.material.dispose();
          } else {
            requestAnimationFrame(updateDroplet);
          }
        };
        updateDroplet();
      }
      
      // Expanding splash ring on ground
      const ringGeo = new THREE.RingGeometry(0.5, 1, 32);
      const ringMat = new THREE.MeshBasicMaterial({ 
        color: COLORS.player,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.position.copy(player.mesh.position);
      ring.position.y = 0.05;
      ring.rotation.x = -Math.PI / 2;
      scene.add(ring);
      
      let ringLife = 60;
      const updateRing = () => {
        ringLife--;
        const scale = 1 + (60 - ringLife) * 0.15;
        ring.scale.set(scale, scale, 1);
        ring.material.opacity = ringLife / 60;
        
        if (ringLife <= 0) {
          scene.remove(ring);
          ring.geometry.dispose();
          ring.material.dispose();
        } else {
          requestAnimationFrame(updateRing);
        }
      };
      updateRing();
      
      // Fountain/explosion of "LEVEL UP" text particles from player's head
      const texts = ["L", "E", "V", "E", "L", " ", "U", "P", "!"];
      
      for(let i=0; i<40; i++) {
        const angle = (i / 40) * Math.PI * 2;
        const speed = 0.15 + Math.random() * 0.35;
        const text = texts[i % texts.length];
        
        const particle = new LevelUpTextParticle(
          player.mesh.position.clone(),
          new THREE.Vector3(
            Math.cos(angle) * speed,
            0.4 + Math.random() * 0.6,
            Math.sin(angle) * speed
          ),
          text
        );
        particles.push(particle);
      }
      
      // Add regular colored particles
      for(let i=0; i<30; i++) {
        const angle = (i / 30) * Math.PI * 2;
        const speed = 0.2 + Math.random() * 0.3;
        const particle = new LevelUpParticle(
          player.mesh.position.clone(),
          new THREE.Vector3(
            Math.cos(angle) * speed,
            0.5 + Math.random() * 0.5,
            Math.sin(angle) * speed
          )
        );
        particles.push(particle);
      }
      
      // Lightning bolts
      for(let i=0; i<8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const lightning = new LightningBolt(
          player.mesh.position.clone(),
          new THREE.Vector3(
            Math.cos(angle) * 5,
            8,
            Math.sin(angle) * 5
          )
        );
        particles.push(lightning);
      }
      
      // Camera zoom effect
      const originalD = 20;
      const zoomD = 12; // Zoom closer
      const zoomDuration = 1200; // ms
      const startTime = Date.now();
      
      const zoomAnim = () => {
        const elapsed = Date.now() - startTime;
        const t = Math.min(elapsed / zoomDuration, 1);
        const eased = 1 - Math.pow(1 - t, 3); // Ease out cubic
        
        const d = originalD - (originalD - zoomD) * Math.sin(eased * Math.PI);
        const aspect = window.innerWidth / window.innerHeight;
        camera.left = -d * aspect;
        camera.right = d * aspect;
        camera.top = d;
        camera.bottom = -d;
        camera.updateProjectionMatrix();
        
        if (t < 1) {
          requestAnimationFrame(zoomAnim);
        }
      };
      zoomAnim();
      
      // Screen shake
      const originalCameraPos = camera.position.clone();
      let shakeTime = 0;
      const shakeDuration = 0.5;
      
      const shakeAnim = () => {
        shakeTime += 0.016;
        if (shakeTime < shakeDuration) {
          const intensity = (1 - shakeTime / shakeDuration) * 2;
          camera.position.x = originalCameraPos.x + (Math.random() - 0.5) * intensity;
          camera.position.y = originalCameraPos.y + (Math.random() - 0.5) * intensity;
          camera.position.z = originalCameraPos.z + (Math.random() - 0.5) * intensity;
          requestAnimationFrame(shakeAnim);
        } else {
          camera.position.copy(originalCameraPos);
        }
      };
      shakeAnim();
    }
    
    class LevelUpTextParticle {
      constructor(pos, vel, text) {
        // Create sprite with text
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.font = 'bold 48px Arial';
        ctx.fillStyle = '#5DADE2';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = '#FFF';
        ctx.shadowBlur = 10;
        ctx.fillText(text, 32, 32);
        
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
        this.mesh = new THREE.Sprite(spriteMat);
        this.mesh.scale.set(0.5, 0.5, 0.5);
        this.mesh.position.copy(pos);
        this.mesh.position.y += 1;
        this.vel = vel;
        scene.add(this.mesh);
        this.life = 80;
        this.rotSpeed = (Math.random() - 0.5) * 0.2;
      }
      
      update() {
        this.life--;
        this.mesh.position.add(this.vel);
        this.vel.y -= 0.02; // Gravity
        this.mesh.rotation.z += this.rotSpeed;
        
        // Fade out
        this.mesh.material.opacity = this.life / 80;
        
        if (this.mesh.position.y < 0.1) {
          this.mesh.position.y = 0.1;
          this.vel.y *= -0.5; // Bounce
          this.vel.x *= 0.7;
          this.vel.z *= 0.7;
        }
        
        if (this.life <= 0) {
          scene.remove(this.mesh);
          this.mesh.material.map.dispose();
          this.mesh.material.dispose();
          return false;
        }
        return true;
      }
    }
    
    class LightningBolt {
      constructor(start, end) {
        const points = [];
        const segments = 12; // Increased from 8 for more detail
        
        for(let i=0; i<=segments; i++) {
          const t = i / segments;
          const x = start.x + (end.x - start.x) * t + (Math.random() - 0.5) * 2; // Increased randomness
          const y = start.y + (end.y - start.y) * t + (Math.random() - 0.5) * 2;
          const z = start.z + (end.z - start.z) * t + (Math.random() - 0.5) * 2;
          points.push(new THREE.Vector3(x, y, z));
        }
        
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ 
          color: 0x00FFFF, // Bright cyan/electric blue for better distinction from gunfire
          transparent: true, 
          opacity: 1,
          linewidth: 5 // Note: linewidth not supported in WebGL, will render at 1px
        });
        
        this.mesh = new THREE.Line(geometry, material);
        scene.add(this.mesh);
        this.life = 30; // Increased from 20 for longer visibility
        this.maxLife = 30;
      }
      
      update() {
        this.life--;
        this.mesh.material.opacity = this.life / this.maxLife;
        
        if (this.life <= 0) {
          scene.remove(this.mesh);
          this.mesh.geometry.dispose();
          this.mesh.material.dispose();
          return false;
        }
        return true;
      }
    }
    
    class LevelUpParticle {
      constructor(pos, vel) {
        const geo = new THREE.OctahedronGeometry(0.15);
        const mat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.copy(pos);
        this.mesh.position.y += 1;
        this.vel = vel;
        scene.add(this.mesh);
        this.life = 60;
      }
      
      update() {
        this.life--;
        this.mesh.position.add(this.vel);
        this.vel.y -= 0.015; // Gravity
        this.mesh.rotation.x += 0.1;
        this.mesh.rotation.y += 0.1;
        
        if (this.mesh.position.y < 0) {
          this.mesh.position.y = 0;
          this.vel.y = 0;
          this.vel.x *= 0.8;
          this.vel.z *= 0.8;
        }
        
        if (this.life <= 0) {
          scene.remove(this.mesh);
          this.mesh.geometry.dispose();
          this.mesh.material.dispose();
          return false;
        }
        return true;
      }
    }
    
    function createFloatingText(text, pos) {
      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.color = '#5DADE2';
      div.style.fontSize = '28px';
      div.style.fontWeight = 'bold';
      div.style.textShadow = '0 0 15px rgba(93,173,226,0.8), 0 0 30px rgba(93,173,226,0.5), 2px 2px 4px #000';
      div.style.pointerEvents = 'none';
      div.style.zIndex = '100';
      div.style.whiteSpace = 'nowrap';
      div.innerText = text;
      
      const vec = pos.clone();
      vec.y += 1;
      vec.project(camera);
      
      const x = (vec.x * .5 + .5) * window.innerWidth;
      const y = (-(vec.y * .5) + .5) * window.innerHeight;
      
      div.style.left = `${x}px`;
      div.style.top = `${y}px`;
      div.style.transform = 'translate(-50%, -50%)';
      
      document.body.appendChild(div);
      
      // Animate upward
      let offsetY = 0;
      const animateDuration = 2000;
      const startTime = Date.now();
      
      const animate = () => {
        const elapsed = Date.now() - startTime;
        const t = elapsed / animateDuration;
        
        if (t >= 1) {
          div.remove();
          return;
        }
        
        offsetY = -100 * t;
        const opacity = 1 - t;
        const scale = 1 + t * 0.5;
        
        div.style.top = `${y + offsetY}px`;
        div.style.opacity = opacity;
        div.style.transform = `translate(-50%, -50%) scale(${scale})`;
        
        requestAnimationFrame(animate);
      };
      animate();
    }

    function showUpgradeModal() {
      const modal = document.getElementById('levelup-modal');
      const list = document.getElementById('upgrade-list');
      list.innerHTML = '';
      
      let choices = [];

      // --- POOL OF UPGRADES ---
      const commonUpgrades = [
        { 
          id: 'str', 
          icon: '⚔️',
          title: 'MUSCLE JUICE', 
          desc: 'Weapon Damage +15% (Base Strength Multiplier)', 
          apply: () => { 
            playerStats.strength += 0.15; 
            showStatChange('+15% Damage');
          } 
        },
        { 
          id: 'aspd', 
          icon: '⚡',
          title: 'SPEEDY TRIGGER', 
          desc: 'Attack Speed +15% (Faster Weapon Fire Rate)', 
          apply: () => { 
            playerStats.atkSpeed += 0.15; 
            weapons.gun.cooldown *= 0.85; 
            weapons.doubleBarrel.cooldown *= 0.85;
            showStatChange('+15% Attack Speed');
          } 
        },
        { 
          id: 'armor', 
          icon: '🛡️',
          title: 'THICC ARMOR', 
          desc: 'Armor +12% (Damage Reduction, Max 80%)', 
          apply: () => { 
            playerStats.armor = Math.min(80, playerStats.armor + 12); 
            showStatChange('+12% Armor (Current: ' + playerStats.armor + '%)');
          } 
        },
        { 
          id: 'hp', 
          icon: '❤️',
          title: 'CHONKY BODY', 
          desc: 'Max HP +30 (Instant Heal +30)', 
          apply: () => { 
            playerStats.maxHp += 30; 
            playerStats.hp += 30; 
            showStatChange('+30 Max HP');
          } 
        },
        { 
          id: 'crit', 
          icon: '🎯',
          title: 'CRIT MACHINE', 
          desc: 'Critical Hit Chance +8% (Lucky Strikes)', 
          apply: () => { 
            playerStats.critChance += 0.08; 
            showStatChange('+8% Crit Chance (Now: ' + Math.round(playerStats.critChance * 100) + '%)');
          } 
        },
        { 
          id: 'regen', 
          icon: '💚',
          title: 'HEALING VIBES', 
          desc: 'HP Regeneration +2/sec (Passive Healing)', 
          apply: () => { 
            playerStats.hpRegen += 2; 
            showStatChange('+2 HP/sec Regen (Total: ' + playerStats.hpRegen + '/sec)');
          } 
        },
        { 
          id: 'speed', 
          icon: '🏃',
          title: 'SPEEDY BOI', 
          desc: 'Movement Speed +15% (Faster Movement)', 
          apply: () => { 
            playerStats.walkSpeed *= 1.15; 
            showStatChange('+15% Move Speed');
          } 
        },
        { 
          id: 'critdmg', 
          icon: '💥',
          title: 'GLASS CANNON', 
          desc: 'Critical Damage +30% (Stronger Crits)', 
          apply: () => { 
            playerStats.critDmg += 0.3; 
            showStatChange('+30% Crit Damage (Now: ' + Math.round(playerStats.critDmg * 100) + '%)');
          } 
        },
        { 
          id: 'magnet', 
          icon: '🧲',
          title: 'XP MAGNET', 
          desc: 'EXP Pickup Range +25% (+1 unit)', 
          apply: () => { 
            magnetRange += 1; 
            showStatChange('EXP Magnet Range +25% (Now: ' + magnetRange + ' units)');
          } 
        },
        { 
          id: 'cooldown', 
          icon: '⏱️',
          title: 'COOLDOWN MASTER', 
          desc: 'All Weapon Cooldowns -5% (Faster Abilities)', 
          apply: () => { 
            weapons.gun.cooldown *= 0.95;
            weapons.sword.cooldown *= 0.95;
            weapons.aura.cooldown *= 0.95;
            weapons.meteor.cooldown *= 0.95;
            weapons.lightning.cooldown *= 0.95;
            weapons.doubleBarrel.cooldown *= 0.95;
            weapons.iceSpear.cooldown *= 0.95;
            weapons.fireRing.cooldown *= 0.95;
            showStatChange('All Weapon Cooldowns -5%');
          } 
        },
        { 
          id: 'dash_mastery', 
          icon: '💨',
          title: 'DASH MASTERY', 
          desc: 'Dash Cooldown -20%, Distance +30%', 
          apply: () => { 
            playerStats.dashCooldownReduction += 0.2;
            playerStats.dashDistanceBonus += 0.3;
            dashCooldown *= 0.8;
            dashDistance *= 1.3;
            player.dashDuration *= 0.9; // Slightly faster dash
            showStatChange('Dash Improved! CD: -20%, Distance: +30%');
          } 
        },
        { 
          id: 'second_wind', 
          icon: '🛡️',
          title: 'SECOND WIND', 
          desc: 'Gain 30 Shield when HP drops below 30%', 
          apply: () => { 
            playerStats.hasSecondWind = true;
            showStatChange('Second Wind Unlocked!');
          } 
        },
        { 
          id: 'life_steal', 
          icon: '🩸',
          title: 'LIFE STEAL', 
          desc: 'Heal 3% of Damage Dealt (Stacks)', 
          apply: () => { 
            playerStats.lifeStealPercent += 0.03;
            showStatChange('Life Steal +3% (Total: ' + Math.round(playerStats.lifeStealPercent * 100) + '%)');
          } 
        },
        { 
          id: 'thorns', 
          icon: '🔱',
          title: 'THORNS', 
          desc: 'Reflect 15% Damage to Attackers (Stacks)', 
          apply: () => { 
            playerStats.thornsPercent += 0.15;
            showStatChange('Thorns +15% (Total: ' + Math.round(playerStats.thornsPercent * 100) + '%)');
          } 
        },
        { 
          id: 'berserker_rage', 
          icon: '😤',
          title: 'BERSERKER RAGE', 
          desc: 'Gain 25% Attack Speed when below 50% HP', 
          apply: () => { 
            playerStats.hasBerserkerRage = true;
            showStatChange('Berserker Rage Unlocked!');
          } 
        },
        { 
          id: 'treasure_hunter', 
          icon: '💰',
          title: 'TREASURE HUNTER', 
          desc: '20% Chance to Drop Extra Gold (Stacks)', 
          apply: () => { 
            playerStats.treasureHunterChance += 0.2;
            showStatChange('Treasure Hunter +20% (Total: ' + Math.round(playerStats.treasureHunterChance * 100) + '%)');
          } 
        },
        { 
          id: 'lucky_strikes', 
          icon: '✨',
          title: 'LUCKY STRIKES', 
          desc: 'Crits have 25% Chance to Strike Twice', 
          apply: () => { 
            playerStats.doubleCritChance += 0.25;
            showStatChange('Lucky Strikes +25% (Total: ' + Math.round(playerStats.doubleCritChance * 100) + '%)');
          } 
        }
      ];

      // --- SPECIAL LEVELS ---
      
      // Levels 4, 9, 17: WEAPON UPGRADE LEVELS
      if ([4, 9, 17].includes(playerStats.lvl)) {
        modal.querySelector('h2').innerText = 'WEAPON UPGRADE!';
        modal.querySelector('h2').style.fontSize = '36px';
        
        choices = [];
        
        // Offer weapon upgrades for active weapons
        if (weapons.gun.active && weapons.gun.level < 4) {
          const nextLevel = weapons.gun.level + 1;
          choices.push({ 
            id: 'gun_upgrade', 
            icon: '🔫',
            title: `GUN Level ${nextLevel}`, 
            desc: `Damage +10, Fire Rate +15%`, 
            apply: () => { 
              weapons.gun.level++;
              weapons.gun.damage += 10;
              weapons.gun.cooldown *= 0.85;
              showStatChange(`Gun Level ${weapons.gun.level}`);
            } 
          });
        }
        
        if (weapons.sword.active && weapons.sword.level < 4) {
          const nextLevel = weapons.sword.level + 1;
          choices.push({ 
            id: 'sword_upgrade', 
            icon: '⚔️',
            title: `SWORD Level ${nextLevel}`, 
            desc: `Damage +15, Range +0.5`, 
            apply: () => { 
              weapons.sword.level++;
              weapons.sword.damage += 15;
              weapons.sword.range += 0.5;
              showStatChange(`Sword Level ${weapons.sword.level}`);
            } 
          });
        }
        
        if (weapons.aura.active && weapons.aura.level < 4) {
          const nextLevel = weapons.aura.level + 1;
          const baseRange = 3; // Initial range
          const currentRange = weapons.aura.range;
          const nextRange = Math.min(5, baseRange * (1 + (nextLevel * 0.10))); // +10% per level, cap at 5
          const rangeIncrease = Math.round((nextRange - currentRange) * 10) / 10;
          
          choices.push({ 
            id: 'aura_upgrade', 
            icon: '🌀',
            title: `AURA Level ${nextLevel}`, 
            desc: `Damage +3, Range +${rangeIncrease.toFixed(1)}`, 
            apply: () => { 
              weapons.aura.level++;
              weapons.aura.damage += 3;
              weapons.aura.range = Math.min(5, baseRange * (1 + (weapons.aura.level * 0.10)));
              showStatChange(`Aura Level ${weapons.aura.level}`);
            } 
          });
        }
        
        if (weapons.meteor.active && weapons.meteor.level < 4) {
          const nextLevel = weapons.meteor.level + 1;
          choices.push({ 
            id: 'meteor_upgrade', 
            icon: '☄️',
            title: `METEOR Level ${nextLevel}`, 
            desc: `Damage +20, Area +1`, 
            apply: () => { 
              weapons.meteor.level++;
              weapons.meteor.damage += 20;
              weapons.meteor.area += 1;
              showStatChange(`Meteor Level ${weapons.meteor.level}`);
            } 
          });
        }
        
        if (weapons.lightning.active && weapons.lightning.level < 4) {
          const nextLevel = weapons.lightning.level + 1;
          const targetIncrease = nextLevel === 2 ? 3 : (nextLevel === 3 ? 2 : 1);
          choices.push({ 
            id: 'lightning_upgrade', 
            icon: '⚡',
            title: `LIGHTNING Level ${nextLevel}`, 
            desc: `Damage +10, Targets +${targetIncrease}`, 
            apply: () => { 
              weapons.lightning.level++;
              weapons.lightning.damage += 10;
              weapons.lightning.targets += targetIncrease;
              showStatChange(`Lightning Level ${weapons.lightning.level}`);
            } 
          });
        }
        
        if (weapons.doubleBarrel.active && weapons.doubleBarrel.level < 4) {
          const nextLevel = weapons.doubleBarrel.level + 1;
          choices.push({ 
            id: 'doublebarrel_upgrade', 
            icon: '🔫',
            title: `DOUBLE BARREL Level ${nextLevel}`, 
            desc: `Damage +12, Fire Rate +10%`, 
            apply: () => { 
              weapons.doubleBarrel.level++;
              weapons.doubleBarrel.damage += 12;
              weapons.doubleBarrel.cooldown *= 0.9;
              showStatChange(`Double Barrel Level ${weapons.doubleBarrel.level}`);
            } 
          });
        }
        
        if (weapons.iceSpear.active && weapons.iceSpear.level < 4) {
          const nextLevel = weapons.iceSpear.level + 1;
          choices.push({ 
            id: 'icespear_upgrade', 
            icon: '❄️',
            title: `ICE SPEAR Level ${nextLevel}`, 
            desc: `Damage +10, Slow +10%, Duration +0.5s`, 
            apply: () => { 
              weapons.iceSpear.level++;
              weapons.iceSpear.damage += 10;
              weapons.iceSpear.slowPercent += 0.1;
              weapons.iceSpear.slowDuration += 500;
              showStatChange(`Ice Spear Level ${weapons.iceSpear.level}`);
            } 
          });
        }
        
        if (weapons.fireRing.active && weapons.fireRing.level < 4) {
          const nextLevel = weapons.fireRing.level + 1;
          choices.push({ 
            id: 'firering_upgrade', 
            icon: '🔥',
            title: `FIRE RING Level ${nextLevel}`, 
            desc: `Damage +5, +1 Orb, Range +0.5`, 
            apply: () => { 
              weapons.fireRing.level++;
              weapons.fireRing.damage += 5;
              weapons.fireRing.orbs += 1;
              weapons.fireRing.range += 0.5;
              showStatChange(`Fire Ring Level ${weapons.fireRing.level}`);
            } 
          });
        }
        
        // Add some stat upgrades too
        choices.push(...commonUpgrades.sort(() => 0.5 - Math.random()).slice(0, 2));
        
        // Shuffle and limit to 3 choices
        choices = choices.sort(() => 0.5 - Math.random()).slice(0, 3);
      }
      // Level 5: Choose Secondary Weapon
      else if (playerStats.lvl === 5) {
        choices = [
          { 
            id: 'sword', 
            icon: '⚔️',
            title: 'SLASHY SLASH', 
            desc: 'Slash enemies in front', 
            apply: () => { 
              weapons.sword.active = true;
              weapons.sword.level = 1;
              showStatChange('New Weapon: Sword');
            } 
          },
          { 
            id: 'aura', 
            icon: '🌀',
            title: 'ZAP ZONE', 
            desc: 'Damage aura around you', 
            apply: () => { 
              weapons.aura.active = true;
              weapons.aura.level = 1;
              showStatChange('New Weapon: Aura');
            } 
          },
          { 
            id: 'meteor', 
            icon: '☄️',
            title: 'SPACE ROCKS', 
            desc: 'Call meteors from sky', 
            apply: () => { 
              weapons.meteor.active = true;
              weapons.meteor.level = 1;
              showStatChange('New Weapon: Meteor');
            } 
          },
          { 
            id: 'lightning', 
            icon: '⚡',
            title: 'LIGHTNING STRIKES', 
            desc: 'Random lightning hits 4 enemies', 
            apply: () => { 
              weapons.lightning.active = true;
              weapons.lightning.level = 1;
              showStatChange('New Weapon: Lightning');
            } 
          },
          { 
            id: 'doublebarrel', 
            icon: '🔫',
            title: 'DOUBLE BARREL', 
            desc: 'Powerful shotgun spread', 
            apply: () => { 
              weapons.doubleBarrel.active = true;
              weapons.doubleBarrel.level = 1;
              showStatChange('New Weapon: Double Barrel');
            } 
          },
          { 
            id: 'icespear', 
            icon: '❄️',
            title: 'ICE SPEAR', 
            desc: 'Freezing projectile that slows enemies 40%', 
            apply: () => { 
              weapons.iceSpear.active = true;
              weapons.iceSpear.level = 1;
              showStatChange('New Weapon: Ice Spear');
            } 
          },
          { 
            id: 'firering', 
            icon: '🔥',
            title: 'FIRE RING', 
            desc: 'Spinning fire orbs orbit around you', 
            apply: () => { 
              weapons.fireRing.active = true;
              weapons.fireRing.level = 1;
              showStatChange('New Weapon: Fire Ring');
            } 
          }
        ];
      }
      // Level 10: CLASS SELECTION
      else if (playerStats.lvl === 10) {
        modal.querySelector('h2').innerText = 'CHOOSE YOUR CLASS';
        modal.querySelector('h2').style.fontSize = '42px';
        
        choices = [
          { 
            id: 'class_tank', 
            title: 'TANK', 
            desc: 'HP+50, Regen+2, Armor+20%, Speed-15%', 
            apply: () => { 
              playerStats.maxHp+=50; 
              playerStats.hp+=50; 
              playerStats.hpRegen+=2; 
              playerStats.armor+=20;
              playerStats.walkSpeed *= 0.85;
              showStatChange('Class: TANK');
            } 
          },
          { 
            id: 'class_berserker', 
            title: 'BERSERKER', 
            desc: 'Str+30%, Crit+10%, Attack Speed+20%, Armor-10%', 
            apply: () => { 
              playerStats.strength+=0.3; 
              playerStats.critChance+=0.1; 
              playerStats.atkSpeed+=0.2;
              weapons.gun.cooldown *= 0.8;
              playerStats.armor = Math.max(0, playerStats.armor-10);
              showStatChange('Class: BERSERKER');
            } 
          },
          { 
            id: 'class_rogue', 
            title: 'ROGUE', 
            desc: 'Speed+25%, Crit+15%, Crit Dmg+30%, HP-20', 
            apply: () => { 
              playerStats.walkSpeed *= 1.25; 
              playerStats.critChance+=0.15; 
              playerStats.critDmg+=0.3;
              playerStats.maxHp = Math.max(50, playerStats.maxHp-20);
              playerStats.hp = Math.min(playerStats.hp, playerStats.maxHp);
              showStatChange('Class: ROGUE');
            } 
          },
          { 
            id: 'class_mage', 
            title: 'MAGE', 
            desc: 'Aura Range+2, Meteor CD-1s, Regen+3, Move Speed+10%', 
            apply: () => { 
              weapons.aura.range+=2; 
              weapons.meteor.cooldown = Math.max(500, weapons.meteor.cooldown-1000);
              playerStats.hpRegen+=3;
              playerStats.walkSpeed *= 1.1;
              showStatChange('Class: MAGE');
            } 
          }
        ];
      } 
      // Level 12, 18, 25: PERK UNLOCKS
      else if ([12, 18, 25].includes(playerStats.lvl)) {
        modal.querySelector('h2').innerText = 'PERK UNLOCK!';
        modal.querySelector('h2').style.fontSize = '40px';
        
        // Create perk pool based on level
        const perkChoices = [
          { 
            id: 'perk_vampire', 
            icon: '🧛',
            title: 'VAMPIRE', 
            desc: `Life Steal +5% (Current: ${Math.round(playerStats.perks.vampire * 5)}%)`, 
            apply: () => { 
              playerStats.perks.vampire++;
              playerStats.lifeStealPercent += 0.05;
              showStatChange(`Vampire Perk Level ${playerStats.perks.vampire}! (+5% Life Steal)`);
            } 
          },
          { 
            id: 'perk_juggernaut', 
            icon: '🛡️',
            title: 'JUGGERNAUT', 
            desc: `Damage Reduction +8% (Current: ${Math.round(playerStats.perks.juggernaut * 8)}%)`, 
            apply: () => { 
              playerStats.perks.juggernaut++;
              playerStats.armor = Math.min(80, playerStats.armor + 8);
              showStatChange(`Juggernaut Perk Level ${playerStats.perks.juggernaut}! (+8% Armor)`);
            } 
          },
          { 
            id: 'perk_swift', 
            icon: '⚡',
            title: 'SWIFT', 
            desc: `Movement Speed +15% (Current: Level ${playerStats.perks.swift})`, 
            apply: () => { 
              playerStats.perks.swift++;
              playerStats.walkSpeed *= 1.15;
              showStatChange(`Swift Perk Level ${playerStats.perks.swift}! (+15% Move Speed)`);
            } 
          },
          { 
            id: 'perk_lucky', 
            icon: '🍀',
            title: 'LUCKY', 
            desc: `Critical Chance +8% (Current: ${Math.round(playerStats.perks.lucky * 8)}%)`, 
            apply: () => { 
              playerStats.perks.lucky++;
              playerStats.critChance += 0.08;
              showStatChange(`Lucky Perk Level ${playerStats.perks.lucky}! (+8% Crit Chance)`);
            } 
          },
          { 
            id: 'perk_berserker', 
            icon: '💢',
            title: 'BERSERKER SOUL', 
            desc: `Low HP Bonus +10% Damage (Current: Level ${playerStats.perks.berserker})`, 
            apply: () => { 
              playerStats.perks.berserker++;
              showStatChange(`Berserker Soul Level ${playerStats.perks.berserker}! (Bonus when HP < 50%)`);
            } 
          }
        ];
        
        // Randomly select 3 perks
        choices = perkChoices.sort(() => 0.5 - Math.random()).slice(0, 3);
      }
      else {
        // Random 4
        choices = commonUpgrades.sort(() => 0.5 - Math.random()).slice(0, 4);
      }

      choices.forEach((u, index) => {
        const card = document.createElement('div');
        card.className = 'upgrade-card';
        
        // Add special styling for perks and powerful upgrades
        if (u.id && u.id.startsWith('perk_')) {
          card.className += ' perk';
        } else if (u.id && (u.id.includes('dash_mastery') || u.id.includes('second_wind') || 
                            u.id.includes('berserker_rage') || u.id.includes('lucky_strikes'))) {
          card.className += ' legendary';
        }
        
        const iconHTML = u.icon ? `<div style="font-size: 48px; margin-bottom: 10px;">${u.icon}</div>` : '';
        card.innerHTML = `${iconHTML}<div class="upgrade-title">${u.title}</div><div class="upgrade-desc">${u.desc}</div>`;
        
        // Add dramatic entrance animation - alternate left/right
        card.style.opacity = '0';
        if (index % 2 === 0) {
          card.style.animation = `swooshInLeft 0.6s ease-out ${index * 0.15}s forwards`;
        } else {
          card.style.animation = `swooshInRight 0.6s ease-out ${index * 0.15}s forwards`;
        }
        
        card.onclick = () => {
          playSound('splash'); // Water splash sound when picking
          u.apply();
          modal.style.display = 'none';
          modal.querySelector('h2').innerText = 'LEVEL UP!';
          modal.querySelector('h2').style.fontSize = '32px';
          isPaused = false;
          updateHUD();
        };
        list.appendChild(card);
      });

      modal.style.display = 'flex';
    }

    function updateHUD() {
      const hpPct = (playerStats.hp / playerStats.maxHp) * 100;
      document.getElementById('hp-fill').style.width = `${Math.max(0, hpPct)}%`;
      document.getElementById('hp-text').innerText = `HP: ${Math.max(0, Math.ceil(playerStats.hp))}/${playerStats.maxHp}`;
      
      const expPct = (playerStats.exp / playerStats.expReq) * 100;
      document.getElementById('exp-fill').style.width = `${Math.min(100, expPct)}%`;
      document.getElementById('exp-text').innerText = `EXP: ${Math.min(100, Math.ceil(expPct))}%`;
      document.getElementById('lvl-text').innerText = `LVL: ${playerStats.lvl}`;
      document.getElementById('score-text').innerText = `KILLS: ${playerStats.kills}`;
      document.getElementById('gold-text').innerText = `GOLD: ${playerStats.gold}`;
    }
    
    function updateWindmillQuestUI() {
      if (!windmillQuest.active || !windmillQuest.windmill) return;
      
      const hp = windmillQuest.windmill.userData.hp;
      const maxHp = windmillQuest.windmill.userData.maxHp;
      const hpPct = (hp / maxHp) * 100;
      
      document.getElementById('windmill-hp-fill').style.width = `${Math.max(0, hpPct)}%`;
      document.getElementById('windmill-hp-text').innerText = `WINDMILL: ${Math.max(0, Math.ceil(hp))}/${maxHp}`;
      document.getElementById('windmill-timer-text').innerText = `DEFEND: ${Math.ceil(windmillQuest.timer)}s`;
    }
    
    function startWindmillQuest(windmill) {
      if (windmillQuest.hasCompleted) return;
      
      windmillQuest.active = true;
      windmillQuest.timer = windmillQuest.duration;
      windmillQuest.windmill = windmill;
      windmill.userData.hp = 600;
      windmill.userData.maxHp = 600;
      
      document.getElementById('windmill-quest-ui').style.display = 'block';
      updateWindmillQuestUI();
      
      createFloatingText("DEFEND THE WINDMILL!", windmill.position);
    }
    
    function completeWindmillQuest() {
      windmillQuest.active = false;
      windmillQuest.hasCompleted = true;
      document.getElementById('windmill-quest-ui').style.display = 'none';
      
      createFloatingText("QUEST COMPLETE!", windmillQuest.windmill.position);
      
      // Grant passive level up
      playerStats.lvl++;
      playerStats.expReq = (playerStats.lvl * 2) * GAME_CONFIG.expValue;
      
      // Unlock Double Barrel Gun
      weapons.gun.barrels = 2;
      weapons.gun.damage += 10;
      
      createFloatingText("DOUBLE BARREL UNLOCKED!", player.mesh.position);
      playSound('levelup');
      updateHUD();
    }

    function createDamageNumber(amount, pos, isCrit = false) {
      const div = document.createElement('div');
      div.className = isCrit ? 'damage-number critical' : 'damage-number normal';
      div.innerText = isCrit ? `CRITICAL!\n${Math.floor(amount)}` : Math.floor(amount);
      
      // Project 3D pos to 2D screen
      const vec = pos.clone();
      vec.y += 1.5;
      vec.project(camera);
      
      const x = (vec.x * .5 + .5) * window.innerWidth;
      const y = (-(vec.y * .5) + .5) * window.innerHeight;
      
      div.style.position = 'absolute';
      div.style.left = `${x}px`;
      div.style.top = `${y}px`;
      div.style.transform = 'translate(-50%, -50%)';
      div.style.whiteSpace = 'pre';
      div.style.textAlign = 'center';
      
      document.body.appendChild(div);
      setTimeout(() => div.remove(), 1000);
    }
    
    function showStatChange(text) {
      // Create floating text on bottom-left of screen (not blocking character)
      const div = document.createElement('div');
      div.style.position = 'fixed';
      div.style.bottom = '80px'; // Bottom-left position
      div.style.left = '20px';
      div.style.transform = 'translateX(-100%) scale(0)'; // Start off-screen left
      div.style.color = '#FFD700';
      div.style.fontSize = '20px';
      div.style.fontWeight = 'bold';
      div.style.textShadow = '0 0 10px rgba(255,215,0,0.8), 0 0 20px rgba(255,215,0,0.5), 2px 2px 4px #000';
      div.style.padding = '10px 15px';
      div.style.background = 'rgba(30,30,30,0.9)';
      div.style.borderRadius = '10px';
      div.style.border = '2px solid #FFD700';
      div.style.zIndex = '2000';
      div.style.pointerEvents = 'none';
      div.innerText = text;
      
      document.body.appendChild(div);
      
      // Animate: slide in from left, scale up, stay visible longer, then fade out matching fade-in
      let scale = 0;
      let opacity = 1;
      const animDuration = 1700; // Increased from 1500ms by 200ms
      const startTime = Date.now();
      
      const animate = () => {
        const elapsed = Date.now() - startTime;
        const t = elapsed / animDuration;
        
        if (t >= 1) {
          div.remove();
          return;
        }
        
        // Scale and fade animation: ease-in, hold, ease-out (matching style)
        if (t < 0.2) {
          // Fade in (0 to 0.2)
          scale = Math.sin((t / 0.2) * Math.PI / 2); // Ease in
          opacity = scale;
        } else if (t < 0.8) {
          // Hold at full scale (0.2 to 0.8)
          scale = 1;
          opacity = 1;
        } else {
          // Fade out (0.8 to 1.0) - matching fade-in curve
          const fadeT = (t - 0.8) / 0.2;
          scale = Math.cos(fadeT * Math.PI / 2); // Ease out (mirror of ease in)
          opacity = scale;
        }
        
        // Slide in from left
        const translateX = t < 0.2 ? (1 - (t / 0.2)) * -100 : 0;
        div.style.transform = `translateX(${translateX}%) scale(${scale})`;
        div.style.opacity = opacity;
        
        requestAnimationFrame(animate);
      };
      animate();
    }

    function gameOver() {
      isGameOver = true;
      isPaused = true;
      isGameActive = false;
      
      // Calculate run stats
      const survivalTime = Math.floor((Date.now() - gameStartTime) / 1000);
      const goldEarned = playerStats.gold - runStartGold;
      
      // Update save data
      saveData.totalRuns++;
      if (survivalTime > saveData.bestTime) saveData.bestTime = survivalTime;
      if (playerStats.kills > saveData.bestKills) saveData.bestKills = playerStats.kills;
      saveSaveData();
      
      // Display game over screen
      document.getElementById('gameover-screen').style.display = 'flex';
      document.getElementById('final-score').innerText = `Survived: ${survivalTime}s`;
      document.getElementById('final-kills').innerText = `Kills: ${playerStats.kills}`;
      document.getElementById('gold-earned').innerText = `Gold Earned: ${goldEarned}`;
      document.getElementById('total-gold').innerText = `Total Gold: ${saveData.gold}`;
      updateGoldDisplays();
    }

    function resetGame() {
      // Apply permanent upgrades from save data
      const baseHp = 100 + PERMANENT_UPGRADES.maxHp.effect(saveData.upgrades.maxHp);
      const baseRegen = PERMANENT_UPGRADES.hpRegen.effect(saveData.upgrades.hpRegen);
      const baseSpeed = 25 * (1 + PERMANENT_UPGRADES.moveSpeed.effect(saveData.upgrades.moveSpeed));
      const baseDamage = 1 + PERMANENT_UPGRADES.attackDamage.effect(saveData.upgrades.attackDamage);
      const baseAtkSpeed = 1 + PERMANENT_UPGRADES.attackSpeed.effect(saveData.upgrades.attackSpeed);
      const baseCritChance = 0.1 + PERMANENT_UPGRADES.critChance.effect(saveData.upgrades.critChance);
      const baseCritDmg = 1.5 + PERMANENT_UPGRADES.critDamage.effect(saveData.upgrades.critDamage);
      const baseArmor = PERMANENT_UPGRADES.armor.effect(saveData.upgrades.armor);
      const cdReduction = PERMANENT_UPGRADES.cooldownReduction.effect(saveData.upgrades.cooldownReduction);
      
      // Reset Stats with permanent upgrades applied
      playerStats.lvl = 1;
      playerStats.exp = 0;
      playerStats.expReq = GAME_CONFIG.baseExpReq;
      playerStats.hp = baseHp;
      playerStats.maxHp = baseHp;
      playerStats.strength = baseDamage;
      playerStats.walkSpeed = baseSpeed;
      playerStats.kills = 0;
      playerStats.atkSpeed = baseAtkSpeed;
      playerStats.critChance = baseCritChance;
      playerStats.critDmg = baseCritDmg;
      playerStats.armor = baseArmor;
      playerStats.hpRegen = baseRegen;
      playerStats.gold = 0;
      waveCount = 0;
      gameStartTime = Date.now();
      runStartGold = saveData.gold;
      
      const gunCooldown = 1000 * (1 - cdReduction);
      weapons.gun = { active: true, level: 1, damage: 15, cooldown: gunCooldown, lastShot: 0, range: 12, barrels: 1 };
      weapons.sword = { active: false, level: 0, damage: 30, cooldown: 1500, lastShot: 0, range: 3.5 };
      weapons.aura = { active: false, level: 0, damage: 5, cooldown: 500, lastShot: 0, range: 3 };
      weapons.meteor = { active: false, level: 0, damage: 60, cooldown: 2500, lastShot: 0, area: 5 };
      weapons.lightning = { active: false, level: 0, damage: 25, cooldown: 3000, lastShot: 0, targets: 4 };
      weapons.doubleBarrel = { active: false, level: 0, damage: 25, cooldown: 1200, lastShot: 0, range: 12, spread: 0.3 };
      
      windmillQuest = { active: false, timer: 0, duration: 15, windmill: null, hasCompleted: false };
      document.getElementById('windmill-quest-ui').style.display = 'none';
      
      // Reset windmill HP
      if (scene) {
        scene.children.forEach(c => {
          if (c.userData.isWindmill) {
            c.userData.hp = 1000;
            c.userData.maxHp = 1000;
          }
        });
      }
      
      // Reset music
      musicOscillators.forEach(m => {
        m.osc.stop();
      });
      musicOscillators = [];
      currentMusicLevel = 0;
      updateBackgroundMusic();

      // Clear Entities
      enemies.forEach(e => {
        scene.remove(e.mesh);
        e.mesh.geometry.dispose();
        e.mesh.material.dispose();
      });
      enemies = [];
      
      expGems.forEach(e => {
        scene.remove(e.mesh);
        e.mesh.geometry.dispose();
        e.mesh.material.dispose();
      });
      expGems = [];
      
      goldCoins.forEach(g => {
        scene.remove(g.mesh);
        g.mesh.geometry.dispose();
        g.mesh.material.dispose();
      });
      goldCoins = [];

      projectiles.forEach(p => {
        scene.remove(p.mesh);
        p.mesh.geometry.dispose();
        p.mesh.material.dispose();
      });
      projectiles = [];
      
      particles.forEach(p => {
        scene.remove(p.mesh);
        p.mesh.geometry.dispose();
        p.mesh.material.dispose();
      });
      particles = [];
      
      // Clean up any active flash lights
      flashLights.forEach(light => {
        scene.remove(light);
      });
      flashLights = [];
      
      // Clear any pending timeouts
      activeTimeouts.forEach(timeoutId => {
        clearTimeout(timeoutId);
      });
      activeTimeouts = [];
      
      meteors.forEach(m => {
        scene.remove(m.mesh);
        scene.remove(m.shadow);
        m.mesh.geometry.dispose();
        m.mesh.material.dispose();
      });
      meteors = [];

      // Reset Player - Spawn beside the lake after emerging from water
      if (player) {
        player.mesh.position.set(50, 0.5, -30); // Spawn beside the lake (lake center at 30, 0.01, -30; radius 18)
        player.mesh.material.color.setHex(COLORS.player);
      }

      isGameOver = false;
      isPaused = false;
      isGameActive = true;
      document.getElementById('gameover-screen').style.display = 'none';
      updateHUD();
    }

    function toggleStats() {
      playSound('levelup'); // Add button sound
      const modal = document.getElementById('stats-modal');
      const levelUpModal = document.getElementById('levelup-modal');
      
      if (modal.style.display === 'flex') {
        modal.style.display = 'none';
        if (levelUpModal.style.display !== 'flex' && !isGameOver) {
          isPaused = false;
        }
      } else {
        // Calculate current run time
        const currentRunTime = isGameActive ? Math.floor((Date.now() - gameStartTime) / 1000) : 0;
        const goldThisRun = playerStats.gold - runStartGold;
        
        // Get permanent upgrade bonuses
        const permMaxHp = PERMANENT_UPGRADES.maxHp.effect(saveData.upgrades.maxHp);
        const permHpRegen = PERMANENT_UPGRADES.hpRegen.effect(saveData.upgrades.hpRegen);
        const permMoveSpeed = PERMANENT_UPGRADES.moveSpeed.effect(saveData.upgrades.moveSpeed);
        const permAttackDamage = PERMANENT_UPGRADES.attackDamage.effect(saveData.upgrades.attackDamage);
        const permAttackSpeed = PERMANENT_UPGRADES.attackSpeed.effect(saveData.upgrades.attackSpeed);
        const permCritChance = PERMANENT_UPGRADES.critChance.effect(saveData.upgrades.critChance);
        const permCritDamage = PERMANENT_UPGRADES.critDamage.effect(saveData.upgrades.critDamage);
        const permArmor = PERMANENT_UPGRADES.armor.effect(saveData.upgrades.armor);
        const permCooldownReduction = PERMANENT_UPGRADES.cooldownReduction.effect(saveData.upgrades.cooldownReduction);
        const permGoldEarned = PERMANENT_UPGRADES.goldEarned.effect(saveData.upgrades.goldEarned);
        const permExpEarned = PERMANENT_UPGRADES.expEarned.effect(saveData.upgrades.expEarned);
        const permMaxWeapons = saveData.upgrades.maxWeapons || 0;
        
        const content = document.getElementById('stats-content');
        content.innerHTML = `
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; max-width: 600px;">
  <div>
    <span style="color: #5DADE2; font-size: 16px; font-weight: bold; display: block; margin-bottom: 10px;">═══ BASE STATS ═══</span>
    <div style="display: grid; grid-template-columns: auto auto; gap: 5px 10px;">
      <span style="color: #aaa;">Max HP:</span><span style="color: #fff; text-align: right;">${playerStats.maxHp}</span>
      <span style="color: #aaa;">Current HP:</span><span style="color: #fff; text-align: right;">${Math.floor(playerStats.hp)}</span>
      <span style="color: #aaa;">HP Regen:</span><span style="color: #fff; text-align: right;">${playerStats.hpRegen}/s</span>
      <span style="color: #aaa;">Move Speed:</span><span style="color: #fff; text-align: right;">${playerStats.walkSpeed.toFixed(1)}</span>
      <span style="color: #aaa;">Attack Dmg:</span><span style="color: #fff; text-align: right;">${playerStats.strength.toFixed(2)}x</span>
      <span style="color: #aaa;">Attack Spd:</span><span style="color: #fff; text-align: right;">${playerStats.atkSpeed.toFixed(2)}x</span>
      <span style="color: #aaa;">Crit Chance:</span><span style="color: #fff; text-align: right;">${(playerStats.critChance*100).toFixed(1)}%</span>
      <span style="color: #aaa;">Crit Damage:</span><span style="color: #fff; text-align: right;">${(playerStats.critDmg*100).toFixed(0)}%</span>
      <span style="color: #aaa;">Armor:</span><span style="color: #fff; text-align: right;">${playerStats.armor.toFixed(0)}%</span>
    </div>
  </div>
  
  <div>
    <span style="color: #27ae60; font-size: 16px; font-weight: bold; display: block; margin-bottom: 10px;">═══ RUN STATS ═══</span>
    <div style="display: grid; grid-template-columns: auto auto; gap: 5px 10px;">
      <span style="color: #aaa;">Level:</span><span style="color: #fff; text-align: right;">${playerStats.lvl}</span>
      <span style="color: #aaa;">Kills:</span><span style="color: #fff; text-align: right;">${playerStats.kills}</span>
      <span style="color: #aaa;">Time:</span><span style="color: #fff; text-align: right;">${currentRunTime}s</span>
      <span style="color: #aaa;">Gold Earned:</span><span style="color: #fff; text-align: right;">${goldThisRun}</span>
    </div>
  </div>
</div>

<div style="margin-top: 20px;">
  <span style="color: #FFD700; font-size: 16px; font-weight: bold; display: block; margin-bottom: 10px;">═══ PERMANENT UPGRADES ═══</span>
  <div style="display: grid; grid-template-columns: auto auto; gap: 5px 15px; max-width: 400px;">
    <span style="color: #aaa;">Max HP:</span><span style="color: #fff; text-align: right;">+${permMaxHp}</span>
    <span style="color: #aaa;">HP Regen:</span><span style="color: #fff; text-align: right;">+${permHpRegen}/s</span>
    <span style="color: #aaa;">Move Speed:</span><span style="color: #fff; text-align: right;">+${(permMoveSpeed*100).toFixed(1)}%</span>
    <span style="color: #aaa;">Attack Damage:</span><span style="color: #fff; text-align: right;">+${(permAttackDamage*100).toFixed(1)}%</span>
    <span style="color: #aaa;">Attack Speed:</span><span style="color: #fff; text-align: right;">+${(permAttackSpeed*100).toFixed(1)}%</span>
    <span style="color: #aaa;">Crit Chance:</span><span style="color: #fff; text-align: right;">+${(permCritChance*100).toFixed(1)}%</span>
    <span style="color: #aaa;">Crit Damage:</span><span style="color: #fff; text-align: right;">+${(permCritDamage*100).toFixed(1)}%</span>
    <span style="color: #aaa;">Armor:</span><span style="color: #fff; text-align: right;">+${permArmor.toFixed(0)}%</span>
    <span style="color: #aaa;">Cooldown Reduction:</span><span style="color: #fff; text-align: right;">${(permCooldownReduction*100).toFixed(1)}%</span>
    <span style="color: #aaa;">Gold Bonus:</span><span style="color: #fff; text-align: right;">+${(permGoldEarned*100).toFixed(1)}%</span>
    <span style="color: #aaa;">EXP Bonus:</span><span style="color: #fff; text-align: right;">+${(permExpEarned*100).toFixed(1)}%</span>
    <span style="color: #aaa;">Max Weapons:</span><span style="color: #fff; text-align: right;">${permMaxWeapons}</span>
  </div>
</div>

<div style="margin-top: 20px;">
  <span style="color: #e74c3c; font-size: 16px; font-weight: bold; display: block; margin-bottom: 10px;">═══ LIFETIME STATS ═══</span>
  <div style="display: grid; grid-template-columns: auto auto; gap: 5px 15px; max-width: 300px;">
    <span style="color: #aaa;">Total Runs:</span><span style="color: #fff; text-align: right;">${saveData.totalRuns}</span>
    <span style="color: #aaa;">Best Time:</span><span style="color: #fff; text-align: right;">${saveData.bestTime}s</span>
    <span style="color: #aaa;">Best Kills:</span><span style="color: #fff; text-align: right;">${saveData.bestKills}</span>
    <span style="color: #aaa;">Total Gold:</span><span style="color: #fff; text-align: right;">${saveData.totalGoldEarned}</span>
  </div>
</div>
        `;
        modal.style.display = 'flex';
        isPaused = true;
      }
    }

    // --- INPUT SYSTEM ---
    function setupInputs() {
      const zone = document.getElementById('joystick-zone');
      const joystickOuter = document.getElementById('joystick-outer');
      const joystickInner = document.getElementById('joystick-inner');
      const joystickOuterRight = document.getElementById('joystick-outer-right');
      const joystickInnerRight = document.getElementById('joystick-inner-right');
      const container = document.getElementById('game-container');
      
      let touchStartX = 0;
      let touchStartY = 0;
      let touchStartTime = 0;
      let swipeDetected = false;
      
      zone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        
        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          const screenWidth = window.innerWidth;
          const screenHeight = window.innerHeight;
          
          // Ignore touches in top 40% of screen (for UI elements)
          if (touch.clientY < screenHeight * 0.6) {
            continue;
          }
          
          // Left half = movement joystick
          if (touch.clientX < screenWidth / 2 && !joystickLeft.active) {
            joystickLeft.id = touch.identifier;
            joystickLeft.active = true;
            joystickLeft.originX = touch.clientX;
            joystickLeft.originY = touch.clientY;
            
            // Store swipe start for dash detection
            swipeStart = { x: touch.clientX, y: touch.clientY, time: Date.now() };
            
            // Show dynamic joystick at touch position
            joystickOuter.style.display = 'block';
            joystickOuter.style.left = (touch.clientX - 60) + 'px';
            joystickOuter.style.top = (touch.clientY - 60) + 'px';
          }
          // Right half = aiming joystick
          else if (touch.clientX >= screenWidth / 2 && !joystickRight.active) {
            joystickRight.id = touch.identifier;
            joystickRight.active = true;
            joystickRight.originX = touch.clientX;
            joystickRight.originY = touch.clientY;
            
            // Show dynamic right joystick at touch position
            joystickOuterRight.style.display = 'block';
            joystickOuterRight.style.left = (touch.clientX - 60) + 'px';
            joystickOuterRight.style.top = (touch.clientY - 60) + 'px';
          }
        }
        
        swipeDetected = false;
      }, { passive: false });

      zone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        
        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          
          // Handle LEFT joystick (movement)
          if (touch.identifier === joystickLeft.id && joystickLeft.active) {
            const dx = touch.clientX - joystickLeft.originX;
            const dy = touch.clientY - joystickLeft.originY;
            
            // Check for dash swipe (250ms, 60px threshold)
            if (swipeStart && !swipeDetected && !player.isDashing) {
              const swipeDist = Math.sqrt(dx*dx + dy*dy);
              const swipeTime = Date.now() - swipeStart.time;
              
              if (swipeTime < 250 && swipeDist > 60) {
                // Perform dash in the exact direction of the swipe!
                swipeDetected = true;
                
                // Use the centralized dash method for proper direction handling
                // Pass normalized screen-space swipe direction
                const dist = Math.sqrt(dx*dx + dy*dy);
                player.dash(dx / dist, dy / dist);
                
                // Track dash
                playerStats.dashesPerformed++;
                
                // Reset swipe
                swipeStart = null;
              }
            }
            
            // Normalize
            const maxDist = 50;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const clampedDist = Math.min(dist, maxDist);
            
            if (dist > 0) {
              joystickLeft.x = (dx / dist) * (clampedDist / maxDist);
              joystickLeft.y = (dy / dist) * (clampedDist / maxDist);
              
              // Update inner joystick knob position
              joystickInner.style.left = '50%';
              joystickInner.style.top = '50%';
              joystickInner.style.transform = `translate(calc(-50% + ${joystickLeft.x * 35}px), calc(-50% + ${joystickLeft.y * 35}px))`;
            }
          }
          
          // Handle RIGHT joystick (aiming)
          if (touch.identifier === joystickRight.id && joystickRight.active) {
            const dx = touch.clientX - joystickRight.originX;
            const dy = touch.clientY - joystickRight.originY;
            
            // Normalize
            const maxDist = 50;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const clampedDist = Math.min(dist, maxDist);
            
            if (dist > 0) {
              joystickRight.x = (dx / dist) * (clampedDist / maxDist);
              joystickRight.y = (dy / dist) * (clampedDist / maxDist);
              
              // Update inner joystick knob position for right stick
              joystickInnerRight.style.left = '50%';
              joystickInnerRight.style.top = '50%';
              joystickInnerRight.style.transform = `translate(calc(-50% + ${joystickRight.x * 35}px), calc(-50% + ${joystickRight.y * 35}px))`;
            }
          }
        }
      }, { passive: false });

      const endJoystick = (e) => {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          
          if (touch.identifier === joystickLeft.id) {
            joystickLeft.active = false;
            joystickLeft.x = 0;
            joystickLeft.y = 0;
            
            // Reset swipe detection
            swipeStart = null;
            swipeDetected = false;
            
            // Hide joystick
            joystickOuter.style.display = 'none';
            joystickInner.style.transform = 'translate(-50%, -50%)';
          }
          
          if (touch.identifier === joystickRight.id) {
            joystickRight.active = false;
            joystickRight.x = 0;
            joystickRight.y = 0;
            
            // Hide right joystick
            joystickOuterRight.style.display = 'none';
            joystickInnerRight.style.transform = 'translate(-50%, -50%)';
          }
        }
      };

      zone.addEventListener('touchend', endJoystick);
      zone.addEventListener('touchcancel', endJoystick);

      // Restart Button
      document.getElementById('restart-btn').addEventListener('click', resetGame);
      document.getElementById('restart-btn').addEventListener('touchstart', (e) => {
        e.stopPropagation(); // Prevent joystick interference
      }, { passive: true });

      // Stats Button
      document.getElementById('stats-btn').addEventListener('click', toggleStats);
      document.getElementById('close-stats-btn').addEventListener('click', toggleStats);
      
      // Swipe Detection (Global - for dash)
      container.addEventListener('touchstart', (e) => {
        const t = e.changedTouches[0];
        touchStartX = t.clientX;
        touchStartY = t.clientY;
        touchStartTime = Date.now();
        swipeDetected = false;
      }, { passive: false });

      container.addEventListener('touchmove', (e) => {
        const t = e.changedTouches[0];
        const dx = t.clientX - touchStartX;
        const dy = t.clientY - touchStartY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        // If moved enough, mark as swipe
        if (dist > 30) {
          swipeDetected = true;
        }
      }, { passive: false });

      container.addEventListener('touchend', (e) => {
        const t = e.changedTouches[0];
        const dx = t.clientX - touchStartX;
        const dy = t.clientY - touchStartY;
        const dt = Date.now() - touchStartTime;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        // Quick swipe for dash (at least 40 pixels, less than 400ms)
        if (dt < 400 && dist > 40 && swipeDetected) {
           player.dash(dx/dist, dy/dist);
        }
      }, { passive: false });
      
      // Keyboard Controls (WASD for movement, mouse for aiming) - only register once
      if (!gameSettings.inputListenersRegistered) {
        const keysPressed = {};
        gameSettings.keysPressed = keysPressed; // Store reference for game loop access
        
        window.addEventListener('keydown', (e) => {
          if (!isGameActive || isPaused || isGameOver) return;
          if (gameSettings.controlType !== 'keyboard') return;
          keysPressed[e.key.toLowerCase()] = true;
          
          // Space bar for dash
          if (e.key === ' ' && !player.isDashing && (keysPressed['w'] || keysPressed['a'] || keysPressed['s'] || keysPressed['d'])) {
            let dx = 0, dy = 0;
            if (keysPressed['w']) dy = -1;
            if (keysPressed['s']) dy = 1;
            if (keysPressed['a']) dx = -1;
            if (keysPressed['d']) dx = 1;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 0) {
              // Delegate dash logic to the common player.dash() method
              const dashDx = dx / dist;
              const dashDz = dy / dist;
              player.dash(dashDx, dashDz);
            }
          }
        });
        
        window.addEventListener('keyup', (e) => {
          keysPressed[e.key.toLowerCase()] = false;
        });
        
        // Mouse Controls for aiming
        // Initialize mouse position to center of the viewport to avoid unexpected initial rotation
        gameSettings.lastMouseX = window.innerWidth / 2;
        gameSettings.lastMouseY = window.innerHeight / 2;
        
        window.addEventListener('mousemove', (e) => {
          gameSettings.lastMouseX = e.clientX;
          gameSettings.lastMouseY = e.clientY;
        });
        
        // Track gamepad button states to detect button press events
        gameSettings.gamepadButtonStates = { dashButton: false };
        
        gameSettings.inputListenersRegistered = true;
      }
    }

    function onWindowResize() {
      const aspect = window.innerWidth / window.innerHeight;
      let d = 20;
      
      // Landscape camera zoom - 50% closer in landscape mode
      const isPortrait = window.innerHeight > window.innerWidth;
      gameSettings.isPortrait = isPortrait;
      
      if (!isPortrait) {
        d *= 0.5; // Zoom in 50% for landscape
      }
      
      camera.left = -d * aspect;
      camera.right = d * aspect;
      camera.top = d;
      camera.bottom = -d;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function updateControlType() {
      const controlType = gameSettings.controlType;
      const joystickZone = document.getElementById('joystick-zone');
      
      if (controlType === 'touch') {
        joystickZone.style.display = 'block';
      } else {
        joystickZone.style.display = 'none';
      }
      
      // Additional setup for keyboard/gamepad controls could go here
    }

    // --- MAIN LOOP ---
    function animate(time) {
      requestAnimationFrame(animate);

      const dt = (time - lastTime) / 1000;
      lastTime = time;
      gameTime = time / 1000; // Update game time in seconds

      if (isPaused || isGameOver || !isGameActive) return;
      
      // Handle keyboard/gamepad input updates (integrated into game loop)
      if (gameSettings.controlType === 'keyboard') {
        const keysPressed = gameSettings.keysPressed || {};
        let x = 0, y = 0;
        if (keysPressed['w']) y = -1;
        if (keysPressed['s']) y = 1;
        if (keysPressed['a']) x = -1;
        if (keysPressed['d']) x = 1;
        
        if (x !== 0 || y !== 0) {
          const dist = Math.sqrt(x*x + y*y);
          joystickLeft.x = x / dist;
          joystickLeft.y = y / dist;
          joystickLeft.active = true;
        } else {
          joystickLeft.active = false;
          joystickLeft.x = 0;
          joystickLeft.y = 0;
        }
        
        // Mouse aiming
        if (renderer && renderer.domElement) {
          const rect = renderer.domElement.getBoundingClientRect();
          const mouseX = gameSettings.lastMouseX - rect.left;
          const mouseY = gameSettings.lastMouseY - rect.top;
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const dist = Math.sqrt(dx*dx + dy*dy);
          
          if (dist > 10) {
            joystickRight.x = dx / dist;
            joystickRight.y = dy / dist;
            joystickRight.active = true;
          } else {
            joystickRight.active = false;
            joystickRight.x = 0;
            joystickRight.y = 0;
          }
        }
      } else if (gameSettings.controlType === 'gamepad') {
        const gamepads = navigator.getGamepads();
        const gamepad = gamepads[0];
        
        if (gamepad) {
          // Left stick for movement
          const leftX = Math.abs(gamepad.axes[0]) > 0.1 ? gamepad.axes[0] : 0;
          const leftY = Math.abs(gamepad.axes[1]) > 0.1 ? gamepad.axes[1] : 0;
          
          if (leftX !== 0 || leftY !== 0) {
            joystickLeft.x = leftX;
            joystickLeft.y = leftY;
            joystickLeft.active = true;
          } else {
            joystickLeft.active = false;
            joystickLeft.x = 0;
            joystickLeft.y = 0;
          }
          
          // Right stick for aiming
          const rightX = Math.abs(gamepad.axes[2]) > 0.1 ? gamepad.axes[2] : 0;
          const rightY = Math.abs(gamepad.axes[3]) > 0.1 ? gamepad.axes[3] : 0;
          
          if (rightX !== 0 || rightY !== 0) {
            joystickRight.x = rightX;
            joystickRight.y = rightY;
            joystickRight.active = true;
          } else {
            joystickRight.active = false;
            joystickRight.x = 0;
            joystickRight.y = 0;
          }
          
          // Button 0 (A/X) for dash - detect button press (not hold)
          const dashPressed = gamepad.buttons[0].pressed;
          if (dashPressed && !gameSettings.gamepadButtonStates.dashButton && !player.isDashing && joystickLeft.active) {
            player.isDashing = true;
            player.dashTime = player.dashDuration;
            // Convert joystick direction to isometric world coordinates before dashing
            const inputX = joystickLeft.x;
            const inputY = joystickLeft.y;
            // Standard isometric transform from input (screen) space to world space
            // Use the centralized dash method for consistent behavior (iso conversion, effects, stats)
            player.dash(joystickLeft.x, joystickLeft.y);
          }
          gameSettings.gamepadButtonStates.dashButton = dashPressed;
        }
      }

      // Spawn Logic
      frameCount++;
      if (frameCount % GAME_CONFIG.waveInterval === 0) {
        spawnWave();
      }
      
      // HP Regen (Every 60 frames approx 1 sec)
      if (frameCount % 60 === 0 && playerStats.hpRegen > 0 && playerStats.hp < playerStats.maxHp) {
        playerStats.hp = Math.min(playerStats.maxHp, playerStats.hp + playerStats.hpRegen);
        updateHUD();
        // Green particle
        spawnParticles(player.mesh.position, 0x00FF00, 2);
      }

      // Player Update
      player.update(dt);
      
      // Check windmill quest trigger
      if (!windmillQuest.active && !windmillQuest.hasCompleted) {
        scene.children.forEach(child => {
          if (child.userData && child.userData.isWindmill) {
            const dist = player.mesh.position.distanceTo(child.position);
            // Check if player is in front of windmill (90 degree arc)
            const dx = player.mesh.position.x - child.position.x;
            const dz = player.mesh.position.z - child.position.z;
            const angle = Math.atan2(dz, dx);
            const isFront = Math.abs(angle) < Math.PI / 2; // Front 180 degree arc
            
            if (dist < 8 && isFront) {
              startWindmillQuest(child);
            }
          }
        });
      }
      
      // Update windmill quest
      if (windmillQuest.active) {
        windmillQuest.timer -= dt;
        updateWindmillQuestUI();
        
        if (windmillQuest.timer <= 0) {
          // Quest completed successfully
          completeWindmillQuest();
        } else if (windmillQuest.windmill && windmillQuest.windmill.userData.hp <= 0) {
          // Quest failed
          windmillQuest.active = false;
          document.getElementById('windmill-quest-ui').style.display = 'none';
        }
      }

      // --- WEAPONS ---
      
      // 1. GUN
      if (weapons.gun.active && time - weapons.gun.lastShot > weapons.gun.cooldown) {
        // Find nearest enemy
        let nearest = null;
        let minDst = Infinity;
        
        for (let e of enemies) {
          if (e.isDead) continue;
          const d = player.mesh.position.distanceTo(e.mesh.position);
          if (d < weapons.gun.range && d < minDst) {
            minDst = d;
            nearest = e;
          }
        }

        if (nearest) {
          // Fire based on barrels
          for(let i=0; i<weapons.gun.barrels; i++) {
            setTimeout(() => {
              projectiles.push(new Projectile(player.mesh.position.x, player.mesh.position.z, nearest.mesh.position));
              
              // Muzzle flash light effect
              // Enhanced muzzle flash light - brighter and more visible
              const flashLight = new THREE.PointLight(0xFFFFFF, 4, 15); // White for gunfire
              flashLight.position.copy(player.mesh.position);
              flashLight.position.y += 1;
              scene.add(flashLight);
              flashLights.push(flashLight);
              
              // Remove flash after short time
              const timeoutId = setTimeout(() => {
                scene.remove(flashLight);
                const idx = flashLights.indexOf(flashLight);
                if (idx > -1) flashLights.splice(idx, 1);
                const tidx = activeTimeouts.indexOf(timeoutId);
                if (tidx > -1) activeTimeouts.splice(tidx, 1);
              }, 80);
              activeTimeouts.push(timeoutId);
              
              // Lightning effect from gun - more visible
              const lightning = new LightningBolt(
                player.mesh.position.clone(),
                nearest.mesh.position.clone()
              );
              particles.push(lightning);
              
              // Muzzle flash particles (bright and intense) - increased count
              spawnParticles(player.mesh.position, 0xFFFF00, 8); // Increased from 5
              spawnParticles(player.mesh.position, 0xFFFFFF, 5); // Increased from 3
              spawnParticles(player.mesh.position, 0xFFA500, 5); // Increased from 3
            }, i * 100);
          }
          weapons.gun.lastShot = time;
          playSound('shoot');
        }
      }

      // 2. SWORD
      if (weapons.sword.active && time - weapons.sword.lastShot > weapons.sword.cooldown) {
        // Find enemy in front or just slash in movement dir
        // If moving, slash forward. If idle, slash nearest?
        // Let's slash in player rotation direction
        const angle = player.mesh.rotation.y;
        projectiles.push(new SwordSlash(player.mesh.position.x, player.mesh.position.z, angle));
        weapons.sword.lastShot = time;
        playSound('shoot'); // Reuse sound for now
      }

      // 3. AURA
      if (weapons.aura.active && time - weapons.aura.lastShot > weapons.aura.cooldown) {
        // Damage all in range
        let hit = false;
        enemies.forEach(e => {
          if (e.isDead) return;
          const d = player.mesh.position.distanceTo(e.mesh.position);
          if (d < weapons.aura.range) {
            e.takeDamage(weapons.aura.damage * playerStats.strength);
            hit = true;
          }
        });
        if (hit) {
          // Visual effect for aura tick?
          // Maybe just damage numbers
        }
        weapons.aura.lastShot = time;
      }

      // 4. METEOR
      if (weapons.meteor.active && time - weapons.meteor.lastShot > weapons.meteor.cooldown) {
        // Target random enemy or random spot near player
        let targetX = player.mesh.position.x + (Math.random() - 0.5) * 10;
        let targetZ = player.mesh.position.z + (Math.random() - 0.5) * 10;
        
        if (enemies.length > 0) {
          const e = enemies[Math.floor(Math.random() * enemies.length)];
          targetX = e.mesh.position.x;
          targetZ = e.mesh.position.z;
        }
        
        meteors.push(new Meteor(targetX, targetZ));
        weapons.meteor.lastShot = time;
      }

      // 5. LIGHTNING STRIKES
      if (weapons.lightning.active && time - weapons.lightning.lastShot > weapons.lightning.cooldown) {
        // Hit random enemies
        const targets = [];
        const aliveEnemies = enemies.filter(e => !e.isDead);
        
        // Select random enemies up to target count
        const targetCount = Math.min(weapons.lightning.targets, aliveEnemies.length);
        const shuffled = [...aliveEnemies].sort(() => 0.5 - Math.random());
        
        for(let i = 0; i < targetCount; i++) {
          const enemy = shuffled[i];
          targets.push(enemy);
          
          // Create lightning bolt from sky
          const lightning = new LightningBolt(
            new THREE.Vector3(enemy.mesh.position.x, 15, enemy.mesh.position.z),
            enemy.mesh.position.clone()
          );
          particles.push(lightning);
          
          // Flash effect - bright cyan for lightning
          const flashLight = new THREE.PointLight(0x00FFFF, 5, 20); // Cyan to match lightning color
          flashLight.position.copy(enemy.mesh.position);
          flashLight.position.y += 2;
          scene.add(flashLight);
          flashLights.push(flashLight);
          const timeoutId = setTimeout(() => {
            scene.remove(flashLight);
            const idx = flashLights.indexOf(flashLight);
            if (idx > -1) flashLights.splice(idx, 1);
            const tidx = activeTimeouts.indexOf(timeoutId);
            if (tidx > -1) activeTimeouts.splice(tidx, 1);
          }, 150);
          activeTimeouts.push(timeoutId);
          
          // Damage enemy
          const dmg = weapons.lightning.damage * playerStats.strength;
          const isCrit = Math.random() < playerStats.critChance;
          const finalDmg = isCrit ? dmg * playerStats.critDmg : dmg;
          enemy.takeDamage(finalDmg);
          createDamageNumber(finalDmg, enemy.mesh.position, isCrit);
          
          // Ground impact particles - 8 white + 6 purple sparks
          spawnParticles(enemy.mesh.position, 0xFFFFFF, 8); // White sparks
          spawnParticles(enemy.mesh.position, 0x7B68EE, 6); // Purple sparks
          
          // Chain Lightning - Find nearest enemy within 8 units at 60% damage
          const chainRange = 8;
          let chainTarget = null;
          let minChainDist = Infinity;
          
          for (let e of aliveEnemies) {
            if (e === enemy || e.isDead) continue;
            const dist = enemy.mesh.position.distanceTo(e.mesh.position);
            if (dist < chainRange && dist < minChainDist) {
              minChainDist = dist;
              chainTarget = e;
            }
          }
          
          if (chainTarget) {
            // Create chain lightning visual
            const chainLightning = new LightningBolt(
              enemy.mesh.position.clone(),
              chainTarget.mesh.position.clone()
            );
            chainLightning.mesh.material.color.setHex(0xADD8E6); // Light blue for chain
            particles.push(chainLightning);
            
            // Chain damage (60% of original)
            const chainDmg = finalDmg * 0.6;
            chainTarget.takeDamage(chainDmg);
            createDamageNumber(chainDmg, chainTarget.mesh.position, false);
            
            // Chain impact particles
            spawnParticles(chainTarget.mesh.position, 0xADD8E6, 8);
            
            // Chain flash
            const chainFlashLight = new THREE.PointLight(0xADD8E6, 2, 10);
            chainFlashLight.position.copy(chainTarget.mesh.position);
            chainFlashLight.position.y += 1;
            scene.add(chainFlashLight);
            flashLights.push(chainFlashLight);
            const chainTimeoutId = setTimeout(() => {
              scene.remove(chainFlashLight);
              const idx = flashLights.indexOf(chainFlashLight);
              if (idx > -1) flashLights.splice(idx, 1);
              const tidx = activeTimeouts.indexOf(chainTimeoutId);
              if (tidx > -1) activeTimeouts.splice(tidx, 1);
            }, 80);
            activeTimeouts.push(chainTimeoutId);
          }
        }
        
        weapons.lightning.lastShot = time;
        if (targets.length > 0) {
          playSound('shoot');
        }
      }

      // 6. DOUBLE BARREL
      if (weapons.doubleBarrel.active && time - weapons.doubleBarrel.lastShot > weapons.doubleBarrel.cooldown) {
        // Find nearest enemy
        let nearest = null;
        let minDst = Infinity;
        
        for (let e of enemies) {
          if (e.isDead) continue;
          const d = player.mesh.position.distanceTo(e.mesh.position);
          if (d < weapons.doubleBarrel.range && d < minDst) {
            minDst = d;
            nearest = e;
          }
        }

        if (nearest) {
          // Fire two shots with spread
          const baseDir = new THREE.Vector3(
            nearest.mesh.position.x - player.mesh.position.x,
            0,
            nearest.mesh.position.z - player.mesh.position.z
          ).normalize();
          
          // Left barrel
          const leftAngle = Math.atan2(baseDir.z, baseDir.x) - weapons.doubleBarrel.spread;
          const leftTarget = new THREE.Vector3(
            player.mesh.position.x + Math.cos(leftAngle) * weapons.doubleBarrel.range,
            0,
            player.mesh.position.z + Math.sin(leftAngle) * weapons.doubleBarrel.range
          );
          projectiles.push(new Projectile(player.mesh.position.x, player.mesh.position.z, leftTarget));
          
          // Right barrel
          const rightAngle = Math.atan2(baseDir.z, baseDir.x) + weapons.doubleBarrel.spread;
          const rightTarget = new THREE.Vector3(
            player.mesh.position.x + Math.cos(rightAngle) * weapons.doubleBarrel.range,
            0,
            player.mesh.position.z + Math.sin(rightAngle) * weapons.doubleBarrel.range
          );
          projectiles.push(new Projectile(player.mesh.position.x, player.mesh.position.z, rightTarget));
          
          // Effects
          const flashLight = new THREE.PointLight(0xFFFF00, 3, 12);
          flashLight.position.copy(player.mesh.position);
          flashLight.position.y += 1;
          scene.add(flashLight);
          flashLights.push(flashLight);
          const timeoutId = setTimeout(() => {
            scene.remove(flashLight);
            const idx = flashLights.indexOf(flashLight);
            if (idx > -1) flashLights.splice(idx, 1);
            const tidx = activeTimeouts.indexOf(timeoutId);
            if (tidx > -1) activeTimeouts.splice(tidx, 1);
          }, 80);
          activeTimeouts.push(timeoutId);
          
          spawnParticles(player.mesh.position, 0xFFFF00, 8);
          spawnParticles(player.mesh.position, 0xFFFFFF, 5);
          
          weapons.doubleBarrel.lastShot = time;
          playSound('shoot');
        }
      }
      
      // 7. ICE SPEAR
      if (weapons.iceSpear.active && time - weapons.iceSpear.lastShot > weapons.iceSpear.cooldown) {
        // Find nearest enemy
        let nearest = null;
        let minDst = Infinity;
        
        for (let e of enemies) {
          if (e.isDead) continue;
          const d = player.mesh.position.distanceTo(e.mesh.position);
          if (d < weapons.iceSpear.range && d < minDst) {
            minDst = d;
            nearest = e;
          }
        }

        if (nearest) {
          projectiles.push(new IceSpear(player.mesh.position.x, player.mesh.position.z, nearest.mesh.position));
          
          // Ice flash effect
          const flashLight = new THREE.PointLight(0x87CEEB, 3, 12); // Sky blue
          flashLight.position.copy(player.mesh.position);
          flashLight.position.y += 1;
          scene.add(flashLight);
          flashLights.push(flashLight);
          const timeoutId = setTimeout(() => {
            scene.remove(flashLight);
            const idx = flashLights.indexOf(flashLight);
            if (idx > -1) flashLights.splice(idx, 1);
            const tidx = activeTimeouts.indexOf(timeoutId);
            if (tidx > -1) activeTimeouts.splice(tidx, 1);
          }, 80);
          activeTimeouts.push(timeoutId);
          
          spawnParticles(player.mesh.position, 0x87CEEB, 8); // Ice blue particles
          spawnParticles(player.mesh.position, 0xFFFFFF, 5); // White particles
          
          weapons.iceSpear.lastShot = time;
          playSound('shoot');
        }
      }
      
      // 8. FIRE RING
      if (weapons.fireRing.active && time - weapons.fireRing.lastShot > weapons.fireRing.cooldown) {
        // Damage enemies within ring range
        let hit = false;
        enemies.forEach(e => {
          if (e.isDead) return;
          const d = player.mesh.position.distanceTo(e.mesh.position);
          if (d < weapons.fireRing.range) {
            const dmg = weapons.fireRing.damage * playerStats.strength;
            const isCrit = Math.random() < playerStats.critChance;
            const finalDmg = isCrit ? dmg * playerStats.critDmg : dmg;
            e.takeDamage(finalDmg);
            createDamageNumber(finalDmg, e.mesh.position, isCrit);
            
            // Fire particles on hit
            spawnParticles(e.mesh.position, 0xFF4500, 6); // Orange-red fire
            spawnParticles(e.mesh.position, 0xFFD700, 4); // Yellow flames
            hit = true;
          }
        });
        weapons.fireRing.lastShot = time;
      }

      // Entities Update
      enemies.forEach(e => e.update(dt, player.mesh.position));
      // Projectiles update returns false if dead
      projectiles = projectiles.filter(p => p.update() !== false);
      meteors = meteors.filter(m => m.update() !== false);
      expGems.forEach(g => g.update(player.mesh.position));
      goldCoins.forEach(g => g.update(player.mesh.position));
      particles = particles.filter(p => p.update() !== false);
      
      // Windmill Rotation and Light Animation
      scene.children.forEach(c => {
        if (c.userData.isWindmill) {
          // Rotate the blades stored in userData
          if (c.userData.blades && c.userData.blades.length > 0) {
            c.userData.blades[0].rotation.z += 0.05;
            c.userData.blades[1].rotation.z += 0.05;
          }
          
          // Animate windmill light (pulsing) with null check
          if (c.userData.light && c.userData.light.material) {
            c.userData.light.material.opacity = 0.8 + Math.sin(gameTime * 3) * 0.2;
          }
        }
        // Water ripple animation
        if (c.userData.isWaterRipple) {
          c.userData.phase += 0.05;
          const scale = 1 + Math.sin(c.userData.phase) * 0.1;
          c.scale.set(scale, 1, scale);
          c.material.opacity = 0.3 + Math.sin(c.userData.phase) * 0.2;
        }
        // Lake sparkles animation
        if (c.userData.isSparkle) {
          c.userData.phase += 0.02 * c.userData.speed;
          c.material.opacity = 0.3 + Math.abs(Math.sin(c.userData.phase)) * 0.7;
          c.scale.set(
            1 + Math.sin(c.userData.phase * 2) * 0.5,
            1,
            1 + Math.sin(c.userData.phase * 2) * 0.5
          );
        }
      });
      
      // Crystal tower animation
      scene.traverse(obj => {
        if (obj.userData.isCrystal) {
          // Rotate crystals
          obj.rotation.x += 0.01;
          obj.rotation.y += 0.02;
          
          // Orbit animation
          obj.userData.phase += 0.01 * obj.userData.orbitSpeed;
          const offsetY = Math.sin(obj.userData.phase) * 0.5;
          obj.position.y += offsetY * 0.05;
          
          // Pulsing emissive
          if (obj.material.emissiveIntensity !== undefined) {
            obj.material.emissiveIntensity = 0.3 + Math.sin(obj.userData.phase * 2) * 0.2;
          }
        }
        
        // Comet particle animation (orbiting particles)
        if (obj.userData.isCometParticle) {
          // Store the initial position as the orbit center (relative to parent/comet group)
          if (!obj.userData.basePosition) {
            obj.userData.basePosition = obj.position.clone();
          }
          
          obj.userData.angle += obj.userData.speed * 0.02;
          
          const centerX = obj.userData.basePosition.x;
          const centerZ = obj.userData.basePosition.z;
          const centerY = obj.userData.basePosition.y;
          
          obj.position.x = centerX + Math.cos(obj.userData.angle) * obj.userData.radius;
          obj.position.z = centerZ + Math.sin(obj.userData.angle) * obj.userData.radius;
          obj.position.y = centerY + obj.userData.height + Math.sin(obj.userData.angle * 2) * 0.3;
          
          // Pulsing opacity (between 0.3 and 0.7 for good visibility)
          obj.material.opacity = 0.5 + Math.sin(obj.userData.angle * 3) * 0.2;
        }
      });
      
      // Waterfall animation
      scene.traverse(obj => {
        if (obj.userData.isWaterfall) {
          obj.userData.phase += 0.05;
          obj.material.opacity = 0.6 + Math.sin(obj.userData.phase) * 0.1;
        }
        if (obj.userData.isWaterDrop) {
          obj.position.y -= obj.userData.speed;
          if (obj.position.y < 0) {
            obj.position.y = obj.userData.startY;
          }
        }
        if (obj.userData.isSplash) {
          obj.userData.phase += 0.1;
          const scale = 1 + Math.sin(obj.userData.phase) * 0.3;
          obj.scale.set(scale, 1, scale);
          obj.material.opacity = 0.4 + Math.sin(obj.userData.phase) * 0.2;
        }
      });

      // Cleanup
      enemies = enemies.filter(e => !e.isDead);
      expGems = expGems.filter(g => g.active);
      goldCoins = goldCoins.filter(g => g.active);

      renderer.render(scene, camera);
    }

    // Init Game
    try { init(); } catch(e) { console.error(e); alert("Game Error: " + e.message); }

  </script>
</body>
</html>